{  }
@inproceedings{Kuhn05a,
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
  title = {Enriching Reverse Engineering with Semantic Clustering},
  booktitle = {Proceedings of 12th Working Conference on Reverse Engineering (WCRE'05)},
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kuhn05aSemanticClustering.pdf},
  misc = {acceptance rate: 21/58 = 36 \%},
  doi = {10.1109/WCRE.2005.16},
  abstract = {Understanding a software system by just analyzing the structure of the system reveals only half of the picture, since the structure tells us only how the code is working but not what the code is about. What the code is about can be found in the semantics of the source code: names of identifiers, comments etc. In this paper, we analyze how these terms are spread over the source artifacts using Latent Semantic Indexing, an information retrieval technique. We use the assumption that parts of the system that use similar terms are related. We cluster artifacts that use similar terms, and we reveal the most relevant terms for the computed clusters. Our approach works at the level of the source code which makes it language independent. Nevertheless, we correlated the semantics with structural information and we applied it at different levels of abstraction (e.g. classes, methods). We applied our approach on three large case studies and we report the results we obtained.},
  acceptnum = {21},
  accepttotal = {58},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub semantic clustering lsi stefPub girba recast06 hapax moose kzVisualization kzRemodularisation},
  location = {Pittsburgh, PA},
  month = nov,
  rate = {36\%}}

@article{Kuhn07a,
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
  title = {Semantic Clustering: Identifying Topics in Source Code},
  journal = {Information and Software Technology},
  volume = {49},
  pages = {230--243},
  publisher = {Butterworth-Heinemann},
  year = {2007},
  pdf = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2006.10.017},
  abstract = {Many of the existing approaches in Software
 Comprehension focus on program program structure or
 external documentation. However, by analyzing formal
 information the informal semantics contained in the
 vocabulary of source code are overlooked. To
 understand software as a whole, we need to enrich
 software analysis with the developer knowledge
 hidden in the code naming. This paper proposes the
 use of information retrieval to exploit linguistic
 information found in source code, such as identifier
 names and comments. We introduce Semantic
 Clustering, a technique based on Latent Semantic
 Indexing and clustering to group source artifacts
 that use similar vocabulary. We call these groups
 semantic clusters and we interpret them as
 linguistic topics that reveal the intention of the
 code. We compare the topics to each other, identify
 links between them, provide automatically retrieved
 labels, and use a visualization to illustrate how
 they are distributed over the system. Our approach
 is language independent as it works at the level of
 identifier names. To validate our approach we
 applied it on several case studies, two of which we
 present in this paper.},
  address = {Newton, MA, USA},
  annote = {internationaljournal},
  issn = {0950-5849},
  keywords = {moose scg-pub recast07 girba stefPub kzRemodularisation},
  month = mar,
  number = {3}}

@inproceedings{Lien05a,
  author = {Adrian Lienhard and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
  title = {Identifying Traits with Formal Concept Analysis},
  booktitle = {Proceedings of 20th Conference on Automated Software Engineering (ASE'05)},
  pages = {66--75},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien05aIdentifyingTraits.pdf},
  misc = {acceptance rate: 28/291 = 9\%},
  doi = {10.1145/1101908.1101921},
  abstract = {Traits are basically mixins or interfaces but with
 method bodies. In languages that support traits,
 classes are composed out of traits. There are two
 main advantages with traits. Firstly, decomposing
 existing classes into traits from which they can be
 recomposed improves the factoring of hierarchies.
 Secondly it increases the library reuse potential by
 providing more reusable traits. Identifying traits
 and decomposing class hierarchies into traits is
 therefore an important and challenging task to
 facilitate maintainability and evolution. In this
 paper we present how we use Formal Concept Analysis
 to identify traits in inheritance hierarchies. Our
 approach is two-staged: first we identify within a
 hierarchy maximal groups of methods that have a set
 of classes in common, second we cluster cohesive
 groups of methods based on method invocations as
 potential traits. We applied our approach on two
 significant hierarchies and compare our results with
 the manual refactorization of the same code which
 was done by the authors of traits.},
  acceptnum = {28},
  accepttotal = {291},
  annote = {internationalconference topconference},
  cvs = {ConAnASE05Traits},
  keywords = {scg-pub snf05 recast06 stefPub moose arevalo jb06 listic kzRemodularisation kzTrait},
  medium = {2},
  month = nov,
  rate = {9\%}}

@article{Lien08c,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
  title = {Taking an Object-Centric View on Dynamic Information with Object Flow Analysis},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {35},
  pages = {63--79},
  publisher = {Elsevier},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien08cObjectFlowAnalysis.pdf},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2008.05.006},
  abstract = {A large body of research analyzes the runtime
 execution of a system to extract abstract behavioral
 views. Those approaches primarily analyze control
 flow by tracing method execution events or they
 analyze object graphs of heap snapshots. However,
 they do not capture how objects are passed through
 the system at runtime. We refer to the exchange of
 objects as the object flow, and we claim that object
 flow is necessary to analyze if we are to understand
 the runtime of an object-oriented application. We
 propose and detail Object Flow Analysis, a novel
 dynamic analysis technique that takes this new
 information into account. To evaluate its
 usefulness, we present a visual approach that allows
 a developer to study classes and components in terms
 of how they exchange objects at runtime. We
 illustrate our approach on three case studies.},
  annote = {internationaljournal},
  keywords = {scg-pub girba moose object-flow dynamic-analysis remoose kzReference kzVisualization},
  number = {1}}

@inproceedings{Lien07c,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
  title = {Object Flow Analysis --- Taking an Object-Centric View on Dynamic Analysis},
  booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL'07)},
  pages = {121--140},
  publisher = {ACM Digital Library},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien07c-ObjectFlowAnalysis.pdf},
  doi = {10.1145/1352678.1352686},
  abstract = {To extract abstract views of the behavior of an
 object-oriented system for reverse engineering, a
 body of research exists that analyzes a system's
 runtime execution. Those approaches primarily
 analyze the control flow by tracing method execution
 events. However, they do not capture information
 flows. We address this problem by proposing a novel
 dynamic analysis technique named Object Flow
 Analysis, which complements method execution tracing
 with an accurate analysis of the runtime flow of
 objects. To exemplify the usefulness of our analysis
 we present a visual approach that allows a system
 engineer to study classes and components in terms of
 how they exchange objects at runtime. We illustrate
 and validate our approach on two case studies.},
  address = {New York, NY, USA},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {scg-pub girba moose object-flow dynamic-analysis kzReference kzDynamicInformation},
  location = {Lugano, Switzerland},
  medium = {2}}

@inproceedings{Lien06a,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Capturing How Objects Flow At Runtime},
  booktitle = {Proceedings International Workshop on Program Comprehension through Dynamic Analysis (PCODA'06)},
  pages = {39--43},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
  abstract = {Most of today's dynamic analysis approaches are
 based on method traces. However, in the case of
 object-orientation understanding program execution
 by analyzing method traces is complicated because
 the behavior of a program depends on the sharing and
 the transfer of object references (aliasing). We
 argue that trace-based dynamic analysis is at a too
 low level of abstraction for object-oriented
 systems. We propose a new approach that captures the
 life cycle of objects by explicitly taking into
 account object aliasing and how aliases propagate
 during the execution of the program. In this paper,
 we present in detail our new meta-model and discuss
 future tracks opened by it.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub girba object-flow dynamic-analysis kzVisualization kzDynamicInformation},
  medium = {2}}

@inproceedings{Berg04c,
  author = {Alexandre Bergel and Christophe Dony and St\'ephane Ducasse},
  title = {Prototalk: an Environment for Teaching, Understanding, Designing and Prototyping Object-Oriented Languages},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  pages = {107--130},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg04c-ISC04-prototalk.pdf},
  abstract = {With prototype-based languages, concretization and abstraction are unified into a single concept a prototype. Prototype-based languages are based on a simple set of principles: object-centered representation, dynamic reshape of objects, cloning and possibly message delegation. However, they all differ in the interpretation and combination of these principles. Therefore there is a need to compare and understand. In this paper we present Prototalk, a research and teaching vehicle to understand, implement and compare prototype-based languages. Prototalk is a framework that offers a predefined set of language data structures and mechanisms that can be composed and extended to generate various prototype-based language interpreters. It presents a classification of languages based on different mechanisms in an operational manner.},
  annote = {internationalconference},
  hal-id = {inria-00533452},
  hal-url = {https://hal.inria.fr/hal-00533452},
  keywords = {stefPub alexPub kzPrototype},
  month = sep,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg04cprototalk.pdf}}

@inproceedings{Berg14a,
  author = {Alexandre Bergel and Sergio Maass and St\'ephane Ducasse and Tudor Girba},
  title = {A Domain-Specific Language For Visualizing Software Dependencies as a Graph},
  booktitle = {Vissoft'14, NIER Track},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg14a-Vissoft-DomainSpecific.pdf},
  abstract = {Graphs are commonly used to visually represent software dependencies. However, adequately visualizing software dependencies as a graph is a non-trivial problem due to the pluridimentional nature of software. We have designed a domain-specific language for visualizing software dependencies as graphs that is both expressive and concise. GRAPH, the implementation of our DSL, features a seamless mapping between visual dimensions to software metrics, composition of graph layouts, graph partition, and hierarchical bundle edges.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/hal-01369705},
  hal-id = {hal-01369705},
  keywords = {stefPub kzVisualization}}

@inproceedings{Berg09a,
  author = {Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues and Fran\c{c}oise Balmas and Karine Mordal-Manet},
  title = {SQUALE -- Software QUALity Enhancement},
  booktitle = {Proceedings of the 13th European Conference on Software Maintenance and Reengineering (CSMR'09), European Projects Track},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg09c-CSMR2009-Squale.pdf},
  annote = {internationalconference},
  hal-id = {hal-00746252},
  institution = {INRIA},
  keywords = {squale-pub lse-pub kzMetric},
  month = {mar},
  note = {Presentation}}

@article{Berg05e,
  author = {Alexandre Bergel and St\'ephane Ducasse},
  title = {Scoped and Dynamic Aspects with {Classboxes}},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet (Num\'ero sp\'ecial : Programmation par aspects)},
  volume = {11},
  pages = {53--68},
  publisher = {Hermes, Paris},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05eDynamicClassboxes.pdf},
  abstract = {Atomically introducing changes to a group of classes is a challenging task.
In addition, certain applications require that changes be applied dynamically without
shutting down and restarting the application. In this paper we present an extension of
classboxes to make them dynamic. A classbox is a kind of module that supports class
extension and instance variable addition. Class extensions and definitions defined in a
classbox represent an aspect. In addition, with classboxes, aspects are dynamically applied
to, removed from hot- in a system. Such aspects may crosscut a large number of classes
which are extended by adding or redefining existing methods and adding new instance
variables. Finally the aspects are scoped i.e., they are local to the classboxes that
define them.},
  annote = {nationaljournal},
  keywords = {classboxes stefPub alexPub kzClassbox kzAspect},
  month = nov,
  number = {3}}

@inproceedings{Berg05d,
  author = {Alexandre Bergel and St\'ephane Ducasse},
  title = {Supporting Unanticipated Changes with {Traits} and {Classboxes}},
  booktitle = {{Net}.{ObjectDays} (NODE'05)},
  pages = {61--75},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05dTraitsClassbox.pdf},
  abstract = {On the one hand, traits are a powerful way of structuring classes. Traits
support the reuse of method collections over several classes. However, traits cannot be
used when specifying unanticipated changes to an application. On the other hand, classboxes
are a new module system that supports the local redefinition of classes: a collection of
classes can be locally extended with variables and/or methods and the existing clients do
not get impacted by changes. However, an extension applied to a class by a classbox cannot
be reused for other classes. This paper describes how combining Traits and Classboxes
supports the safe introduction of crosscutting collaborations: safe because the existing
clients of the classes do not get impacted, crosscutting because collaborations between
several classes can be put in place in a unanticipated manner. In the resulting system, a
collaboration is represented by a classbox and a role by a trait.},
  address = {Erfurt, Germany},
  annote = {nationalconference},
  keywords = {alexPub stefPub kzClassBox kzTrait},
  month = sep}

@article{Berg08d,
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  title = {Creating Sophisticated Development Tools with {OmniBrowser}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {34},
  pages = {109--129},
  publisher = {Elsevier},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08d-JComputerLanguage-OmniBrowser.pdf},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2007.05.005},
  abstract = {Smalltalk is not only an object-oriented programming language; it is also
known for its extensive integrated development environment supporting interactive and
dynamic programming. While the default tools are adequate for browsing the code and
developing applications, it is often cumbersome to extend the environment to support new
language constructs or to build additional tools supporting new ways of navigating and
presenting source code. In this paper, we present the OmniBrowser, a browser framework that
supports the definition of browsers based on an explicit metamodel. With OmniBrowser a
domain model is described in a graph and the navigation in this graph is specified in its
associated metagraph. We present how new browsers are built from predefined parts and how
new tools are easily described. The browser framework is implemented in the Squeak
Smalltalk environment. This paper shows several concrete instantiations of the framework: a
remake of the ubiquitous Smalltalk System Browser, a coverage browser, the Duo Browser and
the Dynamic Protocols browser.},
  annote = {internationaljournal},
  keywords = {StefPub kzIDE},
  number = {2-3}}

@inproceedings{Berg07c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  title = {Meta-Driven Browsers},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
  volume = {4406},
  pages = {134--156},
  publisher = {Springer},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg07cOmnibrowser.pdf},
  doi = {10.1007/978-3-540-71836-9\_3},
  abstract = {Smalltalk is not only an object-oriented programming language; it is also known for its extensive integrated development environment supporting interactive and dynamic programming. While the default tools are adequate for browsing the code and developing applications, it is often cumbersome to extend the environment to support new language constructs or to build additional tools supporting new ways of navigating and presenting source code. In this paper, we present the OmniBrowser, a browser framework that supports the definition of browsers based on an explicit metamodel. With OmniBrowser a domain model is described in a graph and the navigation in this graph is specified in its associated metagraph. We present how new browsers are built from predefined parts and how new tools are easily described. The browser framework is implemented in the Squeak Smalltalk environment. This paper shows several concrete instantiations of the framework: a remake of the ubiquitous Smalltalk System Browser, and a coverage browser.},
  annote = {internationalconference},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {stefPub kzIDE},
  medium = {2},
  month = aug,
  series = {LNCS}}

@inproceedings{Berg08c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Jannik Laval and Romain Peirs},
  title = {Enhanced Dependency Structure Matrix for Moose},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08c-Famoosr2008-DSM.pdf},
  annote = {internationalworkshop},
  hal-id = {inria-00498484},
  keywords = {moose kzCycle}}

@article{Berg08a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Lukas Renggli},
  title = {Seaside -- Advanced Composition and Control Flow for Dynamic Web Applications},
  journal = {ERCIM News},
  volume = 72,
  year = {2008},
  abstract = {Page-centric Web application frameworks fail to offer adequate solutions to
model composition and control flow. Seaside allows Web applications to be developed in the
same way as desktop applications. Control flow is modelled as a continuous piece of code,
and components may be composed, configured and nested as one would expect from traditional
user interface frameworks.},
  annote = {vulgarisation},
  keywords = {alexPub stefPub kzWeb},
  month = jan}

@inproceedings{Berg05b,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Classbox/{J}: Controlling the Scope of Change in {Java}},
  booktitle = {Proceedings of 20th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'05)},
  pages = {177--189},
  publisher = {ACM Press},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05b-OOSPLA05-classboxJ.pdf},
  misc = {acceptance rate: 25/142 = 17\%},
  doi = {10.1145/1094811.1094826},
  abstract = {Unanticipated changes to complex software systems can introduce anomalies such as duplicated code, suboptimal inheritance relationships and a proliferation of run-time downcasts. Refactoring to eliminate these anomalies may not be an option, at least in certain stages of software evolution.	Classboxes are modules that restrict the visibility of changes to selected clients only, thereby offering more freedom in the way unanticipated changes may be implemented, and thus reducing the need for convoluted design anomalies. In this paper we demonstrate how classboxes can be implemented in statically-typed languages like {Java}. We also present an extended case study of Swing, a {Java} GUI package built on top of AWT, and we document the ensuing anomalies that Swing introduces. We show how Classbox/J, a prototype implementation of classboxes for {Java}, is used to provide a cleaner implementation of Swing using local refinement rather than subclassing.},
  acceptnum = {25},
  accepttotal = {142},
  address = {New York, NY, USA},
  annote = {internationalconference topconference},
  hal-id = {inria-00533461},
  hal-url = {https://hal.inria.fr/hal-00533461},
  keywords = {StefPub alexPub kzClassbox},
  rate = {17\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05bclassboxjOOPSLA.pdf}}

@article{Berg05c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Analyzing Module Diversity},
  journal = {Journal of Universal Computer Science},
  volume = {11},
  pages = {1613--1644},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05cModuleDiversity.pdf},
  impactfactor = {SCI impact factor 0.337},
  abstract = {Each object-oriented programming language proposes various grouping
mechanisms to bundle interacting classes (i.e., packages, modules, selector namespaces,
etc). To understand such diversity and to compare the different approaches, a common
foundation is needed. As far as we are aware of, no major attempt that would go in that
direction has been realized. In this paper we present a simple module calculus together
with a set of operators for modeling the composition semantics of different grouping
mechanisms. Using this module calculus we are able to express the semantics of {Java}
packages, C# namespaces, Ruby modules, selector namespaces, gbeta classes, classboxes,
MZScheme units, and MixJuice modules. This calculus supports the identification of system
families sharing similar characteristics. In addition it provides a uniform way to
represent and analyze fine-grained module semantics.},
  annote = {internationaljournal},
  keywords = {classbox stefPub alexPub kzClassbox kzModule},
  month = nov,
  number = {10}}

@article{Berg08e,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Stateful Traits and their Formalization},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {34},
  pages = {83--108},
  publisher = {Elsevier},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08e-JournalComputerLanguages-StatefulTraitsFormalization.pdf},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2007.05.003},
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially \emph{incomplete}, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  annote = {internationaljournal},
  issn = {1477-8424},
  keywords = {StefPub kzTrait},
  medium = {2},
  hal-id = {hal-02109190},
  number = {2-3}}

@article{Berg05a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Classboxes: Controlling Visibility of Class Extensions},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {31},
  pages = {107--126},
  publisher = {Elsevier},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05a-CompLangESUG04-classboxesJournal.pdf},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2004.11.002},
  abstract = {A class extension is a method that is defined in a module, but whose class is
defined elsewhere. Class extensions offer a convenient way to incrementally modify existing
classes when subclassing is inappropriate. Unfortunately existing approaches suffer from
various limitations. Either class extensions have a global impact, with possibly negative
effects for unexpected clients, or they have a purely local impact, with negative results
for collaborating clients. Furthermore, conflicting class extensions are either disallowed,
or resolved by linearization, with consequent negative effects. To solve these problems we
present classboxes, a module system for object-oriented languages that provides for method
addition and replacement. Moreover, the changes made by a classbox are only visible to that
classbox (or classboxes that import it), a feature we call local rebinding. To validate the
model we have implemented it in the Squeak Smalltalk environment, and performed
benchmarks.},
  annote = {internationaljournal},
  hal-id = {inria-00533458},
  hal-url = {https://hal.inria.fr/hal-00533458},
  keywords = {classbox stefPub kzClassbox},
  month = dec,
  number = {3-4},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05aclassboxesJournal.pdf}}

@inproceedings{Berg07a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Stateful Traits},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
  volume = {4406},
  pages = {66--90},
  publisher = {Springer},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg07a-InternationalSmalltalkConference07-StatefulTraits.pdf},
  doi = {10.1007/978-3-540-71836-9\_3},
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable
components while avoiding problems of fragility brought by multiple inheritance and mixins.
Traits as originally proposed are \emph{stateless}, that is, they contain only methods, but
no instance variables. State can only be accessed within traits by accessors, which become
\emph{required methods} of the trait. Although this approach works reasonably well in
practice, it means that many traits, viewed as software components, are artificially
\emph{incomplete}, and classes that use such traits may contain significant amounts of
boilerplate glue code. Although these limitations are largely mitigated by proper tool
support, we seek a cleaner solution that supports \emph{stateful traits}. The key
difficulty is how to handle conflicts that arise when composed traits contribute instance
variables whose names clash. We present a solution that is faithful to the guiding
principle of stateless traits: \emph{the client retains control of the composition}.
Stateful traits consist of a minimal extension to stateless traits in which instance
variables are purely local to the scope of a trait, unless they are explicitly made
accessible by the composing client of a trait. Naming conflicts are avoided, and variables
of disjoint traits can be explicitly merged by clients. We discuss and compare two
implementation strategies, and briefly present a case study in which stateful traits have
been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  annote = {internationalconference},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {StefPub traits kzTrait},
  medium = {2},
  month = aug,
  series = {LNCS}}

@inproceedings{Berg03b,
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  title = {The {Classbox} Module System},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03b-Workshop-Classboxes.pdf},
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  annote = {internationalworkshop},
  keywords = {stefPub alexPub module classbox kzClassBox},
  month = jul,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03bClassboxes.pdf}}

@inproceedings{Berg03a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
  booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
  volume = {2789},
  pages = {122--131},
  publisher = {Springer-Verlag},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03a-JMLC03-Classboxes.pdf},
  doi = {10.1007/b12023},
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  annote = {internationalconference},
  hal-id = {inria-00533446},
  isbn = {978-3-540-40796-6},
  keywords = {module classbox kzClassBox},
  note = {Best Paper Award},
  hal-url = {https://hal.inria.fr/hal-00533446},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03aClassboxes.pdf},
  series = {LNCS}}

@inproceedings{Berg08b,
  author = {Alexandre Bergel and Wolfgang De Meuter and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Dynamic Languages and Applications, Report on the Workshop {Dyla}'07 at {ECOOP} 2007},
  booktitle = {Object-Oriented Technology. ECOOP'07 Workshop Reader},
  volume = {4906},
  pages = {7--12},
  publisher = {Springer-Verlag},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Berg08b-Dyla07Report.pdf},
  doi = {10.1007/978-3-540-78195-0},
  abstract = {Following last two years' workshop on dynamic languages at the ECOOP
conference, the Dyla 2007 workshop was a successful and popular event. As its name implies,
the workshop's focus was on dynamic languages and their applications. Topics and
discussions at the workshop included macro expansion mechanisms, extension of the method
lookup algorithm, language interpretation, reflexivity and languages for mobile ad hoc
networks. The main goal of this workshop was to bring together different dynamic language
communities and favouring cross communities interaction. Dyla 2007 was organised as a full
day meeting, partly devoted to presentation of submitted position papers and partly devoted
to tool demonstration. All accepted papers can be downloaded from the workshop's web site.
In this report, we provide an overview of the presentations and a summary of discussions.},
  annote = {workshopproceedings},
  isbn = {978-3-540-78194-3},
  keywords = {stefPub scg-pub kzEditor},
  medium = {2},
  series = {LNCS}}

@inproceedings{Ali17a,
  author = {Alidra, Abdelghani and Saker, Moussa and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {Identifying class name inconsistency in hierarchy: a first simple heuristic},
  booktitle = {International Workshop on Smalltalk Technologies (IWST'17)},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Alid17a-IdentifyingClassNames-IWST17.pdf},
  doi = {10.1145/3139903.3139920},
  annote = {internationalworkshop},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01663603},
  hal-id = {hal-01663603},
  keywords = {kzVisualization kzEvolution lse-pub},
  tagnicolasa = {other analysis}}

@article{Hora15b,
  author = {Andr\'e Hora and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Automatic Detection of System-Specific Conventions Unknown to Developers},
  journal = {Journal of Systems and Software},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora15b-JSS-detection-specific-conventions.pdf},
  doi = {10.1016/j.jss.2015.08.007},
  hal-id = {hal-01185837},
  keywords = {lse-pub kzEvolution},
  tagnicolasa = {other analysis},
  annote = {internationaljournal}}

@inproceedings{Hora15a,
  author = {Andr\'e Hora and Romain Robbes and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {How Do Developers React to API Evolution? The Pharo Ecosystem Case},
  booktitle = {Proceedings of the 31st IEEE International Conference on Software Maintenance},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora15a-icsme-api-evolution.pdf},
  misc = {acceptance rate: 32/148 = 22\%},
  hal-id = {hal-01185736},
  keywords = {lse-pub},
  tagnicolasa = {other analysis},
  annote = {topconference}}

@inproceedings{Hora14a,
  author = {Andre Hora and Anne Etien and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {APIEvolutionMiner: Keeping API Evolution under Control},
  booktitle = {Proceedings of the Software Evolution Week (CSMR-WCRE'14)},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora14a-CSMR-WCRE-APIEvolutionMiner.pdf},
  misc = {acceptance rate: 27/86 = 31\%},
  abstract = {During software evolution, source code is constantly refactored. In real-world migrations, many methods in the newer version are not present in the old version (e.g., 60\% of the methods in Eclipse 2.0 were not in version 1.0). This requires changes to be consistently applied to reflect the new API and avoid further maintenance problems. In this paper, we propose a tool to extract rules by monitoring API changes applied in source code during system evolution. In this process, changes are mined at revision level in code history. Our tool focuses on mining invocation changes to keep track of how they are evolving. We also provide three case studies in order to evaluate the tool.},
  annote = {internationalconference},
  hal-id = {hal-00991722},
  keywords = {moose lse-pub cutter kzChecking},
  tagnicolasa = {other analysis}}

@inproceedings{Hora13a,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Mining System Specific Rules from Change Patterns},
  booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering (WCRE'13)},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora13a-MinedRules-WCRE13.pdf},
  misc = {Acceptance rate: 38/97 = 39\%},
  abstract = {A significant percentage of warnings reported by tools to detect coding standard violations are false positives. Thus, there are some works dedicated to provide better rules by mining them from source code history, analyzing bug-fixes or changes between system releases. However, software evolves over time, and during development not only bugs are fixed, but also features are added, and code is refactored. In such cases, changes must be consistently applied in source code to avoid maintenance problems. In this paper, we propose to extract system specific rules by mining systematic changes over source code history, i.e., not just from bug-fixes or system releases, to ensure that changes are consistently applied over source code. We focus on structural changes done to support API modification or evolution with the goal of providing better rules to developers. Also, rules are mined from predefined rule patterns that ensure their quality. In order to assess the precision of such specific rules to detect real violations, we compare them with generic rules provided by tools to detect coding standard violations on four real world systems covering two programming languages. The results show that specific rules are more precise in identifying real violations in source code than generic ones, and thus can complement them.},
  annote = {internationalconference},
  hal-id = {hal-00854861},
  keywords = {moose lse-pub cutter kzChecking},
  tagnicolasa = {other analysis}}

@inproceedings{Hora12a,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Muhammad Bhatti and Cesar Couto and Marco T\'ulio Valente and Julio Martins},
  title = {BugMaps: A Tool for the Visual Exploration and Analysis of Bugs},
  booktitle = {Proceedings of the 16th European Conference on Software Maintenance and Reengineering (CSMR'12) - Tool Demonstration Track},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora12a-Official-CSMR2012Tools-BugMaps.pdf},
  abstract = {To harness the complexity of big legacy software, software engineering tools need more and more information on these systems. This information may come from analysis of the source code, study of execution traces, computing of metrics, etc. One source of information received less attention than source code: the bugs on the system. Little is known about the evolutionary behavior, lifetime, distribution, and stability of bugs. In this paper, we propose to consider bugs as first class entities and a useful source of information that can answer such topics. Such analysis is inherently complex, because bugs are intangible, invisible, and difficult to be traced. Therefore, our tool extracts information about bugs from bug tracking systems, link this information to other software artifacts, and explore interactive visualizations of bugs that we call bug maps.},
  annote = {tooldemo},
  hal-id = {hal-00668397},
  keywords = {moose lse-pub raweb2012 kzVisualization},
  tagnicolasa = {other analysis}}

@inproceedings{Hora12b,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Simon Allier},
  title = {Domain Specific Warnings: Are They Any Better?},
  booktitle = {Proceedings of the 28th IEEE International Conference on Software Maintenance (ICSM'12)},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora12b-ICSM2012-DedicatedRules.pdf},
  misc = {acceptance rate: 46/181 = 25\%},
  abstract = {Tools to detect coding standard violations in source code are commonly used to improve code quality. One of their original goals is to prevent bugs, yet, a high number of false positives is generated by the rules of these tools, i.e., most warnings do not indicate real bugs. There are empirical evidences supporting the intuition that the rules enforced by such tools do not prevent the introduction of bugs in software. This may occur because the rules are too generic and do not focus on domain specific problems of the software under analysis. We underwent an investigation of rules created for a specific domain based on expert opinion to understand if such rules are worthwhile enforcing in the context of defect prevention. In this paper, we performed a systematic study to investigate the relation between generic and domain specific warnings and observed defects. From our experiment on a real case, long term evolution, software, we have found that domain specific rules provide better defect prevention than generic ones.},
  annote = {topconference internationalconference},
  hal-id = {hal-00848830},
  keywords = {moose lse-pub raweb2012 kzChecking},
  rate = {25\%},
  tagnicolasa = {other analysis}}

@book{Blac07a,
  author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  title = {Squeak by Example},
  publisher = {Square Bracket Associates},
  year = {2007},
  url = {https://github.com/SquareBracketAssociates/SqueakByExample-english},
  abstract = {Squeak by Example, intended for both students and developers, will guide you gently through the Squeak language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  annote = {book},
  isbn = {978-3-9523341-0-2},
  keywords = {skipdoimarcusdenker}}

@inproceedings{Blac03a,
  author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
  title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  volume = {38},
  pages = {47--64},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blac03a-OOSPLA03-TraitsHierarchy.pdf},
  misc = {acceptance rate: 26/142 = 18\%},
  doi = {10.1145/949305.949311},
  abstract = {Traits are a programming language technology that promote the reuse of
methods between unrelated classes. This paper reports on a refactoring of the Smalltalk
collections classes using traits. The original collection classes contained much
duplication of code; traits let us remove all of it. We also found places where the
protocols of the collections lacked uniformity; traits allowed us to correct these
non-uniformities without code duplication. Traits also make it possible to reuse fragments
of collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
number of methods in the collection classes by approximately 10 per cent. More importantly,
understandability maintainability and reusability of the code were significantly improved.},
  acceptnum = {26},
  accepttotal = {142},
  annote = {internationalconference topconference},
  keywords = {kzTrait},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blac03aTraitsHierarchy.pdf}}

@book{Blac09a,
  author = {Andrew P. Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  title = {Pharo by Example},
  pages = {333},
  publisher = {Square Bracket Associates},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/Blac09a-PBE1-2013-07-29.pdf},
  url = {http://books.pharo.org},
  abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo open-source Smalltalk language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  address = {Kehrsatz, Switzerland},
  annote = {book},
  hal-id = {hal-00849020},
  isbn = {978-3-9523341-4-0},
  keywords = {skipdoi pharo-pub marcusdenker kzPharo}}

@inproceedings{Dery96a,
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  title = {Inhibition et resynchronisation des contr\^oleurs de dialogue},
  booktitle = {Actes d'Interfaces Hommes Machine (IHM'96)},
  year = {1996},
  annote = {nationalconference},
  keywords = {stefPub kzDependency}}

@incollection{Dery96b,
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  title = {Objets et D\'ependances},
  booktitle = {Ing\'eni\`erie Objet},
  pages = {131--155},
  publisher = {Inter-Editions},
  year = {1996},
  annote = {articlebook},
  editor = {O. Mourad},
  keywords = {stefPub kzDependency},
  note = {ISBN: 2-7296-0642-4}}

@inproceedings{Auth12a,
  author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
  title = {Interop\'erabilit\'e des syst\`emes d'information : approches dirig\'ees par les mod\`eles},
  booktitle = {INFORSID},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Auth12a-interop-si-2012.pdf},
  abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and with no entropy creation. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
  annote = {nationalconference},
  hal-id = {hal-00707536},
  hal-url = {http://hal.inria.fr/hal-00707536},
  keywords = {moose lse-pub kzEvolution}}

@article{Auth13a,
  author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
  title = {Ing\'enierie dirig\'ee par les mod\`eles : quels supports \`a l'interop\'erabilit\'e des syst\`emes},
  journal = {Revue Ing\'enierie des Syst\`emes d'Information},
  volume = {18},
  pages = {9-40},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Auth13a-interop-si-JournalVersion.pdf},
  abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and without uncontrolled entropy. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
  annote = {nationaljournal},
  hal-id = {hal-00813675},
  hal-url = {http://hal.inria.fr/hal-00813675},
  keywords = {moose lse-pub kzReengineerig}}

@inproceedings{Raza09a,
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  title = {Multiple Viewpoints Architecture Extraction},
  booktitle = {Proceedings of the 2009 Joint Working IEEE/IFIP Conference on Software Architecture \& European Conference on Software Architectures},
  pages = {329--332},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raza09a-WASECSA-MultipleViewPoints.pdf},
  annote = {internationalconference},
  keywords = {moose lse-pub kzArchi}}

@inproceedings{Raza09b,
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  title = {Software System Understanding via Architectural Views Extraction According to Multiple Viewpoints},
  booktitle = {8th International Workshop on System/Software Architectures},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raza09b-iwssa-.pdf},
  annote = {internationalworkshop},
  keywords = {moose lse-pub kzArchi}}

@article{Sade02a,
  author = {Benny Sadeh and St\'ephane Ducasse},
  title = {Adding Dynamic Interfaces to {Smalltalk}},
  journal = {Journal of Object Technology},
  volume = {1},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sade02aDynamicInterfaces.pdf},
  abstract = {The concept of interfaces is central to
 object-oriented methodologies and is one of the most
 attractive features of {Java} and COM. Although
 Smalltalk always had interfaces implicitly, in
 Smalltalk interfaces are not first-class objects: t
 hey cannot be conversed with, referred to, or
 reflected upon. Consequently, Smalltalkers have been
 deprived of such an important and useful tool. Since
 a fundamental feature of Smalltalk is that just
 about everything in the language is an
 implementation feature, explicit, static interfaces
 can be added to Smalltalk using Smalltalk itself
 with ease. However, such an addition would
 short-change the powerful dynamic aspects of
 Smalltalk. In this article we present
 SmallInterfaces; a new ontology of dynamic i
 nterfaces which makes a powerful use of the dynamic
 nature of Smalltalk. SmallInterfaces adds interfaces
 as honorary members to Smalltalk's extensive
 reflection mechanism, in a manner portable across
 the many Smalltalk variants},
  annote = {internationaljournal},
  keywords = {scg-pub skip-doi stefPub kzLanguageDesign},
  number = {1}}

@book{Berg13a,
  author = {Bergel, Alexandre and Cassou, Damien and Ducasse, St\'ephane and Laval, Jannik},
  title = {{Deep Into Pharo}},
  pages = {420},
  publisher = {Square Bracket Associates},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/Berg13a-PBE2-ESUG-2013-09-06.pdf},
  url = {http://books.pharo.org},
  abstract = {Pharo is a dynamic object-oriented programming language. Pharo's model and syntax are uniform, simple and expressive. These properties, when added to a powerful and flexible programming environment, regularly attract new developers. The community around Pharo has been steadily increasing over the years. This community is actively creating exciting and innovative software artifacts helping the development of advanced software systems. Pharo heightens the software building experience to its best. It offers open and object-oriented programming environments and libraries. The book covers a large spectrum of topics ranging from central language aspects to innovative frameworks and libraries. This book contains unique material often presented in a tutorial form with many hand-on exercises. Everybody will learn something reading this book: programmers familiar with Pharo will enjoy the highlights made of some particularly beautiful aspects of Pharo as well as discovering new and powerful frameworks. Practitioners making their debut with Pharo will take on a wonderful journey in the realm of objects.	Deep into Pharo presents both internal aspects of Pharo and libraries that prove to be important for academic, business and development perspectives.},
  annote = {book},
  hal-id = {hal-00858725},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming pharo StefPub kzBook}}

@inproceedings{Bhat07a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse},
  title = {Surgical Information to Detect Design Problems with MOOSE},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop},
  keywords = {moose kzRemodularisation},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat07aFamoosRWorkshop.pdf},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat07aFamoosRWorkshop.pdf}}

@inproceedings{Bhat08a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
  title = {Aspect Mining in Procedural Object-Oriented Code},
  booktitle = {International Conference on Program Comprehension (ICPC'08)},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat08a-ICPC2008-AspectMining.pdf},
  annote = {internationalconference shortpaper},
  keywords = {moose kzAspect kzModule kzRemodularisation}}

@inproceedings{Bhat08b,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Marianne Huchard},
  title = {Reconsidering Classes in Procedural Object-Oriented Code},
  booktitle = {Proceedings of the 15th International Working Conference on Reverse Engineering (WCRE'08)},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat08b-WCRE2008-ObjectIdentification.pdf},
  annote = {internationalconference},
  keywords = {moose StefPub kzRemodularisation}}

@inproceedings{Blon15a,
  author = {Blondeau, Vincent and Anquetil, Nicolas and Ducasse, St\'ephane and Cresson, Sylvain and Croisy, Pascal},
  title = {Software metrics to predict the health of a project?},
  booktitle = {{International Workshop on Smalltalk Technologies IWST'15}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15a-IWST-PredictingProjectHealth.pdf},
  doi = {10.1145/2811237.2811294},
  hal-url = {https://hal.inria.fr/hal-01185079},
  hal-id = {hal-01185079},
  tagnicolasa = {metric},
  annote = {internationalworkshop},
  address = {Brescia, Italy},
  month = jul,
  keywords = {lse-pub ;	moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews, kzMetric}}

@inproceedings{Blon15b,
  author = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {{Predicting the Health of a Project? An Assessment in a Major IT Company}},
  booktitle = {{8th Seminar on Advanced Techniques \& Tools for Software Evolution (SATToSE'15)}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15b-SATToSE-PredictingProjectHealth.pdf},
  hal-url = {https://hal.inria.fr/hal-01205468},
  hal-id = {hal-01205468},
  tagnicolasa = {metric},
  address = {Mons, Belgium},
  annote = {internationalworkshop},
  month = jul,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews, kzMetric}}

@inproceedings{Blon15c,
  author = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {{Dynamic and Static Approaches Comparison for Test Suite Reduction in Industry}},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software eVOLution seminar}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15c-BENEVOL-TestSuiteReductionComparison.pdf},
  hal-url = {https://hal.inria.fr/hal-01317498},
  hal-id = {hal-01317498},
  tagnicolasa = {other test},
  address = {Lille, France},
  annote = {internationalworkshop},
  month = dec,
  keywords = {lse-pub ;	moose-pub ; pharo-pub ; static; dynamic; test; test selection, kzChecking}}

@inproceedings{Brun14a,
  author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
  title = {Benzo: Reflective Glue for Low-level Programming},
  booktitle = {International Workshop on Smalltalk Technologies 2014},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Brun14a-IWST-Benzo.pdf},
  abstract = {The goal of high-level low-level programming is to bring the abstraction capabilities of high-level languages to the system programming domain, such as virtual machines (VMs) and language runtimes. However, existing solutions are bound to compilation time and expose limited possibilities to be changed at runtime and from language-side. They do not fit well with fully reflective languages and environments.
We propose Benzo1, a lightweight framework for high- level low-level programming that allows developers to gen- erate and execute at runtime low-level code (assembly). It promotes the implementation, and dynamic modification, of system components with high-level language tools outper- forming existing dynamic solutions.
Since Benzo is a general framework we choose three ap- plications that cover an important range of the spectrum of system programming for validating the infrastructure: a For- eign Function Interface (FFI), primitives instrumentation and a just-in-time bytecode compiler (JIT). With Benzo we show that these typical VM-level components are feasible as reflective language-side implementations. Due to its unique combination of high-level reflection and low-level program- ming, Benzo shows better performance for these three ap- plications than the comparable high-level implementations.},
  annote = {internationalworkshop},
  hal-url = {http://hal.inria.fr/hal-01060551},
  hal-id = {hal-01060551},
  keywords = {pharo stefPub kzInfrastructure kzVM lse-pub}}

@inproceedings{Brun13a,
  author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
  title = {Language-side Foreign Function Interfaces with NativeBoost},
  booktitle = {International Workshop on Smalltalk Technologies 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Brun13a-NativeBoostIWST.pdf},
  abstract = {Foreign-Function-Interfaces (FGirb1FIs) are a prerequisite for close system integration of a high-level language. With FFIs the high-level environment interacts with low-level functions allowing for a unique combination of features. This duality has a strong impact on the implementation of the FFI: it has to be flexible and fast at the same time.
	We propose NativeBoost a language-side approach to FFIs that only requires minimal changes to the VM. NativeBoost directly creates specific native code at language-side and thus combines the flexibility of a language-side library with the performance of a native plugin.},
  annote = {internationalworkshop},
  hal-id = {hal-00840781},
  keywords = {pharo stefPub kzVM kzInfrastructure lse-pub}}

@article{Char18a,
  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan and Ducasse, St\'ephane},
  title = {Fully Reflective Execution Environments: Virtual Machines for More Flexible Software},
  journal = {Transaction on Software Engineering},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char18a-preprint-TSE-ReflectiveExecutionEnvironments.pdf},
  doi = {10.1109/TSE.2018.2812715},
  abstract = {VMs are complex pieces of software that implement programming language semantics in an efficient, portable, and secure way. Unfortunately, mainstream VMs provide applications with few mechanisms to alter execution semantics or memory management at run time. We argue that this limits the evolvability and maintainability of running systems for both, the application domain, e.g., to support unforeseen requirements, and the VM domain, e.g., to modify the organization of objects in memory. This work explores the idea of incorporating reflective capabilities into the VM domain and analyzes its impact in the context of software adaptation tasks. We characterize the notion of a fully reflective VM, a kind of VM that provides means for its own observability and modifiability at run time. This enables programming languages to adapt the underlying VM to changing requirements. We propose a reference architecture for such VMs and present TruffleMATE as a prototype for this architecture. We evaluate the mechanisms TruffleMATE provides to deal with unanticipated dynamic adaptation scenarios for security, optimization, and profiling aspects. In contrast to existing alternatives, we observe that TruffleMATE is able to handle all scenarios, using less than 50 lines of code for each, and without interfering with the application's logic.},
  annote = {internationaljournal},
  hal-id = {hal-01728111},
  keywords = {StePub kzLanguageDesign kzVM lse-pub},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char18a-preprint-TSE-ReflectiveExecutionEnvironments.pdf}}

@inproceedings{Hofe06a,
  author = {Christoph Hofer and Marcus Denker and St\'ephane Ducasse},
  title = {Design and Implementation of a Backward-In-Time Debugger},
  booktitle = {Proceedings of NODE'06},
  volume = {P-88},
  pages = {17--32},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hofe06a-NODE06-Unstuck.pdf},
  abstract = {Traditional debugging and stepping execution trace
 are well-accepted techniques to understand deep
 internals about a program. However in many cases
 navigating the stack trace is not enough to find
 bugs, since the cause of a bug is often not in the
 stack trace anymore and old state is lost, so out of
 reach from the debugger. In this paper, we present
 the design and implementation of a backward-in-time
 debugger for a dynamic language, i.e, a debugger
 that allows one to navigate back the history of the
 application. We present the design and
 implementation of a backward-in-time debugger called
 Unstuck and show our solution to key implementation
 challenges.},
  annote = {internationalconference},
  keywords = {skip-doi scg-pub stefPub jb07 fb06 snf06 fromscgbib marcusdenker kzDynamicInformation kzTools},
  medium = {2},
  month = sep,
  organization = {Gesellschaft f{\"u}r Informatik (GI)},
  series = {Lecture Notes in Informatics}}

@article{Bera16a,
  author = {Cl\'ement B\'era and Eliot Miranda and Marcus Denker and St\'ephane Ducasse},
  title = {Practical Validation of Bytecode to Bytecode JIT Compiler Dynamic Deoptimization},
  journal = {Journal of Object Technology},
  volume = {15},
  pages = {1:1-26},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera16aPracticalValidation-JOT.pdf},
  doi = {10.5381/jot.2016.15.2.a1.},
  hal-id = {hal-01299371},
  hal-url = {http://hal.inria.fr/hal-01299371},
  annote = {internationaljournal},
  abstract = {Speculative inlining in just-in-time compilers enables many performance optimizations. However, it also introduces significant complexity. The compiler optimizations themselves, as well as the deoptimization mechanism are complex and error prone. To stabilize our bytecode to bytecode just-in-time compiler, we designed a new approach to validate the correctness of dynamic deoptimization. The approach consists of the symbolic execution of an optimized and an unop-timized bytecode compiled method side by side, deoptimizing the abstract stack at each deoptimization point (where dynamic deoptimization is possible) and comparing the deoptimized and unoptimized abstract stack to detect bugs. The implementation of our approach generated tests for several hundred thousands of methods, which are now available to be run automatically after each commit.},
  keywords = {stefpub lse-pub marcusdenker kzLanguageDesign kzVM},
  number = {2}}

@incollection{Bera13b,
  author = {Cl\'ement Bera and St\'ephane Ducasse},
  title = {Handling Exceptions},
  booktitle = {Deep Into Pharo},
  pages = 38,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  annote = {articlebook},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming kzLanguageDesign kzPharo},
  month = sep}

@book{Cass15a,
  author = {Damien Cassou and St\'ephane Ducasse and Luc Fabresse and Johan Fabry and Van Caekenberghe, Sven},
  title = {Enterprise Pharo: a Web Perspective},
  pages = {278},
  publisher = {Square Bracket Associates},
  year = {2015},
  url = {http://books.pharo.org},
  annote = {book},
  hal-id = {hal-01223026}}

@inproceedings{Cass07a,
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  title = {Redesigning with Traits: the {Nile} Stream trait-based Library},
  booktitle = {ICDL'07: Proceedings of the 15th International Conference on Dynamic Languages},
  pages = {50--75},
  publisher = {ACM Digital Library},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass07a-TraitsStreamRedesign-ICDL.pdf},
  doi = {10.1145/1352678.1352682},
  abstract = {Recently, traits have been proposed as a single inheritance backward compatible solution in which the composing entity has the control over the trait composition. Traits are fine-grained units used to
 compose classes, while avoiding many of the problems
 of multiple inheritance and mixin-based approaches.
 To evaluate the expressiveness of traits, some
 hierarchies were refactored, showing code reuse.
 However, such large refactorings, while valuable,
 may not be facing all the problems, since the
 hierarchies were previously expressed within single
 inheritance and following certain patterns. We
 wanted to evaluate how traits enable reuse, and what
 problems could be encountered when building a
 library using traits from scratch, taking into
 account that traits are units of reuse. This paper
 presents our work on designing a new stream library
 named Nile. We present the reuse that we attained
 using traits, and the problems we encountered.},
  address = {Lugano, Switzerland},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {nile cook kzTrait},
  month = aug,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass07aTraitsStreamRedesign-ICDL.pdf}}

@article{Cass09a,
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  title = {Traits at Work: the design of a new trait-based stream library},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {35},
  pages = {2--20},
  publisher = {Elsevier},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass08a-ComputerLanguages-NileNewKernel.pdf},
  impactfactor = {Impact factor (2010) 0.619},
  doi = {10.1016/j.cl.2008.05.004},
  abstract = {Recent years saw the development of a composition
 mechanism called Traits. Traits are pure units of
 behavior that can be composed to form classes or
 other traits. The trait composition mechanism is an
 alternative to multiple or mixin inheritance in
 which the composer has full control over the trait
 composition. To evaluate the expressiveness of
 traits, some hierarchies were refactored, showing
 code reuse. However, such large refactorings, while
 valuable, may not exhibit all possible composition
 problems, since the hierarchies were previously
 expressed using single inheritance and following
 certain patterns. This paper presents our work on
 designing and implementing a new trait-based stream
 library named Nile. It evaluates how far traits
 enable reuse, what problems can be encountered when
 building a library using traits from scratch and
 compares the traits solution to alternative
 composition mechanisms. Nile's core allows the
 definition of compact collection and file streaming
 libraries as well as the implementation of a
 backward-compatible new stream library. Nile method
 size shows a reduction of 40\% compared to the Squeak
 equivalent. The possibility to reuse the same set of
 traits to implement two distinct libraries is a
 concrete illustration of trait reuse capability.},
  annote = {internationaljournal},
  hal-id = {inria-00216108},
  keywords = {kzTrait},
  number = {1},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass08a-NileNewKernel-ComputerLanguages.pdf}}

@inproceedings{Poll15a,
  author = {Damien Pollet and St\'ephane Ducasse},
  title = {A First Analysis of String APIs: the Case of Pharo},
  booktitle = {International Workshop on Smalltalk Technologies 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll15a-IWST2015-StringsAPI.pdf},
  abstract = {Most programming languages natively provide an abstraction of character strings. However, it is difficult to assess the design or the API of a string library.
There is no comprehensive analysis of the needed operations and their different variations. There are no real guidelines about the different forces in presence and how they structure the design space of string manipulation. In this article, we harvest and structure a set of criteria to describe a string API. We propose an analysis of the Pharo~4 String library as a first experience on the topic.},
  annote = {internationalworkshop},
  keywords = {pharo lse-pub kzLanguageDesign},
  note = {Best Paper Award},
  hal-id = {hal-01244486}}

@article{Poll17a,
  author = {Damien Pollet and St\'ephane Ducasse},
  title = {A critical analysis of string APIs: the case of Pharo},
  journal = {Science of Computer Programming},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll17a-SCICO-StringAPI.pdf},
  doi = {10.1016/j.scico.2017.11.005},
  month = nov,
  issn = {0167-6423},
  hal-id = {hal-01651250},
  abstract = {Most programming languages, besides C, provide a native
 abstraction for character strings, but string APIs vary widely
 in size, expressiveness, and subjective convenience across
 languages. In Pharo, while at first glance the API of the
 String class seems rich, it often feels cumbersome in
 practice; to improve its usability, we faced the challenge of
 assessing its design. However, we found hardly any guideline
 about design forces and how they structure the design space,
 and no comprehensive analysis of the expected string
 operations and their different variations. In this article, we
 first analyse the Pharo 4 String library, then contrast it
 with its Haskell, Java, Python, Ruby, and Rust counterparts.
 We harvest criteria to describe a string API, and reflect on
 features and design tensions. This analysis should help
 language designers in understanding the design space of
 strings, and will serve as a basis for a future redesign of
 the string library in Pharo.},
  annote = {internationaljournal},
  keywords = {lse-pub kzPharo}}

@inproceedings{Rati04a,
  author = {Daniel Ra{\c t}iu and St\'ephane Ducasse and Tudor G{\^\i}rba and Radu Marinescu},
  title = {Using History Information to Improve Design Flaws Detection},
  booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
  pages = {223--232},
  publisher = {IEEE Computer Society},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rati04aHistoryImproveFlawsDetection.pdf},
  misc = {acceptance rate: 33/62 = 52\%},
  abstract = {As systems evolve and their structure decays,
 maintainers need accurate and automatic
 identification of the design problems. Current
 approaches for automatic detection of design
 problems are not accurate enough because they
 analyze only a single version of a system and
 consequently they miss essential information as
 design problems appear and evolve over time. Our
 approach is to use the historical information of the
 suspected flawed structure to increase the accuracy
 of the automatic problem detection. Our means is to
 define measurements which summarize how persistent
 the problem was and how much maintenance effort was
 spent on the suspected structure. We apply our
 approach on a large scale case study and show how it
 improves the accuracy of the detection of God
 Classes and Data Classes, and additionally how it
 adds valuable semantical information about the
 evolution of flawed design structures.},
  acceptnum = {33},
  accepttotal = {62},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {recast04 scg-pub skip-doi stefPub jb04 moose girba ratiu evolution kzChecking kzMetric}}

@inproceedings{Roet09f,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {Autumn Leaves: Curing the Window Plague in IDEs},
  booktitle = {Proceedings of the 16th Working Conference on Reverse Engineering (WCRE 2009)},
  publisher = {IEEE Computer Society},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09f-WCRE2009-AutumnLeaves-ieee.pdf},
  misc = {Acceptance rate: 20/79 = 25\%},
  abstract = {Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.},
  address = {Los Alamitos, CA, USA},
  annote = {internationalconference},
  hal-id = {hal-00746246},
  keywords = {remoose2-pub pharo pharo-pub kzIDE},
  location = {Lille, France},
  rate = {25\%}}

@inproceedings{Roet09e,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Alexandre Bergel},
  title = {Tackling Software Navigation Issues of the Smalltalk IDE},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST'09)},
  publisher = {ACM Digital Library},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09e-IWST2009-obEnhancements.pdf},
  doi = {10.1145/1735935.1735945},
  abstract = {The IDE used in most Smalltalk dialects such as Pharo, Squeak or Cincom Smalltalk did not evolve
significantly over the last years, if not to say decades. For other languages, for instance Java, the
available IDEs made tremendous progress as Eclipse or NetBeans illustrate. While the Smalltalk
IDE served as an exemplar for many years, other IDEs caught up or even overtook the erstwhile
leader in terms of feature-richness, usability, or code navigation facilities.
In this paper we first analyze the difficulty of software navigation in the Smalltalk IDE and second
illustrate with concrete examples the features we added to the Smalltalk IDE to fill the gap to
modern IDEs and to provide novel, improved means to navigate source space. We show that
thanks to the agility and dynamics of Smalltalk, we are able to extend and enhance with reasonable
effort the Smalltalk IDE to better support software navigation, program comprehension, and software
maintenance in general. One such support is the integration of dynamic information into the static
source views we are familiar with. Other means include easing the access to static information
(for instance by better arranging important packages) or helping developers re-locating artifacts
of interest (for example with a categorization system such as smart groups).},
  annote = {internationalworkshop},
  hal-id = {hal-00746247},
  isbn = {9781605588995},
  keywords = {scg-sub jb10 roethlisberger remoose2-pub pharo pharo-pub kzIDE},
  location = {Brest, France}}

@inproceedings{Roet09a,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
  title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
  booktitle = {Proceedings of the 17th International Conference on Program Comprehension (ICPC'09)},
  pages = {253--257},
  publisher = {IEEE Computer Society},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09a-ICPC2009-HeatMaps.pdf},
  doi = {10.1109/ICPC.2008.32},
  abstract = {Mainstream IDEs generally rely on the static structure of a
 software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
  address = {Los Alamitos, CA, USA},
  annote = {internationalconference},
  hal-id = {inria-00498454},
  isbn = {978-0-7695-3176-2},
  keywords = {scg-pub roethlisberger kzIDE}}

@inproceedings{Roth11a,
  author = {David Rothlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {SmartGroups: Focusing on Task-Relevant Source Artifacts in IDEs},
  booktitle = {Proceedings of the 19th IEEE International Conference on Program Comprehension (ICPC'11)},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet11a-ICPC2011-smartGroups.pdf},
  misc = {Acceptance rate: 18/76 = 23\%},
  abstract = {Navigating large software systems, even when using a modern IDE is difficult, since conceptually related software artifacts are distributed in a huge software space.
For most software maintenance tasks, only a small fraction of the entire software space is actually relevant. The IDE, however, does not reveal the task relevancy of source artifacts, thus developers cannot easily focus on the artifacts required to accomplish their tasks.
Smart Groups help developers to perform software maintenance tasks by representing groups of source artifacts that are relevant for the current task. Relevancy is determined by analyzing historical navigation and modification activities, evolutionary information, and runtime information.
The prediction quality of Smart Groups is validated with a benchmark evaluation using recorded development activities and evolutionary information from versioning systems.},
  annote = {internationalconference},
  hal-id = {inria-00614779},
  keywords = {lse-pub raweb2011 pharo pharo-pub kzIDE},
  rate = {23\%},
  x-pays = {FR,CH}}

@inproceedings{Deho13a,
  author = {Dehouck, Mathieu and Bhatti, Usman and Bergel, Alexandre and Ducasse, St\'ephane},
  title = {Pragmatic Visualizations for Roassal: a Florilegium},
  booktitle = {International Workshop on Smalltalk Technologies},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deho13a-IWST2013-AlgoRoassal.pdf},
  abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits. This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.Software analysis and in particular reverse engineering often involves a large amount of structured data. This data should be pre- sented in a meaningful form so that it can be used to improve soft- ware artefacts. The software analysis community has produced nu- merous visual tools to help understand different software elements. However, most of the visualization techniques, when applied to software elements, produce results that are difficult to interpret and comprehend.
This paper presents five graph layouts that are both expressive for polymetric views and agnostic to the visualization engine. These layouts favor spatial space reduction while emphasizing on clarity. Our layouts have been implemented in the Roassal visualization engine and are available under the MIT License.},
  annote = {internationalworkshop},
  hal-id = {hal-00862065},
  keywords = {stefPub lse-pub kzVisualization}}

@inproceedings{Delp19a,
  author = {Delplanque, Julien and Ducasse, St\'ephane and Black, Andrew P. and Polito, Guillermo and Etien, Anne},
  title = {Rotten Green Tests},
  booktitle = {2019 International Conference on Software Engineering (ICSE)},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp19a-RottenGreenTests-ICSE2019-v2.pdf},
  abstract = {Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A green (passing) test is usually taken as a robust sign that the code under test is valid. However, some green tests contain assertions that are never executed. We call such tests Rotten Green Tests. Rotten Green Tests represent a case worse than a broken test: they report that the code under test is valid, but in fact do not test that validity. We describe an approach to identify rotten green tests by combining simple static and dynamic call-site analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. DrTest reports no false negatives, yet it still reports some false positives due to conditional use or multiple test contexts. Using DrTest we conducted an empirical evaluation of 19,905 real test cases in mature projects of the Pharo ecosystem. The results of the evaluation show that the tool is effective; it detected 294 tests as rotten-green tests that contain assertions that are not executed. Some rotten tests have been "sleeping" in Pharo for at least 5 years.},
  institution = {Inria},
  keywords = {lse-pub kzChecking},
  hal-id = {hal-02002346},
  hal-url = {https://hal.inria.fr/hal-02002346},
  annote = {topconference internationalconference}}

@inproceedings{Dema14a,
  author = {Demarey, Christophe and Cassou, Damien and Ducasse, St\'ephane},
  title = {Towards a new package dependency model},
  booktitle = {IWST'14: Proceedings of the 6th International Workshop on Smalltalk Technologies},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dema14a-esug2014-dependencies-model.pdf},
  address = {Cambridge, United Kingdom},
  hal-id = {hal-01086083},
  keywords = {package management system ; package manager ; dependency kzModularisation},
  annote = {internationalworkshop},
  month = {aug},
  hal-url = {https://hal.inria.fr/hal-01086083}}

@inproceedings{Deme18a,
  author = {Demeyer, Serge and Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {Evaluating the Efficiency of Continuous Testing during Test-Driven Development},
  booktitle = {Proceedings {VST 2018} (2nd IEEE International Workshop on Validation, Analysis and Evolution of Software Tests)},
  pages = {1 -- 5},
  year = {2018},
  url = {https://hal.inria.fr/hal-01717343},
  month = mar,
  tagnicolasa = {other test},
  annote = {internationalworkshop}}

@article{Duca01s,
  author = {Ducasse, St\'ephane},
  title = {Squeak: Introspection},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 37}

@techreport{Duca01c,
  author = {Ducasse, St\'ephane},
  title = {Reengineering Object-Oriented Applications},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca01cHab.pdf},
  abstract = {Reengineering object-oriented applications is becoming a vital activity in today industry where the developer turnover drains the system oral memory out of the systems themselves and where applications should constantly evolve to meet new requirements.	This document summarizes the research effort led on reverse engineering and reengineering ob ject-oriented legacy systems. It includes (1) the definition of a suitable meta-model for reengineering, FAMIX. This meta-model, even if flat, supports both reverse engineering and code refac- toring analysis, (2) the presentation of a reengineering platform, MOOSE, (3) the evalution of software metrics for reengineer, (4) the definition of simple visual techniques to support large system understanding or finer grain code element, (5) the identification and cure sup- port for duplicated code, (6) the use of dynamic information to support composable views and collaboration extraction, and (7) the identification of reengineer patterns.	Keywords. Meta-Modeling, Language Independence, Reengineering, Reverse Engineering, Code Duplication, Reengineering Patterns, Program Traces, Dynamic Information, Program Visualization, Software Metrics, Refactorings, Interexchange Format, CODECRAWLER, FAMIX, MOOSE, FAMOOS, Smalltalk, Java, C\+\+.},
  annote = {habilitation},
  institution = {Universit\'e Pierre et Marie Curie (Paris 6)},
  keywords = {scg-pub skip-doi jb-none reengineering snf02 stefPub moose kzHDR},
  month = sep,
  note = {TR University of Bern, Institute of Computer Science and Applied Mathematics --- iam-03-008}}

@inproceedings{Duca09b,
  author = {Ducasse, St\'ephane and Denker, Marcus and Lienhard, Adrian},
  title = {Evolving a Reflective Language},
  booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
  pages = {82--86},
  publisher = {ACM},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09b-IWST09-TraitMop.pdf},
  doi = {10.1145/1735935.1735949},
  abstract = {Traits are method groups that can be used to compose classes. They do not have a runtime existence and are conceptually folded into the classes that use them. Traits have been implemented in different languages. While implementing them in Smalltalk, our first reflex was to take advantage of the fact that traits are not run-time entities: we optimized the implementation for space and hence shared methods between traits and classes. However, by doing so we broke the introspective API of Smalltalk. This paper illustrates a more general problem seen in all reflective systems: the implementation serves both as a model for execution and as the model that is exposed to the programmer. There is a conflict of interests between the information necessary for execution and the information the programmer is interested in. In addition, as soon as the implementation is exposed via reflection, we are not free to optimize. As the complete implementation is visible reflectively, there is no way to hide the optimizations. Few papers report errors and this is one of them. We report our experience facing the initial API mismatch, which has a significant impact on the system because the language is reflective (i.e., written in itself and causally connected). We present the new introspective API we put in place.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {hal-00746130},
  isbn = {978-1-60558-899-5},
  keywords = {stefPub internationalworkshop lse-pub pharo pharo-pub kzTrait},
  location = {Brest, France},
  month = {aug},
  series = {IWST'09}}

@inproceedings{Duca16a,
  author = {Ducasse, St\'ephane and Eliot Miranda and Alain Plantec},
  title = {Pragmas: Literal Messages as Powerful Method Annotations},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca16a-Pragmas-IWST.pdf},
  doi = {10.1145/2991041.2991050},
  address = {Prague, Czech Republic},
  keywords = {stefPub lse-pub kzLanguageDesign},
  hal-id = {hal-01353592},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Duca00b,
  author = {Ducasse, St\'ephane and Lanza, Michele and Tichelaar, Sander},
  title = {Moose: an {Extensible} {Language}-{Independent} {Environment} for {Reengineering} {Object}-{Oriented} {Systems}},
  booktitle = {Proceedings of the 2nd International Symposium on Constructing Software Engineering Tools},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00bMooseCoset.pdf},
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. The reengineering of those systems often poses problems because of the considerable size and complexity of such systems. In the context of the FAMOOS project we have developed a language independent environment called Moose which can deal with that complexity. This paper describes the architecture of Moose, the tools which have been developed around it and the industrial experiences we have obtained.},
  annote = {internationalworkshop},
  keywords = {components scg-pub skip-doi repository oorp stefPub moose kzMoose},
  month = jun,
  series = {CoSET '00}}

@article{Duca09c,
  author = {Ducasse, St\'ephane and Pollet, Damien},
  title = {Software Architecture Reconstruction: A Process-Oriented Taxonomy},
  journal = {IEEE Transactions on Software Engineering},
  volume = {35},
  pages = {573-591},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09c-TSE-SOAArchitectureExtraction.pdf},
  impactfactor = {5-year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2009.19},
  abstract = {To maintain and understand large applications, it is crucial to know their
architecture. The first problem is that unlike classes and packages, architecture is not
explicitly represented in the code. The second problem is that successful applications
evolve over time, so their architecture inevitably drifts. Reconstructing the architecture
and checking whether it is still valid is therefore an important aid. While there is a
plethora of approaches and techniques supporting architecture reconstruction, there is no
comprehensive state of the art and it is often difficult to compare the approaches. This
article presents a state of the art in software architecture reconstruction approaches.},
  annote = {internationaljournal},
  hal-id = {inria-00498407},
  keywords = {lse-pub StefPub kzArchi},
  month = jul,
  number = 4}

@inproceedings{Duca09a,
  author = {Ducasse, St\'ephane and Pollet, Damien and Bergel, Alexandre and Cassou, Damien},
  title = {Reusing and Composing Tests with Traits},
  booktitle = {TOOLS'09: Proceedings of the 47th International Conference on Objects, Models, Components, Patterns},
  pages = {252--271},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09a-Tools2009-TraitTests.pdf},
  misc = {acceptance rate: 17/67 = 25\%},
  abstract = {Single inheritance often forces developers to
 duplicate code and logic. This widely recognized
 situation affects both business code and tests. In a
 large and complex application whose classes
 implement many groups of methods (protocols),
 duplication may also follow the application's
 idiosyncrasies, making it difficult to specify,
 maintain, and reuse tests. The research questions we
 faced are (i) how can we reuse test specifications
 across and within complex inheritance hierarchies,
 especially in presence of orthogonal protocols; (ii)
 how can we test interface behavior in a modular way;
 (iii) how far can we reuse and parametrize
 composable tests. In this paper, we compose tests
 out of separately specified behavioral units of
 reuse ---traits. We propose test traits, where: (i)
 specific test cases are composed from independent
 specifications; (ii) executable behavior
 specifications may be reused orthogonally to the
 class hierarchy under test; (iii) test fixtures are
 external to the test specifications, thus are easier
 to specialize. Traits have been successfully applied
 to test two large and critical class libraries in
 Pharo, a new Smalltalk dialect based on Squeak, but
 are applicable to other languages with traits.},
  acceptnum = {17},
  accepttotal = {67},
  address = {Zurich, Switzerland},
  annote = {internationalconference},
  coreranking = {B},
  hal-id = {inria-00403568},
  keywords = {tools09 traits stefPub pharo pharo-pub kzTrait},
  month = jun,
  rate = {24\%}}

@incollection{Duca19a,
  author = {Ducasse, St\'ephane and Rocha, Henrique and Bragagnolo, Santiago and Denker, Marcus and Francomme, Cl\'ement},
  title = {SmartAnvil: Open-Source Tool Suite for Smart Contract Analysis},
  booktitle = {Blockchain and Web 3.0: Social, economic, and technological challenges},
  publisher = {Routledge},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca18a-BookChapter-SmartAnvil.pdf},
  annote = {articlebook},
  abstract = {Smart contracts are new computational units with special properties: they act as classes with aspectual concerns; their memory structure is more complex than mere objects; they are obscure in the sense that once deployed it is difficult to access their internal state; they reside in an append-only chain. There is a need to support the building of new generation tools to help developers. Such support should tackle several important aspects: (1) the static structure of the contract, (2) the object nature of published contracts, and (3) the overall data chain composed of blocks and transactions. In this chapter, we present SmartAnvil an open platform to build software analysis tools around smart contracts. We illustrate the general components and we focus on three important aspects: support for static analysis of Solidity smart contracts, deployed smart contract binary analysis through inspection, and blockchain navigation and querying. SmartAnvil is open-source and supports a bridge to the Moose data and software analysis platform.},
  keywords = {kzEvolution kzBlockchain kzTools lse-pub stefpub},
  hal-id = {hal-01940287}}

@inproceedings{Dupr19a,
  author = {Dupriez, Thomas and Polito, Guillermo and Costiou, Steven and Aranega, Vincent and Ducasse, St\'ephane},
  title = {Sindarin: A Versatile Scripting API for the Pharo Debugger},
  booktitle = {DLS'19, Dynamic Language Symposium},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr19a-DLS2019-Official.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02280915v1},
  hal-id = {hal-02280915},
  annote = {internationalconference},
  keywords = {StefPub kzTools}}

@booklet{Lore17a,
  author = {Esteban Lorenzano and St\'ephane Ducasse and Johan Fabry and Norbert Hartl},
  title = {Voyage: Persisting Objects in Document Databases},
  pages = {46},
  publisher = {Square Bracket Associates},
  collection = {The Pharo Technology Collection},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-voyage.pdf},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  keywords = {skipdoi kzSmalltalk lse-pub kzPharo kzVulgarisation},
  hal-id = {hal-01612823}}

@inproceedings{Minj05a,
  author = {Florian Minjat and Alexandre Bergel and Pierre Cointe and St\'ephane Ducasse},
  title = {Mise en symbiose des traits et des classboxes : Application \`a l'expression des collaborations},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'05)},
  volume = {11},
  pages = {33--46},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Minj05a-TraitClassbox.pdf},
  abstract = {The trait model is complementary to class
 inheritance and allows collections of methods to be
 reused by several classes. The classbox model allows
 a collection of classes to be locally extended with
 variables and/or methods addition. This paper
 describes a symbiosis of these two models: classes
 can be locally extended by using a trait. It is
 illustrated by an efficient implementation of the
 collaboration model where a collaboration is
 represented by a classbox and a role by a trait.},
  address = {Bern, Switzerland},
  annote = {nationalconference},
  keywords = {traits classbox scg-pub skip-doi scg stefPub alexPub noWorkshop kzTrait kzClassbox}}

@article{Arev10a,
  author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Silvia Gordillo and Oscar Nierstrasz},
  title = {Generating a catalog of unanticipated schemas in class hierarchies using Formal Concept Analysis},
  journal = {Journal of Information and Software Technology},
  volume = {52},
  pages = {1167-1187},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev10a-IST-generatingCatalog.pdf},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2010.05.010},
  annote = {internationaljournal},
  hal-id = {inria-00531498},
  hal-url = {http://hal.inria.fr/inria-00531498},
  inriareport = {2010},
  issn = {0950-5849},
  keywords = {moose lse-pub cook StefPub treport2010 kzRemodularisation},
  month = dec,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev10a-IST-Official-generatingCatalog.pdf}}

@inproceedings{Arev03d,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Understanding Classes using {X-Ray} Views},
  booktitle = {Proceedings of 2nd International Workshop on MASPEGHI 2003 (ASE'03)},
  pages = {9--18},
  publisher = {CRIM --- University of Montreal (Canada)},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03d-MASPEGHI03-XRayViews.pdf},
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views --a technique based on Concept Analysis-- which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it to three Smalltalk classes: OrderedCollection, Scanner, and UIBuilder.},
  annote = {internationalworkshop},
  keywords = {snf04 scg-pub skip-doi tefPub arevalo jb04 moose kzRemodularisation},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03dMASPEGHI03XRayViews.pdf}}

@inproceedings{Arev05b,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Discovering Unanticipated Dependency Schemas in Class Hierarchies},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
  pages = {62--71},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05b-CSMR05-ClassHierarchies.pdf},
  impactfactor = {hors},
  misc = {acceptance rate: 33/81 = 41\%},
  doi = {10.1109/CSMR.2005.24},
  abstract = {Object-oriented applications are difficult to extend and maintain, due to the presence of implicit dependencies in the inheritance hierarchy. Although these dependencies of- ten correspond to well-known schemas, such as hook and template methods, new unanticipated dependency schemas occur in practice, and can consequently be hard to recognize and detect. To tackle this problem, we have applied Concept Analysis to automatically detect recurring dependency schemas in class hierarchies used in object-oriented applications. In this paper we describe our mapping of OO dependencies to the formal framework of Concept Analysis, we apply our approach to a non-trivial case study, and we report on the kinds of dependencies that are uncovered with this technique. As a result, we show how the discovered dependency schemas correspond not only to good design practices, but also to "bad smells" in design.},
  acceptnum = {33},
  accepttotal = {81},
  annote = {internationalconference},
  hal-id = {inria-00533057},
  keywords = {scg-pub arevalo jb05 recast05 StefPub moose kzRemodularisation},
  location = {Manchester, United Kingdom},
  month = mar,
  rate = {41\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05bCSMR05ClassHierarchies.pdf}}

@inproceedings{Arev03c,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {{X-Ray} Views: Understanding the Internals of Classes},
  booktitle = {Proceedings of 18th Conference on Automated Software Engineering (ASE'03)},
  pages = {267--270},
  publisher = {IEEE Computer Society},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03c-ASE03-XRayViews.pdf},
  doi = {10.1109/ASE.2003.1240318},
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views -- a technique based on Concept Analysis --	which reveal the internal relationships between groups of methods and attributes of a class. XRay views are com- posed out of elementary collaborations between attributes and methods, and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it on the Smalltalk class UIBuilder.},
  annote = {internationalconference},
  hal-id = {inria-00533054},
  keywords = {recast03 scg-pub stefPub moose arevalo jb04 kzRemodularisation},
  month = oct,
  note = {Short paper},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03cASE03XRayViews.pdf}}

@inproceedings{Arev05c,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Lessons Learned in Applying Formal Concept Analysis},
  booktitle = {Proceedings of 3rd International Conference on Formal Concept Analysis (ICFCA'05)},
  volume = {3403},
  pages = {95--112},
  publisher = {Springer Verlag},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05c-ICFCA05-LessonsLearned.pdf},
  impactfactor = {hors},
  doi = {10.1007/b105806},
  abstract = {A key difficulty in the maintenance and evolution of complex software systems is to recognize and understand the implicit dependencies that define contracts that must be respected by changes to the software. Formal Concept Analysis is a well-established technique for identifying groups of elements with common sets of properties. We have successfully applied FCA to complex software systems in order to automatically discover a variety of different kinds of implicit, recurring sets of dependencies amongst design artifacts. In this paper we describe our approach, outline three case studies, and draw various lessons from our experiences. In particular, we discuss how our approach is applied iteratively in order to draw the maximum benefit offered by FCA.},
  annote = {internationalconference},
  hal-id = {inria-00533445},
  hal-url = {http://hal.inria.fr/inria-00533445},
  keywords = {scg-pub jb05 recast05 arevalo StefPub kzRemodularisation},
  location = {Lens, France},
  month = feb,
  series = {LNAI (Lecture Notes in Artificial Intelligence)}}

@inproceedings{Gabs20a,
  author = {Gabsi, Hamdi and Drira, Rim and Hajjami Ben Gh\'ezala, Henda and Ducasse, St\'ephane},
  title = {From Business Process to Cloud Application},
  booktitle = {Proceeding of the 35th Conference of International Business Information Management Association (IBIMA'20)},
  publisher = {IEEE Computer Society Press},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gabs20-FromBusinessProcesstoCloudApplication-IBIMA2020.pdf},
  abstract = {Business Process (BP) development can be defined as the process of constructing a workflow application by composing a set of services performing BP's activities. In this respect, Cloud Services (CSs) are being increasingly used in BP development to ensure a high level of performance with a low operating cost. Although large companies may benefit from CSs' advantages, Small and Medium-sized Enterprises (SMEs) and startups are falling behind in cloud usage due to missing Information Technology competence, (IT-competence). The crucial challenge facing SMEs and startups in cloud-based BP development is to effectively address the so-called business and IT alignment issue. It represents the alignment between two different domains; one that entails technical cloud resource requirements and another comprising business-level. Formerly, we present this issue as a discovery challenge of suitable CSs performing abstract BP's activities. To address this challenge, firstly, we introduce the concept of cloud-aware BP by proposing a Domain-Specific Language (DSL) named "BP4Cloud" to enrich BP modeling and cover both business and technical requirements. Secondly, we propose an Activity-Services Matching algorithm that automates the discovery of CSs performing BP's activities.
As a part of the evaluation, we set up by clarifying the specification of BP4Cloud elements through a proof of concept implementation applied on a real BP. Then, we proceed by evaluating the precision and recall of our Activity-Service Matching algorithm.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-02533375},
  hal-id = {inria-00200869},
  keywords = {lse-pub StefPub kzOther},
  location = {Seville, Spain}}

@inproceedings{Govi17a,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Ducasse, St\'ephane and Monegier Du Sorbier, Arnaud},
  title = {{Managing an Industrial Software Rearchitecting Project With Source Code Labelling}},
  booktitle = {{Complex Systems Design \& Management conference  (CSD\&M)}},
  year = {2017},
  url = {https://hal.inria.fr/hal-02095200},
  tagnicolasa = {other tools},
  annote = {internationalworkshop},
  address = {Paris, France},
  month = dec,
  hal-id = {hal-02095200}}

@inproceedings{Govi16b,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{How Can We Help Software Rearchitecting Efforts ? Study of an Industrial Case}},
  booktitle = {{Proceedings of the International Conference on Software Maintenance and Evolution, (Industrial Track)}},
  year = {2016},
  url = {https://hal.archives-ouvertes.fr/hal-01451242v1},
  address = {Raleigh, USA},
  annote = {internationalconference},
  inria = {RMOD},
  month = oct,
  tagnicolasa = {architecture},
  keywords = {lse-pub ; tool-supported process ; migration ; industrial case},
  hal-id = {hal-01451242}}

@inproceedings{Govi15b,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Measuring the progress of an Industrial Reverse Engineering Process}},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software
 eVOLution seminar}},
  year = {2015},
  url = {https://hal.archives-ouvertes.fr/hal-01353203},
  address = {Lille, France},
  annote = {internationalworkshop},
  month = dec,
  keywords = {reverse engineering ; software process ; lse-pub},
  tagnicolasa = {metric},
  hal-id = {hal-01353203}}

@inproceedings{Govi15a,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Reverse Engineering Tool Requirements for Real Time Embedded Systems}},
  booktitle = {{Seminar on Advanced Techniques \& Tools for Software Evolution (SATToSE'15)}},
  year = {2015},
  url = {https://hal.inria.fr/hal-01187532},
  hal-url = {https://hal.inria.fr/hal-01187532},
  address = {Mons, Belgium},
  annote = {internationalworkshop},
  note = {Short paper},
  inria = {RMOD},
  month = jul,
  keywords = {reverse engineering tool},
  tagnicolasa = {other},
  hal-id = {hal-01187532}}

@inproceedings{Govi16a,
  author = {Govin, Brice and Anquetil, Nicolas and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Clustering Techniques for Conceptual Cluster}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  url = {https://hal.archives-ouvertes.fr/hal-01353205v1},
  doi = {10.1145/2991041.2991052},
  address = {Prague, Czech Republic},
  annote = {internationalworkshop},
  month = aug,
  keywords = {pharo-pub ; lse-pub ; clustering ; conceptual clusters ; industrial project ; architecture migration ; pharo},
  tagnicolasa = {other},
  hal-id = {hal-01353205}}

@inproceedings{Char15a,
  author = {Guido Chari and Diego Garbervetsky and Stefan Marr and St\'ephane Ducasse},
  title = {Towards Fully Reflective Environments},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char15a-Onward-ReflectiveVM.pdf},
  abstract = {Modern development environments promote live programming (LP) mechanisms because it enhances the development experience by providing instantaneous feedback and interaction with live objects. LP is typically supported with advanced reflective techniques within dynamic languages. These languages run on top of Virtual Machines (VMs) that are built in a static manner so that most of their components are bound at compile time. As a consequence, VM developers are forced to work using the traditional edit-compile-run cycle, even when they are designing LP-supporting environments. In this paper we explore the idea of bringing LP techniques to VM development to improve the observabil-ity, evolution and adaptability of VMs at run-time. We define the notion of fully reflective execution environments , systems that provide reflection not only at the application level but also at the level of the execution environment (EE). We characterize such systems, propose a design, and present Mate v1, a prototypical implementation. Based on our prototype, we analyze the feasibility and applicability of incorporating reflective capabilities into different parts of EEs. Furthermore, the evaluation demonstrates the opportunities such reflective capabilities provide for unanticipated dynamic adaptation scenarios, benefiting thus, a wider range of users.},
  annote = {internationalconference},
  hal-id = {hal-01185843},
  keywords = {kzReflection kzLanguageDesign stefPub lse-pub},
  numpages = {10}}

@inproceedings{Larc15a,
  author = {Guillaume Larcheveque and Usman Bhatti and Nicolas Anquetil and St\'ephane Ducasse},
  title = {Telescope: A High-Level Model to Build Dynamic Visualizations},
  booktitle = {International Workshop on Smalltalk Technologies (IWST'15)},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Larc15a-Telescope-IWST.pdf},
  hal-id = {hal-02864587},
  keywords = {kzVisualization},
  annote = {internationalworkshop},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02864587}}

@article{Poli17c,
  author = {Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Run-Fail-Grow: Creating Tailored Object-Oriented Runtimes},
  journal = {The Journal of Object Technology},
  volume = {16},
  publisher = {Chair of Software Engineering},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17c-JOT-Tornado.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01609295},
  doi = {10.5381/jot.2017.16.3.a2},
  annote = {internationaljournal},
  abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts at runtime. Thus, an application often occupies more memory than actually needed. Tailoring is one of the main solutions to this problem i.e., extracting used code units such as classes and methods of an application. However, existing tailoring techniques are mostly based on static type annotations. These techniques cannot efficiently tailor applications in all their extent (e.g., runtime object graphs and metadata) nor be used in the context of dynamically-typed languages. We propose a run-fail-grow technique to tailor applications using their runtime execution. Run-fail-grow launches (a) a reference application containing the original application to tailor and (b) a nurtured application containing only a seed with a minimal set of code units the user wants to ensure in the final application. The nurtured application is executed, failing when it founds missing objects, classes or methods. On failure, the necessary elements are installed into the nurtured application from the reference one, and the execution resumes. The nurtured application is executed until it finishes, or until the developer explicitly finishes it, for example in the case of a web application. resulting in an object memory (i.e., a heap) with only objects, classes and methods required to execute the application. To validate our approach we implemented a tool based on Virtual Machine modifications, namely Tornado. Tornado succeeds to create very small memory footprint versions of applications e.g., a simple object-oriented heap of 11kb. We show how tailoring works on application code, base and third-party libraries even supporting human interaction with user G. interfaces. These experiments show memory savings ranging from 95\% to 99\%.},
  number = {3},
  keywords = {lse-pub kzLanguageDesign kzInfrastructure},
  pdf-second = {http://www.jot.fm/issues/issue_2017_03/article2.pdf},
  hal-id = {hal-01609295}}

@inproceedings{Poli17b,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse},
  title = {First-Class Undefined Classes for Pharo},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {9:1--9:8},
  publisher = {ACM},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17b-IWST-UndefinedClasses.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01585305},
  doi = {10.1145/3139903.3139914},
  annote = {internationalworkshop},
  abstract = {Loading code inside a Pharo image is a daily concern for a Pharo developer. Nevertheless, several problems may arise at loading time that can prevent the code to load or even worse let the system in an inconsistent state. In this paper, we focus on the problem of loading code that references a class that does not exist in the system. We discuss the different flavors of this problem, the limitations of the existing Undeclared mechanism and the heterogeneity of Pharo tools to solve it. Then, we propose an unified solution for Pharo that reifies Undefined Classes. Our model of Undefined Classes is the result of an objective selection among different alternatives. We then validate our solution through two cases studies: migrating old code and loading code with circular dependencies. This paper also presents the integration of this solution into Pharo regarding the needed Meta-Object Protocol for Undefined Classes and the required modifications of existing tools.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {9},
  numpages = {8},
  address = {New York, NY, USA},
  inria = {RMOD},
  keywords = {Software engineering ; Programming languages ; Pharo ; Reflection ; Dynamic Languages ; Partial Code Loading; lse-pub kzLanguageDesign},
  hal-id = {hal-01585305}}

@article{Poli17d,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse and Camille Teruel},
  title = {Scoped Extension Methods in Dynamically-Typed Languages},
  journal = {The Art, Science, and Engineering of Programming},
  volume = {2},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17d-Programming-ScopedExtensions.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01609310},
  doi = {10.22152/programming-journal.org/2018/2/1},
  annote = {internationaljournal},
  number = {1},
  month = aug,
  keywords = {lse-pub kzLanguageDesign},
  hal-id = {hal-01609310}}

@inproceedings{Sant17a,
  author = {Gustavo Santos and Kl\'erisson Paixao and Nicolas Anquetil and Anne Etien and Marcelo Maia and St\'ephane Ducasse},
  title = {Recommending Source Code Locations for System Specific Transformations},
  booktitle = {24th IEEE International Conference on Software Analysis, Evolution, and Reengineering},
  pages = {1--10},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant17a-saner-2017.pdf},
  misc = {acceptance rate: 34/140 = 24\%},
  hal-id = {hal-01441790},
  keywords = {lse-pub kzAnalysis kzEvolution},
  abstract = {From time to time, developers perform sequences of code transformations in a systematic and repetitive way. This may happen, for example, when introducing a design pattern in a legacy system: similar classes have to be introduced, containing similar methods that are called in a similar way. Automation of these sequences of transformations has been proposed in the literature to avoid errors due to their repetitive nature. However, developers still need support to identify all the relevant code locations that are candidate for transformation. Past research showed that these kinds of transformation can lag for years with forgotten instances popping out from time to time as other evolutions bring them into light. In this paper, we evaluate three distinct code search approaches (structural, based on Information Retrieval, and AST based algorithm) to find code locations that would require similar transformations. We validate the resulting candidate locations from these approaches on real cases identified previously in literature. The results show that looking for code with similar roles, e.g., classes in the same hierarchy, provides interesting results with an average recall of 87\% and in some cases the precision up to 70%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant17a-saner-2017.pdf},
  annote = {topconference},
  keywords = {lse-pub kzAnalysis kzEvolution},
  tagnicolasa = {other largescale}}

@inproceedings{Sant15c,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {OrionPlanning: Improving Modularization and Checking Consistency on Software Architecture},
  booktitle = {3rd IEEE Working Conference on Software Visualization (VISSOFT 2015) -- Tool track},
  pages = {190--194},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15c-VISSOFT-OrionPlanning.pdf},
  hal-id = {hal-01185635},
  keywords = {moose lse-pub kzEvolution},
  abstract = {Many techniques have been proposed in the literature to support architecture definition, conformance, and analysis. However, there is a lack of adoption of such techniques by the industry. Previous work have analyzed this poor support. Specifically, former approaches lack proper analysis techniques (e.g., detection of architectural inconsistencies), and they do not provide extension and addition of new features. In this paper, we present ORIONPLANNING, a prototype tool to assist refactorings at large scale. The tool provides support for model- based refactoring operations. These operations are performed in an interactive visualization. The contributions of the tool consist in: (i) providing iterative modifications in the architecture, and (ii) providing an environment for architecture inspection and definition of dependency rules. We evaluate ORIONPLANNING against practitioners' requirements on architecture definition listed in a previous survey. We also evaluate the tool in a concrete example of software remodularization.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15c-VISSOFT-OrionPlanning.pdf},
  selectif = {yes},
  annote = {internationalconference},
  tagnicolasa = {largescale architecture}}

@inproceedings{Sant15b,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Recording and Replaying System Specific, Source Code Transformations},
  booktitle = {15th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM'15)},
  pages = {221--230},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15b-SCAM-MacroRecorder.pdf},
  hal-id = {hal-01185639},
  keywords = {moose lse-pub kzEvolution},
  abstract = {During its lifetime, a software system is under continuous maintenance to remain useful. Maintenance can be achieved in activities such as adding new features, fixing bugs, improving the system's structure, or adapting to new APIs. In such cases, developers sometimes perform sequences of code changes in a systematic way. These sequences consist of small code changes (e.g., create a class, then extract a method to this class), which are applied to groups of related code entities (e.g., some of the methods of a class). This paper presents the design and proof-of-concept implementation of a tool called MACRORECORDER. This tool records a sequence of code changes, then it allows the developer to generalize this sequence in order to apply it in other code locations. In this paper, we discuss MACRORECORDERs approach that is independent of both development and transformation tools. The evaluation is based on previous work on repetitive code changes related to rearchitecting. MACRORECORDER was able to replay 92\% of the examples, which consisted in up to seven code entities modified up to 66 times. The generation of a customizable, large-scale transformation operator has the potential to efficiently assist code maintenance},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15b-SCAM-MacroRecorder.pdf},
  annote = {internationalconference},
  tagnicolasa = {other largescale}}

@inproceedings{Sant15a,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {System Specific, Source Code Transformations},
  booktitle = {31st IEEE International Conference on Software Maintenance and Evolution},
  pages = {221--230},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15a-ICSME-TransformationPatterns.pdf},
  misc = {acceptance rate: 32/148 = 22\%},
  hal-id = {hal-01185637},
  keywords = {moose lse-pub kzEvolution},
  abstract = {During its lifetime, a software system might undergo a major transformation effort in its structure, for example to mi- grate to a new architecture or bring some drastic improvements to the system. Particularly in this context, we found evidences that some sequences of code changes are made in a systematic way. These sequences are composed of small code transformations (e.g., create a class, move a method) which are repeatedly applied to groups of related entities (e.g., a class and some of its methods). A typical example consists in the systematic introduction of a Factory design pattern on the classes of a package. We define these sequences as transformation patterns. In this paper, we identify examples of transformation patterns in real world software systems and study their properties: (i) they are specific to a system; (ii) they were applied manually; (iii) they were not always applied to all the software entities which could have been transformed; (iv) they were sometimes complex; and (v) they were not always applied in one shot but over several releases. These results suggest that transformation patterns could benefit from automated support in their application. From this study, we propose as future work to develop a macro recorder, a tool with which a developer records a sequence of code transformations and then automatically applies them in other parts of the system as a customizable, large-scale transformation operator.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15a-ICSME-TransformationPatterns.pdf},
  annote = {topconference},
  tagnicolasa = {other analysis}}

@inproceedings{Casa11a,
  author = {Gwenael Casaccio and St\'ephane Ducasse and Luc Fabresse and Jean-Baptiste Arnaud and van Ryseghem, Benjamin},
  title = {Bootstrapping a Smalltalk},
  booktitle = {Proceedings of Smalltalks 2011 International Workshop},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Casa11a-Smalltalks-BootstrappingASmalltalk.pdf},
  abstract = {Smalltalk is a reflective system. It means that it is defined in itself in a causally connected way. Traditionally, Smalltalk systems evolved by modifying and cloning what is called an image (a chunk of memory containing all the objects at a given point in time). During the evolution of the system, objects representing it are modified. However, such an image modification and cloning poses several problems: (1) There is no operational machine-executable algorithm that allows one to build a system from scratch. A system object may be modified but it may be difficult to reproduce its exact state before the changes. Therefore it is difficult to get a reproducible process. (2) As a consequence, certain classes may not have been initialized since years. (3) Finally, since the system acts as a living system, it is not simple to evolve the kernel for introducing new abstractions without performing some kind of brain surgery on oneself. There is a need to have a step by step process to build Smalltalk kernels from scratch. In this paper, after an analysis of past and current practices to mutate or generate kernels, we describe a kernel bootstrap process step-by-step. First the illusion of the existence of a kernel is created via stubs objects. Second the classes and meta-classes hierarchy are generated. Code is compiled and finally information needed by the virtual machine and execution are generated and installed.},
  address = {Bernal, Buenos Aires, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00636785},
  keywords = {pharo-pub lse-pub raweb2011 kzReflection}}

@inproceedings{Abde13a,
  author = {Hani Abdeen and Houari Sahraoui and Osama Shata and Nicolas Anquetil and St\'ephane Ducasse},
  title = {Towards Automatically Improving Package Structure While Respecting Original Design Decisions},
  booktitle = {International Working Conference on Reverse Engineering (WCRE'13)},
  publisher = {IEEE Computer Society Press},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde13a-ImprovingPackageStructure-WCRE13.pdf},
  misc = {Acceptance rate: 38/97 = 39\%},
  abstract = {Recent studies have largely investigated the detection of class design anomalies. They proposed a large set of metrics that help in detecting those anomalies and in predicting the quality of class design. While those studies and the proposed metrics are valuable, they do not address the particularities of Java interfaces. Interfaces define the contracts that spell out how software modules and logic units interact with each other. This paper proposes a list of design anomalies related to Java interfaces. We identify and describe those anomalies via real examples, taken from well-known Java applications. Then we define three metrics help in automatically estimate the interface design quality, regarding the proposed design anomalies. We evaluate our metrics on three large Java applications. The results show that our metrics are realistic and help in qualifying the interface design, and in identifying candidate refactoringRecently, there has been an important progress in applying search-based optimization techniques to the problem of software re-modularization. Yet, a major part of the existing body of work addresses the problem of modularizing software systems from scratch, regardless of the existing packages structure. This paper presents a novel multi-objective optimization approach for improving existing packages structure. The optimization ap- proach aims at increasing the cohesion and reducing the coupling and cyclic connectivity of packages, by modifying as less as pos- sible the existing packages organization. Moreover, maintainers can specify several constraints to guide the optimization process with regard to extra design factors. To this contribution, we use the Non-Dominated Sorting Genetic Algorithm (NSGA-II). We evaluate the optimization approach through an experiment covering four real-world software systems. The results promise the effectiveness of our optimization approach for improving existing packages structure by doing very small modifications.},
  annote = {internationalconference},
  hal-id = {hal-00862063},
  hal-url = {http://hal.inria.fr/inria-00862063},
  keywords = {moose cutter lse-pub kzMetric StefPub kzInterface},
  tagnicolasa = {architecture}}

@inproceedings{Abde08b,
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  title = {Package Reference Fingerprint: a Rich and Compact Visualization to Understand Package Relationships},
  booktitle = {Proceeding of the 12th European Conference on Software Maintenance and Reengineering (CSMR'08)},
  pages = {213--222},
  publisher = {IEEE Computer Society Press},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde08b-CSMR2008-Fingerprint.pdf},
  misc = {Acceptance rate: 24/87 = 27\%},
  abstract = {Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages, allowing classes to be organized into named abstractions. Maintainers of large applications need to understand how packages are structured and how they relate to each other, but this task is very complex because packages often have multiple clients and different roles (class container, code ownership...). Cohesion and coupling are still among the most used metrics, because they help identify candidate packages for restructuring; however, they do not help maintainers understand the structure and interrelationships between packages. In this paper, we present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable visualization centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system. We applied these views on three large case studies: JBoss, Azureus, and ArgoUML.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00200869},
  hal-id = {inria-00200869},
  keywords = {moose cook-pub lse-pub StefPub kzVisualization},
  location = {Athens, Greece},
  rate = {27\%}}

@inproceedings{Abde07a,
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  title = {Package References Distribution Fingerprint},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop},
  keywords = {moose StefPub kzVisualization lse-pub}}

@article{Abde10a,
  author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui},
  title = {Package Fingerprint: a visual summary of package interfaces and relationships},
  journal = {Information and Software Technology Journal},
  volume = {52},
  pages = {1312-1330},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde10a-IST-Official-packageFingerprints.pdf},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2010.07.005},
  abstract = {Context: Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages. Maintainers of large systems need to understand how packages relate to each other, but this task is complex because packages often have multiple clients and play different roles (class container, code ownership. . . ). Several approaches have been proposed, among which the use of cohesion and coupling metrics. Such metrics help identify candidate packages for restructuring; however, they do not help maintainers actually understand the structure and interrelation- ships between packages.
Objectives: In this paper, we use pre-attentive processing as the basis for package visualization and see to what extent it could be used in package understanding.
Method: We present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable views centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system.
Results: We applied these views on four large systems: Squeak, JBoss, Azureus, and ArgoUML. We obtained several interesting results, among which, the identification of a set of recurring visual patterns that help maintainers: (a) more easily identify the role of and the way a package is used within the system (e.g., the package under analysis provides a set of layered services), and, (b) detect either problematic situations (e.g., a single package that groups together a large number of basic services) or opportunities for better package restructuring (e.g., removing cyclic dependencies among packages). The visualization generally scaled well and the detection of different patterns was always possible.
Conclusion: The proposed visualizations and patterns proved to be useful in understanding and maintaining the different systems we addressed. To generalize to other contexts and systems, a real user study is required.},
  annote = {internationaljournal},
  hal-id = {inria-00531496},
  hal-url = {http://hal.inria.fr/inria-00531496},
  keywords = {moose remoose2 lse-pub StePub cook kzVisualisation}}

@article{Abde14a,
  author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui and Jean-R\'emy Falleri},
  title = {The Package Blueprint: Visually analyzing and quantifying packages dependencies},
  journal = {Science of Computer Programming},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde14a-Official-PackageBlueprint-SCP.pdf},
  impactfactor = {5-Year ISI impact factor (2010) 4.865},
  annote = {internationaljournal},
  hal-id = {00957695},
  hal-url = {http://hal.inria.fr/inria-00957695},
  keywords = {lse-pub StefPub kzVisualization},
  month = feb}

@inproceedings{Abde11a,
  author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui},
  title = {Modularization Metrics: Assessing Package Organization in Legacy Large Object-Oriented Software},
  booktitle = {Proceedings of the 18th IEEE International Working Conference on Reverse Engineering (WCRE'11)},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde11a-WCRE-ModularizationMetrics-INRIA.pdf},
  misc = {Short paper, acceptance rate: 50/104 = 48\%},
  abstract = {There exist many large object-oriented software systems consisting of several thousands of classes that are organized into several hundreds of packages. In such software systems, classes cannot be considered as units for software modularization. In such context, packages are not simply classes containers, but they also play the role of modules: a package should focus to provide well identified services to the rest of the software system. Therefore, understanding and assessing package organization is primordial for software maintenance tasks. Although there exist a lot of works proposing metrics for the quality of a single class and/or the quality of inter-class relationships, there exist few works dealing with some aspects for the quality of package organization and relationship. We believe that additional investigations are required for assessing package modularity aspects. The goal of this paper is to provide a complementary set of metrics that assess some modularity principles for packages in large legacy object-oriented software: Information-Hiding, Changeability and Reusability principles. Our metrics are defined with respect to object-oriented dependencies that are caused by inheritance and method call. We validate our metrics theoretically through a careful study of the mathematical properties of each metric.},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00614778/},
  hal-id = {inria-00614778},
  keywords = {moose cutter lse-pub raweb2011 kzMetric StefPub kzRemodularisation},
  rate = {acceptance rate (full + short papers): 50/104 = 48\%},
  hal-pdf = {http://hal.inria.fr/docs/00/61/45/83/PDF/ModularizationMetrics-INRIA.pdf}}

@inproceedings{Abde09b,
  author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui and Ilham Alloui},
  title = {Automatic Package Coupling and Cycle Minimization},
  booktitle = {Proceedings of the 16th International Working Conference on Reverse Engineering (WCRE'09)},
  pages = {103--112},
  publisher = {IEEE Computer Society Press},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde09b-WCRE2009-AutomaticPackageCoupling.pdf},
  misc = {acceptance rate: 20/79 = 25\%},
  doi = {10.1109/WCRE.2009.13},
  abstract = {Object-oriented (OO) software is usually organized into subsystems using the concepts of package or module. Such modular structure helps applications to evolve when facing new requirements. However, studies show that as soft- ware evolves to meet requirements and environment changes, modularization quality degrades. To help maintainers improve the quality of software modularization we have designed and implemented a heuristic search-based approach for automatically optimizing inter-package connectivity (i.e., dependencies). In this paper, we present our approach and its underlying techniques and algorithm. We show through a case study how it enables maintainers to optimize OO package structure of source code. Our optimization approach is based on Simulated Annealing technique.},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00425417},
  hal-id = {inria-00425417},
  keywords = {moose remoose2 lse-pub cook StefPub kzRemodularisation},
  rate = {25\%}}

@inproceedings{Ouma16a,
  author = {Hayatou Oumarou and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Kolyang Dina Taiwe},
  title = {Identifying the Exact Bug Fixing Actions},
  booktitle = {2016 7th International Workshop on Empirical Software Engineering in Practice (IWESEP)},
  pages = {51-56},
  year = {2016},
  url = {doi.ieeecomputersociety.org/10.1109/IWESEP.2016.13},
  doi = {10.1109/IWESEP.2016.13},
  keywords = {Software;Computer bugs;Data mining;Reliability;Control systems;Conferences;Software engineering},
  isbn = {978-1-5090-1851-2},
  annote = {internationalworkshop},
  tagnicolasa = {other analysis},
  month = {mar}}

@inproceedings{Ouma15a,
  author = {Hayatou Oumarou and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Kolyang Dina Taiwe},
  title = {Identifying the Exact Fixing Actions of Static Rule Violation},
  booktitle = {Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER'15)},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Haya15a-Saner-FixingActionOfStaticRule.pdf},
  misc = {acceptance rate: 46/144 = 32\%},
  acceptnum = {46},
  accepttotal = {144},
  address = {Montreal, Canada},
  hal-id = {hal-01185795},
  aeresstatus = {aeres15},
  annote = {internationalconference},
  keywords = {moose lse-pub raweb2015 pharo},
  abstract = {We study good programming practices expressed in rules and detected by static analysis checkers such as PMD or FindBugs. To understand how violations to these rules are corrected and whether this can be automated, we need to identify in the source code where they appear and how they were fixed. This presents some similarities with research on understanding software bugs, their causes, their fixes, and how they could be avoided. The traditional method to identify how a bug or a rule violation were fixed consists in finding the commit that contains this fix and identifying what was changed in this commit. If the commit is small, all the lines changed are ascribed to the fixing of the rule violation or the bug. However, commits are not always atomic, and several fixes and even enhancements can be mixed in a single one (a large commit). In this case, it is impossible to detect which modifications contribute to which fix. In this paper, we are proposing a method that identifies precisely the modifications that are related to the correction of a rule violation. The same method could be applied to bug fixes, providing there is a test illustrating this bug. We validate our solution on a real world system and actual rules.},
  tagnicolasa = {other analysis},
  x-country = {CM}}

@inproceedings{Rocha18a,
  author = {Henrique Rocha and St\'ephane Ducasse},
  title = {Preliminary Steps Towards Modeling Blockchain Oriented Software},
  booktitle = {1st International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
  pages = {1-6},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rocha18a-WETSEB-Modeling.pdf},
  doi = {10.1145/3194113.3194123},
  annote = {internationalworkshop},
  abstract = {Even though blockchain is mostly popular for its cryptocurrency,
smart contracts have become a very prominent blockchain application.
Smart contracts are like classes that can be called by client
applications outside the blockchain. Therefore it is possible to develop
blockchain-oriented software (BOS) that implements part of
the business logic in the blockchain by using smart contracts. Currently,
there is no design standard to model BOS. Since modeling is
an important part of designing a software, developers may struggle
to plan their BOS. In this paper, we show three complementary
modeling approaches based on well-known software engineering
models and apply them to a BOS example. Our goal is to start the
discussion on specialized blockchain modeling notations.},
  hal-id = {inria-01831046},
  keywords = {Blockchain;Modeling;Smart Contracts;UML;BPMN;ER Model; lse-pub kzBlockchain},
  month = {may}}

@inproceedings{Roch17a,
  author = {Henrique Rocha and St\'ephane Ducasse and Marcus Denker and Jason Lecerf},
  title = {Solidity Parsing Using SmaCC: Challenges and Irregularities},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {2:1--2:9},
  publisher = {ACM},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roch17a-IWST-SolidityParser.pdf},
  doi = {10.1145/3139903.3139906},
  annote = {internationalworkshop},
  abstract = {Solidity is a language used to implement smart contracts on a blockchain platform. Since its initial conception in 2014, Solidity has evolved into one of the major languages for the Ethereum platform as well as other blockchain technologies. Due to its popularity, there are many tools specifically designed to handle smart contracts written in Solidity. However , there is a lack of tools for Pharo to handle Solidity contracts. Therefore, we implemented a parser using SmaCC to serve as a base for further developing Solidity support in Pharo. In this paper we describe the parser creation, the irregularities we found in the Solidity grammar specification, and common practices on how to adapt the grammar to an LR type parser. Our experiences with parsing the Solidity language using SmaCC may help other developers trying to convert similar grammars.},
  hal-url = {https://hal.inria.fr/hal-01651858},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {2},
  numpages = {9},
  address = {New York, NY, USA},
  keywords = {Solidity Parser SmaCC Blockchain Ethereum lse-pub kzBlockchain},
  hal-id = {hal-01651858}}

@inproceedings{Hern19a,
  author = {Hern\`andez Phillips, Carolina and Guillermo Polito and Luc Fabresse and  St\'ephane Ducasse and Noury Bouraqadi and Pablo Tesone},
  title = {Challenges in Debugging Bootstraps of Reflective Kernels},
  booktitle = {{IWST19 - International workshop on Smalltalk Technologies}},
  year = {2019},
  pdf = {https://hal.archives-ouvertes.fr/hal-02297710/file/challengesInBootstrappingReflectiveKernels-corrected.pdf},
  hal-id = {hal-02297710},
  annote = {internationalworkshop},
  keywords = {IoT ; bootstrap ; language kernels}}

@misc{Fern05a,
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  title = {Squeak: mon premier programme},
  journal = {Linux Pratique},
  volume = {1},
  pages = {18--23},
  year = {2005},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = oct,
  number = 31}

@misc{Fern06a,
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  title = {Smalltalk: Le pouvoir et la simplicit\'e du tout objet},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = apr,
  number = 82}

@inproceedings{Fern07a,
  author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Caron},
  title = {{Dr Geo II}: Adding Interactivity Planes in Interactive Dynamic Geometry},
  booktitle = {Proceedings of 5th International Conference on Creating, Connecting and Collaborating through Computing (C5 2007)},
  pages = {153--162},
  publisher = {IEEE Computer Society},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern07a-C5-DrIIInterfactiveMultimodal.pdf},
  doi = {10.1109/C5.2007.12},
  abstract = {Interactive geometry environments support the creation and exploitation of interactive geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with: i. the internal cognitive representation of the learner about the geometric domain and ii. the way a geometric sketch is used in a paper-pen environment. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of the interactive geometry environments. We think additional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed DR. GEO II, an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our first results.},
  annote = {internationalconference},
  hal-id = {inria-00531636},
  isbn = {0-7695-2806-6},
  keywords = {stefPub kzTeaching}}

@inproceedings{Fern08a,
  author = {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
  title = {iSTOA: Artefacts for mathematical interactive learning execises kzTeaching},
  booktitle = {Proceedings of 6th International Conference on Creating, Connecting and Collaborating through Computing (C5 2008)},
  pages = {65--72},
  publisher = {IEEE Computer Society},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern08a-C5-istoa-exercises.pdf},
  abstract = {In primary schools, mathematics teachers use support tools to introduce new concepts. The objective of these tools is to reinforce a mental representation of the newly introduced concept. Tools can be physical objects or paper- pen based. We call these tools artefacts. In computer assisted environments, such artefacts are not always clearly present, those environments focus on the nature of the exercises (drills, quiz). To realise environments in closer relation to classroom teaching, we propose to analyse and categorise such artefacts: we used pedagogical literature and we extracted artefacts used in teaching multiplication. We present our infrastructure and a list of artefacts in the multiplication realm.},
  annote = {internationalconference},
  hal-id = {inria-00531649},
  isbn = {0-7695-3115-6},
  keywords = {stefPub kzTeaching}}

@inproceedings{Lava09a,
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  title = {Matrice de d\'ependances enrichie},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO 2009)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09a-LMO2009-DSM.pdf},
  abstract = {Les matrices de d\'ependance (DSM - Dependency Structure Matrix), d\'evelopp\'ees dans le cadre de l'optimisation de processus, ont fait leurs preuves pour identifier les d\'ependances logicielles entre des packages ou des sous-syst\`e\-mes. Il existe plusieurs algorithmes pour structurer une matrice de fa\c con \`a ce qu'elle refl\`ete l'architecture des \'el\'ements analys\'es et mette en \'evidence des cycles entre les sous-sys\-t\`e\-mes. Cependant, les impl\'ementations de matrices de d\'ependance existantes manquent d'informations importantes pour apporter une r\'eelle aide au travail de r\'eing\'enierie. Par exemple, le poids des relations qui posent probl\`eme ainsi que leur type ne sont pas clairement pr\'esent\'es. Ou encore, des cycles ind\'ependants sont fusionn\'es. Il est \'egalement difficile d'obtenir une visualisation centr\'ee sur un package.	Dans ce papier, nous am\'eliorons les matrices de d\'ependance en ajoutant des informations sur (i) le type de r\'ef\'erences, (ii) le nombre d'entit\'es r\'ef\'eren\c cantes, (iii) le nombre d'entit\'es r\'ef\'erenc\'ees. Nous	distinguons \'egalement les cycles ind\'ependants. Ce travail a \'et\'e impl\'ement\'e dans l'environnement de r\'eing\'enierie open-source \emph{Moose}. Il a \'et\'e appliqu\'e \`a des \'etudes de cas complexes comme le framework \emph{Morphic UI} contenu dans les environnements Smalltalk open-source \emph{Squeak} et	\emph{Pharo}. Les r\'esultats obtenus ont \'et\'e appliqu\'es dans l'environnement de programmation \emph{Pharo} et ont men\'e \`a des am\'eliorations.},
  address = {Nancy, France},
  annote = {nationalconference},
  hal-id = {inria-00498463},
  keywords = {moose lse-pub pharo pharo-pub kzCycle kzRemodularisation}}

@inproceedings{Lava08a,
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  title = {Assessing the Quality of your Software with MoQam},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava08a-Famoosr2008-MoQam.pdf},
  annote = {internationalworkshop},
  hal-id = {inria-00498482},
  keywords = {moose lse-pub stefPub kzMetric}}

@article{Lava12b,
  author = {Jannik Laval and Jean-R\'{e}my Falleri and Philippe Vismara and St\'ephane Ducasse},
  title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
  journal = {Journal of Object Technology},
  volume = {11},
  pages = {1-24},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava12b-JOT-Ranking.pdf},
  url = {http://www.jot.fm/contents/issue\_2012\_04/article4.html},
  doi = {10.5381/jot.2012.11.1.a4},
  annote = {internationaljournal},
  hal-id = {hal-00692569},
  issn = {1660-1769},
  keywords = {lse-pub moose kzRemodularization stefPub},
  month = apr,
  number = {1}}

@inproceedings{Lava10e,
  author = {Jannik Laval and Nicolas Anquetil and St\'ephane Ducasse},
  title = {OZONE: Package Layered Structure Identification in presence of Cycles},
  booktitle = {Proceedings of the 9th edition of the Workshop BElgian-NEtherlands software eVOLution seminar (BENEVOL'10)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava10e-Benevol2010-Layers.pdf},
  abstract = {Packages are complex entities and it can be difficult to understand them as they play different roles (e.g., core package, UI class container, tests package . . . ). In particular, package interdependencies make difficult their management (substitution, evolutions, deprecation). Understanding whether a package has high or low impact on the system is another valuable piece of information. In addition, package organization represents the backbone of large software system. It is is usually agreed that packages should form layered structures. However, identifying such layered structure is difficult since packages are often in cycles. Several approaches propose to recover software structure or to visualize classes or files organization. Only few approaches provide layered organization and in particular take cycle into account. In this paper, we propose an approach which provides (i) a strategy to highlight dependencies which break Acyclic Dependency Principle and (ii) an organization of package (even in presence of cycles) in multiple layers. While our approach can be run automatically, it also supports human inputs and constraints. We validate our approach with a preliminary study on the structure of the Moose software analysis platform: it shows promising results.},
  annote = {internationalworkshop},
  inriareport = {2010},
  keywords = {moose lse-pub raweb2010 pharo pharo-pub kzCycle kzRemodularisation},
  tagnicolasa = {architecture}}

@article{Lava13a,
  author = {Jannik Laval and Nicolas Anquetil and Usman Bhatti and St\'ephane Ducasse},
  title = {oZone: Layer identification in the presence of cyclic dependencies},
  journal = {Science of Computer Programming},
  volume = {78},
  pages = {1055--1072},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava13a-Official-OzoneLayer-SCO.pdf},
  impactfactor = {Impact Factor (2013) 0.548},
  doi = {10.1016/j.scico.2012.08.001},
  annote = {internationaljournal},
  hal-id = {hal-00732655},
  keywords = {lse-pub moose kzRemodularization stefPub},
  number = {8},
  tagnicolasa = {architecture}}

@inproceedings{Lava09d,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
  title = {Identifying cycle causes with CycleTable},
  booktitle = {FAMOOSr 2009: 3rd Workshop on FAMIX and MOOSE in Software Reengineering},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09d-Famoosr2009-CycleTable.pdf},
  abstract = {No abstract},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {inria-00498495},
  keywords = {moose lse-pub pharo pharo-pub kzCycle}}

@incollection{Lava14a,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
  title = {Visualisations pour la remodularisation \`a large \'echelle des syst\`emes \`a objets},
  booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
  publisher = {Herm\`es},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava14a-Chapitresvisu.pdf},
  annote = {articlebook},
  ean13 = {9782746245549},
  keywords = {lse-pub cutter raweb2012 kzVisualization kzCycle}}

@inproceedings{Lava09c,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Alexandre Bergel},
  title = {Identifying cycle causes with Enriched Dependency Structural Matrix},
  booktitle = {WCRE '09: Proceedings of the 2009 16th Working Conference on Reverse Engineering},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09c-WCRE2009-eDSM.pdf},
  misc = {Acceptance rate: 20/79 = 25\%},
  abstract = {Dependency Structure Matrix (DSM) has been successfully applied to identify software
 dependencies among packages and subsystems. A number of algorithms were proposed to compute the
 matrix so that it highlights patterns and problematic dependencies between subsystems. However,
 existing DSM implementations often miss important information to fully support reengineering
 effort. For example, they do not clearly qualify and quantify problematic relationships,
 information which is crucial to support remediation tasks.
In this paper we present enriched DSM (eDSM) where cells are enriched with contextual information
 about (i) the type of dependencies (inheritance, class reference . . . ), (ii) the proportion of
 referencing entities, (iii) the proportion of referenced entities. We distinguish independent
 cycles and stress potentially simple fixes for cycles using coloring information. This work is
 language independent and has been implemented on top of the Moose reengineering environment. It has
 been applied to non-trivial case studies among which ArgoUML, and Morphic the UI framework
 available in two open-source Smalltalks, Squeak and Pharo. Solution to problems identified by eDSM
 have been performed and retrofitted in Pharo main distribution.},
  address = {Lille, France},
  annote = {internationalconference},
  hal-id = {inria-00498446},
  keywords = {moose lse-pub pharo pharo-pub kzVisualization kzCycle},
  rate = {25\%}}

@inproceedings{Lava09b,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Andy Kellens},
  title = {Supporting Incremental Changes in Large System Models},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies},
  pages = {1--7},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09b-IWST09-incrementalChange.pdf},
  abstract = {When reengineering large systems, software developers would like to assess and compare the impact of multiple change scenarios without actually performing these changes. A change can be effected by applying a tool to the source code, or by a manual refactoring. In addition, tools run over a model are costly to redevelop. It raises an interesting challenge for tools implementors: how to support modification of large source code models to enable comparison of multiple versions. One naive approach is to copy the entire model after each modification. However, such an approach is too expensive in memory and execution time. In this paper we explore different implementations that source code metamodels support multiple versions of a system. We propose a solution based on dynamic binding of entities between multiple versions, providing good access performance while minimizing memory consumption.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {inria-00498492},
  keywords = {moose lse-pub pharo pharo-pub kzMeta},
  series = {IWST'09}}

@article{Lava10b,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Jean-R\'emy Falleri},
  title = {Supporting Simultaneous Versions for Software Evolution Assessment},
  journal = {Journal of Science of Computer Programming (SCP)},
  volume = {76},
  pages = {1177-1193},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava10a-Official-SCP-Orion.pdf},
  impactfactor = {5-year impact factor (2012) 0.903},
  doi = {10.1016/j.scico.2010.11.014},
  abstract = {When reengineering software systems, maintainers should be able to assess and compare multiple change scenarios for a given goal, so as to choose the most pertinent one. Because they implicitly consider one single working copy, revision control systems do not scale up well to perform simultaneous analyses of multiple versions of systems. We designed Orion, an interactive prototyping tool for reengineering, to simulate changes and compare their impact on multiple versions of software source code models. Our approach offers an interactive simulation of changes, reuses existing assessment tools, and has the ability to hold multiple and branching versions simultaneously in memory. Specifically, we devise an infrastructure which optimizes memory usage of multiple versions for large models. This infrastructure uses an extension of the FAMIX source code meta-model but it is not limited to source code analysis tools since it can be applied to models in general. In this paper, we validate our approach by running benchmarks on memory usage and computation time of model queries on large models. Our benchmarks show that the Orion approach scales up well in terms of memory usage, while the current implementation could be optimized to lower its computation time. We also report on two large case studies on which we applied Orion.},
  annote = {internationaljournal},
  hal-id = {inria-00531500},
  inriareport = {2010},
  keywords = {lse-pub moose rawed2010 pharo pharo-pub kzMeta kzCycle kzRemodularisation},
  month = may,
  number = {12}}

@misc{Lava10d,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Package et gestion de versions en Pharo},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746243},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
  month = nov,
  number = 132}

@misc{Lava10a,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Optimisation d'applications en Pharo},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746241},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = jan,
  number = 123}

@article{Lava14b,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Resolving cyclic dependencies between packages with Enriched Dependency Structural Matrix},
  journal = {Software: Practice and Experience},
  volume = {44},
  pages = {235-257},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava14b-Official-SoftwarePracticeExperience-ResolvingCyclicDependencies.pdf},
  doi = {10.1002/spe.2164},
  annote = {internationaljournal},
  hal-id = {hal-00748120},
  keywords = {moose cutter kzCycle}}

@misc{Lava10c,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Pharo: un nouveau Smalltalk open source},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746242},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
  month = sep,
  number = 130}

@inproceedings{Fall11a,
  author = {Jean R\'emi Falleri and Simon Denier and Jannik Laval and Philipe Vismara and St\'ephane Ducasse},
  title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
  booktitle = {Proceedings of the 49th International Conference on Objects, Models, Components, Patterns (TOOLS'11)},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fall11a-Tools2011-UndesirableCycles.pdf},
  abstract = {Many design guidelines state that a software system architecture should avoid cycles between its packages. Yet such cycles appear again and again in many programs. We believe that the existing approaches for cycle detection are too coarse to assist the developers to remove cycles from their programs. In this paper, we describe an efficient algorithm that performs a fine-grained analysis of the cycles among the packages of an application. In addition, we define a metric to rank cycles by their level of undesirability, prioritizing the cycles that seems the more undesired by the developers. Our approach is validated on two large and mature software systems in Java and Smalltalk.},
  address = {Zurich, Switzerland},
  annote = {internationalconference},
  hal-id = {inria-00614770},
  keywords = {lse-pub cutter raweb2011 pharo kzCycle kzRemodularisation},
  month = jun}

@inproceedings{Arna10a,
  author = {Jean-Baptiste Arnaud and Marcus Denker and St\'ephane Ducasse and Damien Pollet and Alexandre Bergel and Mathieu Suen},
  title = {Read-Only Execution for Dynamic Languages},
  booktitle = {Proceedings of the 48th International Conference Objects, Models, Components, Patterns (TOOLS'10)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arna10a-Tools2010-ReadOnlyExecutionForDynamicLanguages.pdf},
  misc = {25\%},
  doi = {10.1007/978-3-642-13953-6\_7},
  abstract = {Supporting read-only and side effect free execution has been the focus of a large body of work in the area of statically typed programming languages. Read-onlyness in dynamically typed languages is difficult to achieve because of the absence of a type checking phase and the support of an open-world assumption in which code can be constantly added and modified. To address this issue, we propose Dynamic Read-Only references (DRO) that provide a view on an object where this object and its object graph are protected from modification. The read- only view dynamically propagates to aggregated objects, without changing the object graph itself; it acts as a read-only view of complex data structures, without making them read-only globally. We implement dynamic read-only references by using smart object proxies that lazily propagate the read-only view, following the object graph and driven by control flow and applied them to realize side-effect free assertions.},
  address = {Malaga, Spain},
  annote = {internationalconference},
  hal-url = {http://hal.archives-ouvertes.fr/inria-00498377/fr/},
  hal-id = {inria-00498377},
  inriareport = {2010},
  keywords = {tools10 lse-pub marcusdenker pharo kzLanguageDesign StefPub},
  month = jun,
  rate = {25\%}}

@article{Arna14a,
  author = {Jean-Baptiste Arnaud and St\'ephane Ducasse and Marcus Denker and Camille Teruel},
  title = {Handles: Behavior-Propagating First Class References For Dynamically-Typed Languages},
  journal = {Journal of Science of Computer Programming},
  volume = {98},
  pages = {318-338},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arna14a-SCICO-Handles.pdf},
  impactfactor = {(Core A), 5-year impact factor (2012) 0.903},
  abstract = {Controlling object graphs and giving specific semantics to references (such as read-only, owner- ship, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is an underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first-class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementa- tion of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.},
  annote = {internationaljournal},
  hal-url = {http://hal.inria.fr/hal-01060537},
  hal-id = {hal-01060537},
  issue = {3},
  keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzLanguageDesign}}

@article{Fabr14b,
  author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
  title = {AspectMaps: Extending Moose to visualize AOP software},
  journal = {Science of Computer Programming},
  volume = {79},
  pages = {6-22},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fabr14b-Official-SCP-AspectMaps.pdf},
  doi = {10.1016/j.scico.2012.02.007},
  annote = {internationaljournal},
  hal-id = {hal-01086997},
  issn = {0167-6423},
  keywords = {lse-pub plomo lse-pub stefPub kzVisualization},
  note = {lse-pub stefPub kzVisualization}}

@inproceedings{Fabr11a,
  author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
  title = {{AspectMaps}: A Scalable Visualization of Join Point Shadows},
  booktitle = {Proceedings of the 19th International Conference on Program Comprehension},
  pages = {121-130},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fabr11a-ICPC2011-AspectMaps.pdf},
  misc = {Acceptance rate: 18/76 = 23\%},
  doi = {http://dx.doi.org/10.1109/ICPC.2011.11},
  abstract = {When using Aspect-Oriented Programming, it is sometimes difficult to determine at which join point an aspect executes. Similarly, when considering one join point, knowing which aspects will execute there and in what order is non- trivial. This makes it difficult to understand how the application will behave. A number of visualizations have been proposed that attempt to provide support for such program understanding. However, they neither scale up to large code bases nor scale down to understanding what happens at a single join point. In this paper, we present AspectMaps - a visualization that scales in both directions, thanks to a multi-level selective structural zoom. We show how the use of AspectMaps allows for program understanding of code with aspects, revealing both a wealth of information of what can happen at one particular join point as well as allowing to see the ``big picture'' on a larger code base. We demonstrate the usefulness of AspectMaps on an example and present the results of a small user study that shows that AspectMaps outperforms other aspect visualization tools.},
  annote = {internationalconference},
  hal-id = {inria-00614773},
  keywords = {lse-pub plomo raweb2011 pharo kzVisualization kzAspect kzModule},
  rate = {23\%},
  series = {ICPC'11}}

@book{Fabr17a,
  author = {Johan Fabry and St\'ephane Ducasse},
  title = {The Spec UI Framework},
  pages = {84},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {book},
  keywords = {skipdoi kzSmalltalk kzBook lse-pub},
  hal-id = {hal-01612690}}

@booklet{Bran17d,
  author = {John Brant and Jason Lecerf and Thierry Goubier and St\'ephane Ducasse and Black, Andrew P.},
  title = {Smacc: a Compiler-Compiler},
  pages = {44},
  publisher = {Square Bracket Associates},
  collection = {The Pharo Technology Collection},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-10-21-Smacc-Compiler.pdf},
  url = {http://books.pharo.org/booklet-Smacc/},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  keywords = {skipdoi kzPharo kzTools lse-pub},
  hal-id = {hal-01612820}}

@inproceedings{Laut09a,
  author = {Juan Lautaro Fern\'andez and Santiago Robles and Andr\'es Fortier and St\'ephane Ducasse and Gustavo Rossi and Silvia Gordillo},
  title = {Meteoroid Towards a real MVC for the Web},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
  publisher = {ACM Digital Library},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Laut09a-IWST09-Meteroid.pdf},
  abstract = {Web development has moved from simple static pages to complex web applications, some of them
resembling desktop ones. In most of these applications the web browser acts as thin-client (or a view) of the
model that sits on the server. Despite the technological evolution of the web, there is still no standard
mechanism to send data or events from the server to the client without an explicit request from the later,
thus forcing the web browser to constantly poll the server for updates. To solve this problem a set of
techniques under the name of Comet were proposed, allowing to send information from the server to the web
browser without an explicit client request. In this paper we introduce Meteoroid, a Comet approach to make
live Seaside applications. Our framework exploits the Model-View-Controller (MVC) paradigm for building
 simple yet scalable web applications, requiring very little programming effort.},
  annote = {internationalworkshop},
  keywords = {stefPub kzWeb},
  location = {Brest, France},
  x-pays = {AR}}

@inproceedings{Cruz99b,
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  title = {Coordinating Open Distributed Systems},
  booktitle = {Proceedings of International Workshop in Future Trends in Distributed Computing Systems '99},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99-FTDCS.pdf},
  doi = {10.1109/FTDCS.1999.818794},
  abstract = {Open Distributed Systems are the dominating intellectual issue of the end of this century.	Figuring out how to build those systems will become a central issue in distributed system research in the next future. Although CORBA seems to provide all the necessary support to construct those systems. It provides a very limited support to the evolution of requirements in those systems. The main problem is that the description of the elements from which systems are built, and the way in which they are composed are mixed into the application code. Making them difficult to understand, modify and customize.	We think that a solution to this problem goes through the introduction of the so called coordination models and languages into the CORBA model. We propose in this paper the introduction of our object coordination model called CoLaS into the CORBA model.},
  annote = {internationalworkshop},
  keywords = {stefPub kzLanguageDesign kzCoordination},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99FTDCS.pdf}}

@inproceedings{Cruz99a,
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  title = {A Group Based Approach for Coordinating Active Objects},
  booktitle = {Proceedings of Coordination'99},
  volume = {1594},
  pages = {355--371},
  publisher = {Springer-Verlag},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99a-GroupBasedApproach.pdf},
  misc = {Core A},
  abstract = {Although coordination of concurrent objects is a fundamental aspect of object-oriented concurrent programming, there is only little support for its specification and abstraction at the language level.	This is a problem because coordination is often buried in the code of the coordinated objects, leading to a lack of abstraction and reuse. Here we present CoLaS, a coordination model and its implementation based on the notion of Coordination Groups. By clearly identifying and separating the coordination from the co-ordinated objects CoLaS provides a better abstraction and reuse of the coordination and the coordinated objects. Moreover CoLaS's high dynamicity provides better support for coordination of active objects.},
  annote = {internationalconference},
  keywords = {kzLanguageDesign kzCoordination},
  series = {LNCS},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99aGroupBasedApproach.pdf}}

@inproceedings{Delp17a,
  author = {Julien Delplanque and Anne Etien and Olivier Auverlot and Tom Mens and Nicolas Anquetil and St\'ephane Ducasse},
  title = {CodeCritics Applied to Database Schema: Challenges and First Results},
  booktitle = {24th IEEE International Conference on Software Analysis, Evolution, and Reengineering},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp17a-Saner-CodeCritics-Applied-To-Database-Schemas.pdf},
  hal-id = {hal-01596247},
  keywords = {lse-pub kzEvolution kzDB},
  abstract = {Relational databases (DB) play a critical role in many information systems. For different reasons, their schemas gather not only tables and columns but also views, triggers or stored functions (i.e., fragments of code describing treatments). As for any other code-related artefact, software quality in a DB schema helps avoiding future bugs. However, few tools exist to analyse DB quality and prevent the introduction of technical debt.	Moreover, these tools suffer from limitations like the difficulty to deal with some entities (e.g., functions) or dependencies between entities. This paper presents research issues related to assessing the software quality of a DB schema by adapting existing source code analysis research to database schemas. We present preliminary results that have been validated through the implementation of DBCritics, a prototype tool to perform static analysis on the SQL source code of a database schema. DBCritics addresses the limitations of existing DB quality tools based on an internal representation considering all entities of the database and their relationships.},
  annote = {internationalconference},
  tagnicolasa = {other database}}

@inproceedings{Delp19b,
  author = {Julien Delplanque and St\'ephane Ducasse and Oleksandr Zaitsev},
  title = {Magic Literals in Pharo},
  booktitle = {International workshop of Smalltalk Technologies},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp19b-IWST-MagicLiterals.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02266137v1},
  hal-id = {hal-02266137},
  annote = {internationalworkshop},
  keywords = {kzEvolution}}

@incollection{Mord14a,
  author = {Karine Mordal and Jannik Laval and St\'ephane Ducasse},
  title = {Mod\`eles de mesure de la qualit\'e des logiciels},
  booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
  publisher = {Herm\`es},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord14a-Chapitrequalite.pdf},
  annote = {articlebook},
  ean13 = {9782746245549},
  inriareport = {2014},
  keywords = {moose lse-pub kzMetric}}

@inproceedings{Mord09a,
  author = {Karine Mordal-Manet and Fran\c{c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
  title = {The Squale Model -- A Practice-based Industrial Quality Model},
  booktitle = {Proceedings of the 25th IEEE International Conference on Software Maintenance (ICSM'09)},
  pages = {94--103},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord09a-ICSM2009-SqualeModel.pdf},
  misc = {(short paper) acceptance rate: 35(+29)/162: 21(40)\% for short papers},
  abstract = {ISO 9126 promotes a three-level model of quality (factors, criteria, and metrics) which allows one to assess quality at the top level of factors and criteria. However, it is difficult to use this model as a tool to increase software quality. In the Squale model, we add practices as an intermediate level between metrics and criteria. Practices abstract away from raw information (metrics, tool reports, audits) and provide technical guidelines to respect. Moreover, practice marks are adjusted using formulae to suit company development habits or exigences: for example bad marks are stressed to point to places which need more attention. The Squale model has been developed and validated over the last couple of years in an industrial setting with Air France-KLM and PSA Peugeot-Citroen.},
  address = {Edmonton, Canada},
  annote = {internationalconference},
  hal = {inria-00637364},
  keywords = {moose kzMetric},
  rate = {40\%}}

@inproceedings{Mord11a,
  author = {Karine Mordal-Manet and Jannik Laval and St\'ephane Ducasse and Nicolas Anquetil and Fran\c{c}oise Balmas and Fabrice Bellingard and Laurent Bouhier and Philippe Vaillergues and Thomas J. McCabe},
  title = {An empirical model for continuous and weighted metric aggregation},
  booktitle = {Proceedings of the 15th European Conference on Software Maintenance and Reengineering (CSMR'11)},
  pages = {141--150},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord11a-CSMR2011-Squale.pdf},
  misc = {acceptance rate: 29/82 = 35\%},
  abstract = {It is now understood that software metrics alone are not enough to characterize software quality. To cope with this problem, most of advanced and/or industrially validated quality models aggregate software metrics: for example, cyclomatic complexity is combined with test coverage to stress the fact that it is more important to cover complex methods than accessors. Yet, aggregating and weighting metrics to produce quality indexes is a difficult task. Indeed certain weighting approaches may lead to abnormal situations where a developer increasing the quality of a software component sees the overall quality degrade. Finally, mapping combinations of metric values to quality indexes may be a problem when using thresholds. In this paper, we present the problems we faced when designing the Squale quality model, then we present an empirical solution based on weighted aggregations and on continuous functions. The solution has been termed the Squale quality model and validated over 4 years with two large multinational companies: Air France-KLM and PSA Peugeot-Citroen.},
  address = {Oldenburg, Germany},
  annote = {internationalconference},
  hal = {inria-00637367},
  keywords = {moose lse-pub squale raweb2011 kzMetric},
  tagnicolasa = {metric}}

@article{Mord13a,
  author = {Karine Mordal{-}Manet and Nicolas Anquetil and Jannik Laval and Alexander Serebrenik and Bogdan Vasilescu and St\'ephane Ducasse},
  title = {Software quality metrics aggregation in industry},
  journal = {Journal of Software: Evolution and Process},
  volume = {25},
  pages = {1117--1135},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord12b-Official-JSoft-MetricAggregation.pdf},
  impactfactor = {Impact Factor (2013) 0.442},
  doi = {10.1002/smr.1558},
  aeresstatus = {aeres13},
  annote = {internationaljournal},
  number = {10},
  tagnicolasa = {metric}}

@article{Gybe06a,
  author = {Kris Gybels and Roel Wuyts and St\'ephane Ducasse and Maja D'Hondt},
  title = {Inter-Language Reflection --- A Conceptual Model and Its Implementation},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {32},
  pages = {109--124},
  publisher = {Elsevier},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gybe06aSymbioticReflectionESUGJournal.pdf},
  impactfactor = {5 Year ISI impact factor (2009) 0.619},
  doi = {10.1016/j.cl.2005.10.003},
  abstract = {Meta programming is the act of reasoning about a
 computational system. For example, a program in
 Prolog can reason about a program written in
 Smalltalk. Reflection is a more powerful form of
 meta programming where the same language is used to
 reason about, and act upon, itself in a causally
 connected way. Thus on the one hand we have meta
 programming that allows different languages or
 paradigms to be used, but without causal connection,
 while on the other hand we have reflection that
 offers causal connection but only for a single
 language. This paper combines both and presents
 inter-language reflection that allows one language
 to reason about and change in a causally connected
 way another language and vice versa. The fundamental
 aspects of inter-language reflection and the
 language symbiosis used therein, are discussed.
 Moreover the implementation of two symbiotic
 reflective languages is discussed: Agora/Java and
 SOUL/Smalltalk.},
  annote = {internationaljournal},
  keywords = {stefPub kzReflection},
  month = jul,
  number = {2-3}}

@inproceedings{Ardi97a,
  author = {Laurent Arditi and St\'ephane Ducasse},
  title = {Scheme: un langage applicatif pour l'enseignement de l'informatique en milieu aride},
  booktitle = {Actes des Journ\'ees Fran\c{c}aises des Langages Applicatifs (JFLA '97)},
  pages = {209--228},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ardi97a-JFLA07-SchemeTeaching.pdf},
  abstract = {Dans cet article, nous pr\'esentons une exp\'erience d'enseignement de l'informatique en milieu aride: volume horaire faible, faible coefficient, \'etudiants peu motiv\'es. Dans ce contexte d\'efavorable, nous avons choisi de privil\`egier un concept, la r\'ecursivit\'e dans le cadre de la programmation fonctionnelle, plut\^ot qu'un langage.	Ce choix nous a conduit \`a consid\`erer le langage Scheme pour sa simplicit\'e. Nous d\'ecrivons ici notre cours, les probl\`emes que nous avons rencontr\'es et les solutions que nous avons choisies.},
  annote = {nationalconference},
  hal-id = {inria-00533051},
  keywords = {stefPub kzTeaching}}

@book{Ardi96a,
  author = {Laurent Arditi and St\'ephane Ducasse},
  title = {La programmation: une approche fonctionelle et r\'ecursive avec Scheme},
  pages = {238},
  publisher = {Eyrolles},
  year = {1996},
  address = {Paris},
  annote = {book},
  isbn = {2-212-08915-5},
  keywords = {stefPub scglib kzBook kzTeaching},
  month = apr,
  note = {Pr\'eface de G\'erard Huet}}

@inproceedings{Lece18a,
  author = {Lecerf, Jason and Brant, John and Goubier, Thierry and Ducasse, St\'ephane},
  title = {A Reflexive and Automated Approach to Syntactic Pattern Matching in Code Transformations},
  booktitle = {IEEE International Conference on Software Maintenance and Evolution (ICSME'18)},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lece18a-ICSME-ReflectiveParsing.pdf},
  doi = {10.1109/ICSME.2018.00052},
  annote = {internationalconference topconference},
  abstract = {Empowering software engineers often requires to let them write code transformations. However existing automated or tool-supported approaches force developers to have a detailed knowledge of the internal representation of the underlying tool. While this knowledge is time consuming to master, the syntax of the language, on the other hand, is already well known to developers and can serve as a strong foundation for pattern matching. Pattern languages with metavariables (that is variables holding abstract syntax subtrees once the pattern has been matched) have been used to help programmers define program transformations at the language syntax level. The question raised is then the engineering cost of metavariable support. Our contribution is to show that, with a GLR parser, such patterns with metavariables can be supported by using a form of runtime reflexivity on the parser internal structures. This approach allows one to directly implement such patterns on any parser generated by a parser generation framework, without asking the pattern writer to learn the AST structure and node types. As a use case for that approach we describe the implementation built on top of the SmaCC (Smalltalk Compiler Compiler) GLR parser generator framework. This approach has been used in production for source code transformations on a large scale. We will express perspectives to adapt this approach to other types of parsing technologies.},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01851857},
  address = {Madrid, Spain},
  month = sep,
  keywords = {StefPub kzEvolution kzTools parser generation ; GLR parsing ; syntactic patterns ; pattern matching ; code templates lse-pub},
  hal-id = {hal-01851857}}

@inproceedings{Godo14a,
  author = {Lucas Godoy and Damien Cassou and St\'ephane Ducasse},
  title = {Tracking dependencies between code changes: An incremental approach},
  booktitle = {IWST'14: Proceedings of the	International Workshop on Smalltalk Technologies 2014},
  year = {2014},
  abstract = {Merging a change often leads to the question of knowing what are the dependencies to other changes that should be merged too to obtain a working system. This question also arises with code history trackers -- Code history trackers are tools that react to what the developer do by creating first-class objects that represent the change made to the system. In this paper, we evaluate the capacity of different code history trackers to represent, also as first-class objects, the dependencies between those changes. We also present a representation for dependencies that works with the event model of \emph{Epicea}, a fine-grained and incremental code history tracker.},
  annote = {internationalworkshop},
  keywords = {lse-pub pharo stefPub kzInfrastructure}}

@inproceedings{Reng07a,
  author = {Lukas Renggli and St\'ephane Ducasse and Adrian Kuhn},
  title = {Magritte --- A Meta-Driven Approach to Empower Developers and End Users},
  booktitle = {Model Driven Engineering Languages and Systems},
  volume = {4735},
  pages = {106--120},
  publisher = {Springer},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng07aMagritte.pdf},
  doi = {10.1007/978-3-540-75209-7\_8},
  abstract = {Model-driven engineering is a powerful approach to
 build large-scale applications. However, an
 application's metamodel often remains static after
 the development phase and cannot be changed unless a
 new development effort occurs. Yet, end users often
 need to rapidly adapt their applications to new
 business needs. In many cases, the end users would
 know how to make the required adaptations, if only,
 the application would let them do so. In this paper
 we present how we built a runtime-dynamic
 meta-environment by integrating Magritte, a
 self-described metamodel, into Smalltalk's
 reflective language model. Our solution offers the
 best of both worlds: developers can develop their
 applications using the same tools they were used to,
 but at the same time they gain the power of
 meta-programming. We show in particular that our
 approach is adapted to support end user
 customization of applications: the adaptive model of
 Magritte enables to not only describe existing
 classes, but also lets end users build their own
 metamodels on the fly.},
  annote = {internationalconference},
  isbn = {978-3-540-75208-0},
  keywords = {kzMeta},
  medium = {2},
  month = sep,
  rate = {32\%},
  series = {LNCS}}

@inproceedings{Reng10b,
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Domain-Specific Program Checking},
  booktitle = {Proceedings of the 48th International Conference on Objects, Models, Components and Patterns (TOOLS'10)},
  volume = {6141},
  pages = {213--232},
  publisher = {Springer-Verlag},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng10b-DomainSpecificProgramChecking.pdf},
  doi = {10.1007/978-3-642-13953-6\_12},
  abstract = {Lint-like program checkers are popular tools that
 ensure code quality by verifying compliance with
 best practices for a particular programming
 language. The proliferation of internal
 domain-specific languages and models, however, poses
 new challenges for such tools. Traditional program
 checkers produce many false positives and fail to
 accurately check constraints, best practices, common
 errors, possible optimizations and portability
 issues particular to domain-specific languages. We
 advocate the use of dedicated rules to check
 domain-specific practices. We demonstrate the
 implementation of domain-specific rules, the
 automatic fixing of violations, and their
 application to two case-studies: (1) Seaside defines
 several internal DSLs through a creative use of the
 syntax of the host language; and (2) Magritte adds
 meta-descriptions to existing code by means of
 special methods. Our empirical validation
 demonstrates that domain-specific program checking
 significantly improves code quality when compared
 with general purpose program checking.},
  annote = {internationalconference},
  editor = {Jan Vitek},
  hal-id = {inria-00531509},
  inriareport = {2010},
  isnb = {978-3-642-13952-9},
  keywords = {scg-pub helvetia girba snf10 jb10 remoose lse-pub pharo pharo-pub kzTools kzChecking},
  ratex = {29\%},
  series = {LNCS}}

@inproceedings{Reng10c,
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Practical Dynamic Grammars for Dynamic Languages},
  booktitle = {4th Workshop on Dynamic Languages and Applications (DYLA 2010)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng10cDynamicGrammars.pdf},
  abstract = {Grammars for programming languages are traditionally
 specified statically. They are hard to compose and
 reuse due to ambiguities that inevitably arise.
 PetitParser combines ideas from scannerless parsing,
 parser combinators, parsing expression grammars and
 packrat parsers to model grammars and parsers as
 objects that can be reconfigured dynamically.
 Through examples and benchmarks we demonstrate that
 dynamic grammars are not only flexible but highly
 practical.},
  address = {Malaga, Spain},
  annote = {internationalworkshop},
  hal-id = {hal-00746253},
  inriareport = {2010},
  keywords = {scg-pub moose lse-pub pharo pharo-pub kzLanguageDesign},
  month = jun}

@inproceedings{Weih05a,
  author = {Marcel Weiher and St\'ephane Ducasse},
  title = {High-Order Messaging},
  booktitle = {Proceedings of International Symposium on Dynamic Languages (SDL'05)},
  pages = {23--34},
  publisher = {ACM Press},
  year = {2005},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Weih05aHigherOrderMessagingOOPSLA2005.pdf},
  abstract = {We introduce Higher Order Messaging, a higher order
 programming mechanism for dynamic object-oriented
 languages. Higher Order Messages allow user-defined
 message dispatch mechanism to be expressed using an
 optimally compact syntax that is a natural extension
 of plain messaging and also have a simple conceptual
 model. They can be implemented without extending the
 base language and operate through language bridges.},
  annote = {internationalconference},
  keywords = {stefPub jb06 listic kzLanguageDesign kzMessaging}}

@inproceedings{Denk08b,
  author = {Marcus Denker and Mathieu Suen and St\'ephane Ducasse},
  title = {The Meta in Meta-object Architectures},
  booktitle = {Proceedings of TOOLS EUROPE 2008},
  volume = {11},
  pages = {218--237},
  publisher = {Springer-Verlag},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk08b-Tools08-MetaContext.pdf},
  doi = {10.1007/978-3-540-69824-1\_13},
  isbn = {978-3-540-69824-1},
  abstract = {Behavioral reflection is crucial to support for example functional upgrades, on-the-fly debugging, or monitoring critical applications. However the use of reflective features can lead to severe problems due to infinite metacall recursion even in simple cases. This is especially a problem when reflecting on core language features since there is a high chance that such features are used to implement the reflective behavior itself. In this paper we analyze the problem of infinite meta-object call recursion and solve it by providing a first class representation of meta-level execution: at any point in the execution of a system it can be determined if we are operating on a meta-level or base level so that we can prevent infinite recursion. We present how meta-level execution can be represented by a meta-context and how reflection becomes context-aware. Our solution makes it possible to freely apply behavioral reflection even on system classes: the meta-context brings stability to behavioral reflection. We validate the concept with a robust implementation and we present benchmarks.},
  annote = {internationalconference},
  hal = {inria-00271286,p56w09p},
  issn = {1865-1348},
  keywords = {scg-pub jb08 fb08 snf08 reflectivity marcusdenker remoose kzReflection},
  series = {LNBIP}}

@inproceedings{Denk07a,
  author = {Marcus Denker and St\'ephane Ducasse},
  title = {Software Evolution from the Field: an Experience Report from the {Squeak} Maintainers},
  booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
  volume = {166},
  pages = {81--91},
  publisher = {Elsevier},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07a-Ercim06-EvolutionSqueak.pdf},
  doi = {10.1016/j.entcs.2006.08.003},
  abstract = {Over the last few years, we actively participated in the maintenance and evolution of Squeak, an open-source Smalltalk. The community is constantly faced with the problem of enabling changes while at the same time preserving compatibility. In this paper we describe the current situation, the problems that faced the community and we outline the solutions that have been put in place. We also identify some areas where problems continue to exist and propose these as potential problems to addressed by the research community.},
  annote = {internationalworkshop},
  issn = {1571-0661},
  keywords = {scg07 stefPub scg-pub snf06 recast06 jb07 marcusdenker kzEvolution},
  medium = {2},
  month = jan,
  series = {Electronic Notes in Theoretical Computer Science}}

@inproceedings{Denk07b,
  author = {Marcus Denker and St\'ephane Ducasse and Adrian Lienhard and Philippe Marschall},
  title = {Sub-Method Reflection},
  booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
  volume = {6/9},
  pages = {231--251},
  publisher = {ETH},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07b-TOOLS07-Submethod.pdf},
  doi = {10.5381/jot.2007.6.9.a14},
  abstract = {Reflection has proved to be a powerful feature to support the design of development environments and to extend languages. However, the granularity of structural reflection stops at the method level.	This is a problem since without sub-method reflection developers have to duplicate efforts, for example to introduce transparently pluggable type-checkers or fine-grained profilers. In this paper we present Persephone, an efficient implementation of a sub-method meta-object protocol (MOP) based on AST annotations and dual methods (a compiled method and its meta-object) that reconcile AST expressiveness with bytecode execution. We validate the MOP by presenting TreeNurse, a method instrumentation framework and TypePlug, an optional, pluggable type system which is based on Persephone.},
  annote = {internationalconference},
  issn = {1660-1769},
  keywords = {skip-doi jot snf-bmcc reflectivity fromscgbib marcusdenker kzReflection},
  medium = {2},
  month = oct}

@article{Denk06a,
  author = {Marcus Denker and St\'ephane Ducasse and {\'E}ric Tanter},
  title = {Runtime Bytecode Transformation for {Smalltalk}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {32},
  pages = {125--139},
  publisher = {Elsevier},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk06a-COMLAN-RuntimeByteCode.pdf},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2005.10.002},
  abstract = {Transforming programs to alter their semantics is of
 wide interest, for purposes as diverse as
 off-the-shelf component adaptation, optimization,
 trace generation, and experimentation with new
 language features. The current wave of interest in
 advanced technologies for better separation of
 concerns, such as aspect-oriented programming, is a
 solid testimony of this fact. Strangely enough,
 almost all proposals are formulated in the context
 of {Java}, in which tool providers encounter severe
 restrictions due to the rigidity of the environment.
 This paper present ByteSurgeon, a library to
 transform binary code in Smalltalk. ByteSurgeon
 takes full advantage of the flexibility of the
 Squeak environment to enable bytecode transformation
 at runtime, thereby allowing dynamic, on-the-fly
 modification of applications. ByteSurgeon operates
 on bytecode in order to cope with situations where
 the source code is not available, while providing
 appropriate high-level abstractions so that users do
 not need to program at the bytecode level. We
 illustrate the use of ByteSurgeon via the
 implementation of method wrappers and a simple MOP,
 and report on its efficiency.},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub mdPub fromscgbib marcusdenker kzReflection},
  month = jul,
  number = {2-3}}

@inproceedings{Rizu16a,
  author = {Markiyan Rizun and Gustavo Santos and St\'ephane Ducasse and Camille Teruel},
  title = {{Phorms: Pattern Combinator Library for Pharo}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rizu16a-IWST16-Matcher.pdf},
  doi = {10.1145/2991041.2991057},
  abstract = {Pattern matching is a common mechanism to provide analysis and transformation of data structures. Such an approach basically checks whether the containing elements of a data structure are constituents of a pattern, described by the developer. This paper is a step towards having seamless object-oriented pattern matching, which would be applicable to any object in Pharo. We present a pattern matching library, called \phorms, which enables users to compose patterns using the syntax of the Pharo programming language. In this library, patterns are objects and therefore can be inspected and debugged using existing Pharo tools. Our solution is extensible unlike \emph{The Rewrite Engine} -- Pharo's current pattern matching facilities. Moreover, by treating patterns as first class objects, our library provides more flexibility in the pattern matching process.},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353883},
  keywords = {lse-pub kzInfrastructure kzPharo kzLanguageDesign},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Gael04c,
  author = {Markus Gaelli and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {One-Method Commands: Linking Methods and Their Tests},
  booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gael04c-LinkingMethodsAndTests.pdf},
  abstract = {Although unit testing is essential for programming, current languages only barely support the developer in composing unit tests into new ones or in navigating between unit tests and their corresponding methods under test. We have taken several Smalltalk programs and analyzed the relationships between unit tests and methods under test, and the re- lationships amongst unit tests.	First results indicate that most unit tests can be seen or at least decomposed into commands which focus on single methods, and that large portions of unit tests overlap each other. But these relationships between unit tests and methods under test are not reflected in current languages. We therefore first conceptually extend the meta-model of Smalltalk with one-method commands so that unit tests become both com- posable and navigable. Then we introduce a first lightweight implementation of this meta model using method comments to differentiate between the several test phases of existing XUnit test case methods.},
  annote = {internationalworkshop},
  keywords = {snf05 scg-pub skip-doi gaelli kzChecking},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gael04cLinkingMethodsAndTests.pdf}}

@inproceedings{Marr15b,
  author = {Marr, Stefan and Ducasse, St\'ephane},
  title = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},
  booktitle = {OOPSLA'2015},
  publisher = {ACM},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  doi = {10.1145/2814270.2814275},
  abstract = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.
This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object- oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},
  numpages = {10},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  series = {OOPSLA'15},
  annote = {topconference},
  keywords = {lse-pub kzLanguageDesign stefPub},
  hal-id = {hal-01205345},
  keywords = {lse-pub kzLanguageDesign stefPub},
  month = {jun}}

@inproceedings{Marr15a,
  author = {Marr, Stefan and Seaton, Chris and Ducasse, St\'ephane},
  title = {Zero-Overhead Metaprogramming: Reflection and Metaobject Protocols Fast and without Compromises},
  booktitle = {PLDI - Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher = {ACM},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15a-PLDI15-ZeroOverheadMetaprogramming.pdf},
  doi = {10.1145/2737924.2737963},
  abstract = {Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.},
  numpages = {10},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15a-PLDI15-ZeroOverheadMetaprogramming.pdf},
  series = {PLDI '15},
  annote = {topconference},
  keywords = {lse-pub kzLanguageDesign kzClutter stefPub},
  hal-id = {hal-01141135},
  inria = {RMOD},
  keywords = {lse-pub kzLanguageDesign kzClutter stefPub},
  month = {jun}}

@inproceedings{Dias15a,
  author = {Mart\'in Dias and Alberto Bacchelli and Georgios
 Gousios and Damien Cassou and St\'ephane Ducasse},
  title = {Untangling Fine-Grained Code Changes},
  booktitle = {SANER'15: Proceedings of the 22nd International Conference on Software Analysis, Evolution, and Reengineering},
  pages = {341--350},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias15a-Saner-FineGrainedChanges.pdf},
  acceptnum = {39},
  accepttotal = {144},
  address = {Montreal, Canada},
  abstract = {After working for some time, developers commit their code changes to a version control system. When doing
 so, they often bundle unrelated changes (e.g., bug fix and refactoring) in a single commit, thus creating a so-called tangled commit. Sharing tangled commits is problematic because it makes review, reversion, and integration of these commits harder and historical analyses of the project less reliable. Researchers have worked at untangling existing commits, i.e., finding which part of a commit relates to which task. In this paper, we contribute to this line of work in two ways: (1) A publicly available dataset of untangled code changes, created with the help of two developers who accurately split their code changes into self contained tasks over a period of four months; (2) a novel approach, EpiceaUntangler, to help developers share untangled commits (aka. atomic commits) by using fine-grained code change information. EpiceaUntangler is based and tested on the publicly available dataset, and further evaluated by deploying it to 7 developers, who used it for 2 weeks. We recorded a median success rate of 91% and average one of 75\%, in automatically creating clusters of untangled fine-grained code changes.},
  annote = {internationalconference},
  hal-id = {hal-01116225},
  keywords = {lse-pub pharo kzAnalysis kzChange kzMerging},
  note = {(candidate for IEEE Research Best Paper Award)},
  hal-url = {https://hal.inria.fr/hal-01116225},
  pages = {341--350}}

@inproceedings{Dias13a,
  author = {Mart\'in Dias and Damien Cassou and St\'ephane Ducasse},
  title = {Representing Code History with Development Environment Events},
  booktitle = {IWST'13: International Workshop on Smalltalk Technologies 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias13a-IWST13-Epicea.pdf},
  abstract = {Modern development environments handle information about the intent of the programmer: for example, they use abstract syntax trees for providing high-level code manipulation such as refactorings; nevertheless, they do not keep track of this information in a way that would simplify code sharing and change understanding. In most Smalltalk systems, source code modifications are immediately registered in a transaction log often called a ChangeSet. Such mechanism has proven reliability, but it has several limitations. In this paper we analyse such limitations and describe scenarios and requirements for tracking fine-grained code history with a semantic representation. We present Epicea, an early prototype implementation. We want to enrich code sharing with extra information from the IDE, which will help understanding the intention of the changes and let a new generation of tools act in consequence.},
  annote = {internationalworkshop},
  hal-id = {hal-00862626},
  keywords = {pharo lse-pub kzMerging kzMeta}}

@inproceedings{Dias15b,
  author = {Mart\'in Dias and Guillermo Polito and Damien Cassou and St\'ephane Ducasse},
  title = {DeltaImpactFinder: Assessing Semantic Merge Conflicts with Dependency Analysis},
  booktitle = {IWST'15: International Workshop on Smalltalk Technologies 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias15b-IWST-DeltaImpactFinder.pdf},
  url = {https://hal.inria.fr/hal-01199035},
  abstract = {In software development, version control systems (VCS) provide branching and merging support tools. Such tools are popular among developers to concurrently change a codebase in separate lines and reconcile their changes automatically afterwards. However, two changes that are correct independently can introduce bugs when merged together. We call semantic merge conflicts this kind of bugs.
Change impact analysis (CIA) aims at estimating the effects of a change in a codebase. In this paper, we propose to detect semantic merge conflicts using CIA. On a merge, DELTAIMPACTFINDER analyzes and compares the impact of a change in its origin and destination branches. We call the difference between these two impacts the delta-impact. If the delta-impact is empty, then there is no indicator of a semantic merge conflict and the merge can continue automatically. Otherwise, the delta-impact contains what are the sources of possible conflicts.},
  annote = {internationalworkshop},
  keywords = {pharo lse-pub kzMerging kzMeta},
  hal-id = {hal-01199035}}

@article{Dias14a,
  author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
  title = {Fuel: A Fast General-Purpose Object Graph Serializer},
  journal = {Journal of Software: Practice and Experience},
  volume = {44},
  pages = {433-453},
  publisher = {John Wiley \& Sons, Ltd.},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias14a-Official-SPE-Fuel.pdf},
  impactfactor = {Impact Factor (2012) 0.519},
  doi = {10.1002/spe.2136},
  annote = {internationaljournal},
  hal-id = {hal-00703574},
  keywords = {lse-pub pharo kzInfrastructure}}

@inproceedings{Dias11a,
  author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
  title = {Clustered Serialization with {Fuel}},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dia11a-IWST11-Fuel.pdf},
  doi = {10.1145/2166929.2166930},
  abstract = {Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614838},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter kzInfrastructure}}

@article{Dias16a,
  author = {Mart\'in Dias and St\'ephane Ducasse and Damien Cassou and Uquillas G\'{o}mez, Ver\'{o}nica},
  title = {Do Tools Support Code Integration? A Survey},
  journal = {Journal of Object Technology},
  volume = {16},
  pages = {2:1-20},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias16a-IntegratorSurvey.pdf},
  doi = {10.5381/jot.2016.15.2.a2},
  annote = {internationaljournal},
  keywords = {lse-pub kzMerging},
  number = {2},
  issn = {1660-1769},
  month = mar,
  pdf-second = {http://www.jot.fm/issues/issue_2016_02/article2.pdf}}

@article{Mart13a,
  author = {Martinez Peck, Mariano	and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Marea: An Efficient Application-Level Object Graph Swapper},
  journal = {Journal of Object Technology},
  volume = {12},
  pages = {2:1-30},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart12c-JOT-Marea.pdf},
  doi = {10.5381/jot.2013.12.1.a2},
  abstract = {Abstract During the execution of object-oriented
 applications, several millions of objects are
 created, used and then collected if they are not
 referenced. Problems appear when objects are unused
 but cannot be garbage-collected because they are
 still referenced from other objects. This is an
 issue because those objects waste primary memory and
 applications use more primary memory than they
 actually need. We claim that relying on the
 operating system's (OS) virtual memory is not always
 enough since it cannot take into account the domain
 and structure of applications. At the same time,
 applications have no easy way to parametrize nor
 cooperate with memory management. In this paper, we
 present Marea, an efficient application-level object
 graph swapper for object-oriented programming
 languages. Its main goal is to offer the programmer
 a novel solution to handle application-level memory.
 Developers can instruct our system to release
 primary memory by swapping out unused yet referenced
 objects to secondary memory. Our approach has been
 qualitatively and quantitatively validated. Our
 experiments and benchmarks on real-world
 applications show that Marea can reduce the memory
 footprint between 23\% and 36\%.},
  annote = {internationaljournal},
  hal-id = {hal-00781129},
  keywords = {pharo-pub lse-pub kzClutter pharo},
  month = {jan},
  number = {1}}

@inproceedings{Mart10b,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Experiments with a Fast Object Swapper},
  booktitle = {Smalltalks 2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart10b-Smalltalks2010-Swapper-ImageSegments.pdf},
  abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running. Graph exporting and swapping are two important object graph operations. Exporting refers to copying the graph to some other memory so that it can be loaded by another system. Swapping refers to moving the graph to a secondary memory (e.g., a hard disk) to temporary release part of the primary memory.
While exporting and swapping are achieved in different ways, each of them faces a common and central problem which is the speed of the approach in presence of large object graphs. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with extremely common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph. This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present most of the general problems of object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk. However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
  address = {Concepci\'on del Uruguay, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00531565},
  inriareport = {2010},
  keywords = {stefPub lse-pub marcusdenker pharo pharo-pub kzClutter}}

@inproceedings{Mart11a,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Efficient Proxies in {Smalltalk}},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'11)},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11a-IWST11-Ghost.pdf},
  doi = {10.1145/2166929.2166937},
  abstract = {A proxy object is a surrogate or placeholder that controls access to another target object.	Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-languages communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but they are unable to create proxies for classes or methods. Proxies can be complex to install, have a significant overhead, be limited to certain type of classes, etc. Moreover, most proxy implementations are not stratified at all and there is no separation between proxies and handlers. In this paper, we present Ghost, a uniform, light-weight and stratified general purpose proxy model and its Smalltalk implementation.Ghost supports proxies for classes or methods. When a proxy takes the place of a class it intercepts both, messages received by the class and lookup of methods for messages received by instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614720},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzLanguageDesign kzClutter}}

@inproceedings{Mart10a,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Visualizing Objects and Memory Usage},
  booktitle = {Smalltalks 2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart10a-Smalltalks2010-VisualizingUnusedObjects.pdf},
  abstract = {Most of the current garbage collector implementations work by reachability. This means they only take care of the objects that nobody else points to. As a consequence, there are objects which are not really used but are not garbage collected because they are still referenced. Such unused but reachable objects create memory leaks. This is a problem because applications use much more memory than what is actually needed. In addition, they may get slower and crash. It is important to understand which parts of the system are instantiated but also which are used or unused. There is a plethora of work on runtime information or class instantiation visualizations but none of them show whether instances are actually used. Such information is important to identify memory leaks.
In this paper, we present some visualizations that show used/unused objects in object-oriented applications. For this, we use Distribution Map which is a visualization showing spread and focus of properties across systems. We extend Distribution Maps to represent the way classes are used or not, since we distinguish between a class that just has instances from one that has used instances. To identify unused objects, we modified the Pharo Virtual Machine.},
  address = {Concepci\'on del Uruguay, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00531510},
  inriareport = {2010},
  keywords = {moose stefPub lse-pub marcusdenker pharo pharo-pub kzVisualization kzClutter}}

@inproceedings{Mart11b,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Problems and Challenges when Building a Manager for Unused Objects},
  booktitle = {Proceedings of Smalltalks 2011 International Workshop},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11b-Smalltalks2011-UOM.pdf},
  abstract = {Large object-oriented applications may occupy hundreds of megabytes or even gigabytes of memory. During program execution, a large graph of objects is created and constantly changed.
Most object runtimes support some kind of automatic memory management based on garbage collectors (GC) whose idea is the automatic destruction of unreferenced objects. However, there are referenced objects which are not used for a long period of time or that are used just once. These are not garbage-collected because they are still reachable and might be used in the future. Due to these unused objects, applications use much more resources than they actually need.
In this paper we present the challenges and possible approaches towards an unused object manager for Pharo. The goal is to use less memory by swapping out the unused objects to secondary memory and only leaving in primary memory only those objects which are needed and used. When one of the unused objects is needed, it is brought back into primary memory.},
  address = {Bernal, Buenos Aires, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00635793},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter}}

@article{Mart11c,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and St\'ephane Ducasse and Luc Fabresse},
  title = {Object Swapping Challenges: an Evaluation of {ImageSegment}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {38},
  pages = {1--15},
  publisher = {Elsevier},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11c-COMLAN-ObjectSwapping.pdf},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2011.10.001},
  abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running.
Graph exporting and swapping are two important object graph operations.
Exporting refers to copying the graph to some other memory so that it can be loaded by another system.
Swapping refers to moving the graph to a secondary memory (for example, a hard disk) to temporary release part of the primary memory (for example, RAM).
Exporting and swapping are achieved in different ways and the speed in presence of large object graphs is critical. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with	common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph.	This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present all general problems to our knowledge about object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk.
However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
  annote = {internationaljournal},
  hal-id = {hal-00646897},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter},
  month = {nov},
  number = {1}}

@inproceedings{Suen07a,
  author = {Mathieu Suen and St\'ephane Ducasse and Damien Pollet and Hani Abdeen and Ilham Alloui},
  title = {Package Surface Blueprint: A Software Map},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop stefPub},
  keywords = {moose kzVisualization}}

@inproceedings{Mar17a,
  author = {Matteo Marra and Elisa Gonzalez Boix and Steven Costiou and Micka\"el Kerboeuf and Alain Plantec and Guillermo Polito and St\'ephane Ducasse},
  title = {Debugging Cyber-Physical Systems with Pharo},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {8:1--8:10},
  publisher = {ACM},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mar17a-IWST-DebuggingIoT.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01585349},
  doi = {10.1145/3139903.3139913},
  annote = {internationalworkshop},
  abstract = {Cyber-Physical Systems (CPS) integrate sensors and actua-tors to collect data and control entities in the physical world. Debugging CPS systems is hard due to the time-sensitive nature of a distributed applications combined with the lack of control on the surrounding physical environment. This makes bugs in CPS systems hard to reproduce and thus to fix. In this context, on-line debugging techniques are helpful because the debugger is connected to the device when an exception or crash occurs. This paper reports on our experiences on applying two different on-line debugging techniques for a CPS system: remote debugging using the Pharo remote debugger and our IDRA debugger. In contrast to traditional remote debug-ging, IDRA allows to on-line debug an application locally in another client machine by reproducing the runtime context where the bug manifested. Our qualitative evaluation shows that IDRA provides almost the same interaction capabilities than Pharo's remote debugger and is less intrusive when performing hot-modifications. Our benchmarks also show that IDRA is significantly faster than the Pharo remote debugger, although it increases the amount of data transferred over the network.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {8},
  numpages = {10},
  address = {New York, NY, USA},
  keywords = {Cyber-Physical Systems ; software tools ; debugging; lse-pub kzInfrastructure},
  hal-id = {hal-01585349}}

@inproceedings{Rieg98a,
  author = {Matthias Rieger and St\'ephane Ducasse},
  title = {Visual Detection of Duplicated Code},
  booktitle = {Proceedings ECOOP Workshop on Experiences in Object-Oriented Re-Engineering},
  publisher = {Forschungszentrum Informatik Karlsruhe},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg98aEcoopWorkshop.pdf},
  abstract = {Code duplication is considered as bad practice that
 complicates the maintenance and evolution of
 software. Detecting duplicated code is a difficult
 task because of the large amount of data to be
 checked and the fact that a priori it is unknown
 which code part has been duplicated. In this paper,
 we present a tool called DUPLOC that supports code
 duplication detection in a visual and exploratory or
 an automatic way.},
  annote = {internationalworkshop},
  editor = {St\'ephane Ducasse and Joachim Weisbrod},
  keywords = {scg-pub skip-doi kzDuplication},
  number = {6/7/98},
  series = {FZI Report}}

@inproceedings{Rieg98b,
  author = {Matthias Rieger and St\'ephane Ducasse},
  title = {Visual Detection of Duplicated Code},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
  volume = {1543},
  pages = {75--76},
  publisher = {Springer-Verlag},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg98aEcoopWorkshop.pdf},
  abstract = {Code duplication is considered as bad practice that
 complicates the maintenance and evolution of
 software. Detecting duplicated code is a difficult
 task because of the large amount of data to be
 checked and the fact that a priori it is unknown
 which code part has been duplicated. In this paper,
 we present a tool called DUPLOC that supports code
 duplication detection in a visual and exploratory or
 an automatic way.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {scg-pub skip-doi stefPub kzVisualization kzDuplication},
  month = jul,
  series = {LNCS}}

@inproceedings{Rieg99a,
  author = {Matthias Rieger and St\'ephane Ducasse and Georges Golomingi},
  title = {Tool Support for Refactoring Duplicated OO Code},
  booktitle = {Object-Oriented Technology (ECOOP '99 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg99aToolSuppRefacOOCode.pdf},
  abstract = {Code duplication is an important problem in
 application maintenance. Tools exist that support
 code duplication detection. However, few of them
 propose a solution for the problem, i.e.
 refactorings. We propose an approach that uses the
 information given by code duplication detection to
 guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  keywords = {olit scg-pub skip-doi jb-none kzVisualization kzDuplication},
  number = {1743},
  series = {LNCS}}

@inproceedings{Rieg04b,
  author = {Matthias Rieger and St\'ephane Ducasse and Michele Lanza},
  title = {Insights into System-Wide Code Duplication},
  booktitle = {Proceedings of 11th Working Conference on Reverse Engineering (WCRE'04)},
  pages = {100--109},
  publisher = {IEEE Computer Society Press},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg04bWCRE2004ClonesVisualization.pdf},
  misc = {acceptance rate: 28/78 = 36\%},
  doi = {10.1109/WCRE.2004.25},
  abstract = {Duplication of code is a common phenomenon in the
 development and maintenance of large software
 systems. The detection and removal of duplicated
 code has become a standard activity during the
 refactoring phases of a software life-cycle.
 However, code duplication identification ends to
 produce large amounts of data making the
 understanding of the duplication situation as a
 whole difficult. Reengineers can easily lose sight
 of the forest for the trees. There is a need to
 support a qualitative analysis of the duplicated
 code. In this paper we propose a number of
 visualzations of duplicated source elements that
 support reengineers in answering questions, e.g.,
 which parts of the sysem are connected by copied
 code or which parts of the sysem are copied the
 most.},
  acceptnum = {28},
  accepttotal = {78},
  annote = {internationalconference},
  cvs = {DuplocVizPaper},
  keywords = {scg-pub stefPub clones kzDuplication},
  location = {Delft, The Netherlands},
  month = nov}

@inproceedings{Seeb06b,
  author = {Mauricio Seeberger and Adrian Kuhn and Tudor G\^irba and St\'ephane Ducasse},
  title = {{Chronia}: Visualizing How Developers Change Software Systems},
  booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
  pages = {345--346},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Seeb06bChronia.pdf},
  abstract = {To understand a certain issue of the system we want
 to ask the knowledgeable developers. Yet, in large
 systems, not every developer is knowledgeable in all
 the details of the system. Thus, we would want to
 know which developer is knowledgeable in the issue
 at hand. In this paper we present the Chronia tool
 that implements the Ownership Map visu- alization to
 understand when and how different developers
 interacted in which way and in which part of the
 system. circle reflects the size of the change, and
 the color of the line denotes the author who owns
 most of the lines of code of the file in that
 period. File A commit by the green author followed
 by the ownership file removed by the blue author
 file present from the first import},
  annote = {tooldemo},
  cvs = {ChroniaDemoCSMR2006},
  keywords = {scg-misc moose stefPub kzVisualization girba chronia},
  month = mar,
  note = {Tool demo}}

@inproceedings{Wint02a,
  author = {Michael Winter and Thomas Gen{\ss}ler and Alexander Christoph and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Gabriela Ar{\'e}valo and Peter M\"uller and Christian Stich and Bastiaan Sch\"onhage},
  title = {Components for Embedded Software --- The PECOS Approach},
  booktitle = {Proc. Second International Workshop on Composition Languages},
  year = {2002},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wint02a.pdf},
  abstract = {This paper presents a domain specific composition language called CoCo. The CoCo language has been
developed in the context of the PECOS project which aims at enabling component-based technology for a		certain class of embedded systems called "field devices".},
  annote = {internationalworkshop},
  keywords = {pecos stefPub arevalo kzComponent kzLanguageDesign},
  note = {In conjunction with 16th European Conference on Object-Oriented Programming (ECOOP) Malaga, Spain, June 11, 2002}}

@inproceedings{Lanz01d,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {The Class Blueprint: A Visualization of the Internal Structure of Classes},
  booktitle = {Workshop Proceedings of OOPSLA 2001},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01dClassBlueprint.pdf},
  abstract = {Understanding classes is a key activity in
 object-oriented programming, since classes represent
 the primary abstractions from which applications are
 built. The main problem of this task is to quickly
 grasp the purpose and inner structure of a class. In
 this paper we discuss the class blueprint, a
 visualization of the inner structure of classes.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization}}

@inproceedings{Lanz02a,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Understanding Software Evolution Using a Combination of Software Visualization and Software Metrics},
  booktitle = {Proceedings of Langages et Mod\`eles \`a Objets (LMO'02)},
  pages = {135--149},
  publisher = {Lavoisier},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz02aEvolutionMatrix.pdf},
  abstract = {Coping with huge amounts of data is one of the major
 problems in the context of software evolution.
 Current approaches reduce this complexity by
 filtering out irrelevant information. In this paper
 we propose an approach based on a combination of
 software visualization and software metrics, as
 software visualization is apt for complexity
 reduction and metrics introduce the possibility to
 qualify evolution. We discuss a simple and effective
 way to visualize the evolution of software systems
 which helps to recover the evolution of object
 oriented software systems. In addition we define a
 vocabulary that qualifies some specific situations
 that occurs when considering system evolution.},
  address = {Paris},
  annote = {nationalconference},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization kzMetric kzHistory}}

@article{Lanz03d,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Polymetric Views---A Lightweight Visual Approach to Reverse Engineering},
  journal = {Transactions on Software Engineering (TSE)},
  volume = {29},
  pages = {782--795},
  publisher = {IEEE Computer Society},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz03dTSEPolymetric.pdf},
  impactfactor = {5-Year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2003.1232284},
  abstract = {Reverse engineering software systems has become a
 major concern in software industry because of their
 sheer size and complexity. This problem needs to be
 tackled, since the systems in question are of
 considerable worth to their owners an d maintainers.
 In this article we present the concept of a
 polymetric view, a lightweight software
 visualization technique enriched with software
 metrics information. Polymetric views help to
 understand the structure and detect problems of a
 software system in the initial phases of a reverse
 engineering process. We discuss the benefits and
 limits of several predefined polymetric views we
 have implemented in our tool CodeCrawler. Moreover,
 based on clusters of different polymetric views we
 have developed a methodology which supports and
 guides a software engineer in the first phases of a
 reverse engineering of a large software system. We
 have refined this methodology by repeatedly applying
 it on industrial systems, and illustrate it by
 applying a selection of polymetric views to a case
 study.},
  annote = {internationaljournal},
  keywords = {scg-pub recast04 stefPub moose kzVisualization},
  month = sep,
  number = {9}}

@inproceedings{Lanz01b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {A {Categorization} of {Classes} based on the {Visualization} of their {Internal} {Structure}: the {Class} {Blueprint}},
  booktitle = {Proceedings of 16th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '01)},
  pages = {300--311},
  publisher = {ACM Press},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01bClassBlueprint.pdf},
  misc = {acceptance rate: 27/145 = 18\%},
  doi = {10.1145/504282.504304},
  abstract = {The reengineering and reverse engineering of
 software systems is gaining importance in software
 industry, because the accelerated turnover in
 software companies creates legacy systems in a
 shorter period of time. Especially understanding
 classes is a key activity in object-oriented
 programming, since classes represent the primary
 abstractions from which applications are built. The
 main problem of this task is to quickly grasp the
 purpose of a class and its inner structure. To help
 the reverse engineers in their first contact with a
 foreign system, we propose a categorization of
 classes based on the visualization of their internal
 structure. The contributions of this paper are a
 novel categorization of classes and a visualization
 of the classes which we call the class blueprint. We
 have validated the categorization on several case
 studies, two of which we present here.},
  acceptnum = {27},
  accepttotal = {145},
  annote = {internationalconference topconference},
  keywords = {scg-pub stefPub moose kzVisualization}}

@inproceedings{Lanz02b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Beyond Language Independent Object-Oriented Metrics: Model Independent Metrics},
  booktitle = {Proceedings of the 6th International Workshop on Quantitative Approaches in Object-Oriented Software Engineering},
  pages = {77--84},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz02bModelIndependentMetrics.pdf},
  abstract = {Software Metrics have become essential in software
 engineering for several reasons, among which quality
 assessment and reengineering. In the context of the
 European Esprit Project FAMOOS, whose main goal was
 to provide methodologies for the reengineering of
 large industrial software systems, we have developed
 the Moose Reengineering Environment, based on the
 language independent FAMIX metamodel. Moose includes
 a metrics engine which supports language independent
 metrics, since coping with software written in
 different implementation languages was one of the
 project's main constraints. Our current research is
 pushing us towards the development and
 implementation of a metametamodel, which would
 include our metamodel and allow for several
 extension in different research directions, among
 which concept analysis, knowledge management and
 software evolution. In this article we want to
 present our current and future work for the
 transition from language independent to domain
 independent metrics.},
  annote = {internationalworkshop},
  editor = {Fernando Brito e Abreu and Mario Piattini and Geert Poels and Houari A. Sahraoui},
  isbn = {84-699-8696-1},
  keywords = {scg-pub skip-doi stefPub moose kzMetric kzMeta}}

@incollection{Lanz05b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {CodeCrawler --- An Extensible and Language Independent 2D and 3D Software Visualization Tool},
  booktitle = {Tools for Software Maintenance and Reengineering},
  pages = {74--94},
  publisher = {Franco Angeli},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz05bCCBookChapter.pdf},
  abstract = {CodeCrawler is an extensible and language
 independent software visualization tool. It has been
 validated in several industrial case studies over
 the past years. CodeCrawler enables the fast
 exploration of new visualization ideas. It
 implements and visualizes polymetric views,
 visualizations of software enriched with information
 such as software metrics and other source code
 semantics. It provides a rich set of views that can
 be customized using a large set of metrics. While
 CodeCrawler is mainly targeted at visualizing
 object-oriented software, in its latest
 implementation it has become a general information
 visualization tool.},
  address = {Milano},
  annote = {articlebook},
  isbn = {88-464-6396-X},
  keywords = {scg-pub skip-doi stefPub recast05 moose kzVisualization kzTools},
  series = {RCOST / Software Technology Series}}

@inproceedings{Lanz05a,
  author = {Michele Lanza and St\'ephane Ducasse and Harald Gall and Martin Pinzger},
  title = {CodeCrawler --- An Information Visualization Tool for Program Comprehension},
  booktitle = {Proceedings of ICSE 2005 (27th IEEE International Conference on Software Engineering)},
  pages = {672--673},
  publisher = {ACM Press},
  year = {2005},
  annote = {tooldemo},
  keywords = {stefPub moose kzVisualization}}

@inproceedings{Lanz01a,
  author = {Michele Lanza and St\'ephane Ducasse and Lukas Steiger},
  title = {Understanding Software Evolution using a Flexible Query Engine},
  booktitle = {Proceedings of the Workshop on Formal Foundations of Software Evolution},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01aQueryEngine.pdf},
  abstract = {One of the main problems which arises in the field
 of software evolution is the sheer amount of
 information to be dealt with. Compared to reverse
 engineering where the main goal is the main
 understanding of one single system. In the field of
 software evolution this information is multiplied by
 the number of versions of the system one wants to
 understand. To counter this problem we have come up
 with a flexible query engine which can perform
 queries on the different versions of a system. In
 this paper we give an outlook on our current work in
 the field of software evolution and focus
 particularly on the concepts behind the query engine
 we have built.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization kzHistory}}

@inproceedings{Miss19a,
  author = {Misse-Chanabier, Pierre and Aranega, Vincent and Polito, Guillermo and Ducasse, St\'ephane},
  title = {Illicium A modular transpilation toolchain from Pharo to C},
  booktitle = {International workshop of Smalltalk Technologies},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Miss19a-IWST-Transpilation.pdf},
  address = {K{\"o}ln, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {kzVM lse-pub},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02297860/file/final_submission.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02297860},
  hal-id = {hal-02297860}}

@article{Bhat12b,
  author = {Muhammad U. Bhatti and Nicolas Anquetil and St\'ephane Ducasse},
  title = {An Environment for dedicated Software Analysis tools},
  journal = {ERCIM News},
  volume = {88},
  pages = {12--13},
  year = {2012},
  pdf = {http://ercim-news.ercim.eu/images/stories/EN88/EN88-web.pdf},
  abstract = {Moose is an open-source platform for the assessment of software and data analysis. Moose provides several engines to build tools, analyses and visualizations. One of Moose's strengths is the possibility to rapidly build domain-specific analysis tools.},
  annote = {vulgarisation},
  hal-id = {hal-00759511},
  keywords = {moose lse-pub raweb2012 kzIDE kzMoose},
  month = jan,
  tagnicolasa = {other analysis}}

@inproceedings{Bhat12a,
  author = {Muhammad U.Bhatti and Nicolas Anquetil and Marianne Huchard and St\'ephane Ducasse},
  title = {A Catalog of Patterns for Concept Lattice Interpretation in Software Reengineering},
  booktitle = {Proceedings of the 24th International Conference on Software Engineering \& Knowledge Engineering (SEKE 2012)},
  pages = {118--24},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat12c-SEKE2012-FCA-patterns.pdf},
  misc = {acceptance rate: 59/219 = 27\%},
  abstract = {Formal Concept Analysis (FCA) provides an important approach in software reengineering for software understanding,	design anomalies detection and correction.
However, FCA-based approaches	have two problems: (i) they produce lattices that must be interpreted by the user according to his/her understanding of the technique and different elements of the graph; and, (ii) the lattice can rapidly become so big that one is overwhelmed by the mass of information and possibilities.
In this paper, we present	a catalog of important patterns in concept lattices, which can allow automating the task of lattice interpretation. The approach helps the reengineer to concentrate on the task of reengineering rather than understanding a complex lattice.
We provide interpretation of these patterns in a generalized manner and illustrate them on various contexts constructed from program information of different open-source systems. We also present a tool that allows automated extraction of the patterns from concept lattices.},
  acceptnum = {59},
  accepttotal = {219},
  annote = {internationalconference},
  hal-id = {hal-00700046},
  isbn = {978-1-891706-31-8},
  keywords = {lse-pub stefPub kzRemodularisation},
  tagnicolasa = {architecture FCA}}

@inproceedings{Scha04b,
  author = {Nathanael Sch\"arli and Andrew P. Black and St\'ephane Ducasse},
  title = {Object-oriented Encapsulation for Dynamically Typed Languages},
  booktitle = {Proceedings of 18th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'04)},
  pages = {130--149},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha04b-OOPSLA-OOEncapsulation.pdf},
  misc = {acceptance rate: 27/174 = 16\%},
  doi = {10.1145/1028976.1028988},
  abstract = {Encapsulation in object-oriented languages has
 traditionally been based on static type systems. As
 a consequence, dynamically-typed languages have only
 limited support for encapsulation. This is
 surprising, considering that encapsulation is one of
 the most fundamental and important concepts behind
 object-oriented programming and that it is essential
 for writing programs that are maintainable and
 reliable, and that remain robust as they evolve. In
 this paper we describe the problems that are caused
 by insufficient encapsulation mechanisms and then
 present object-oriented encapsulation, a simple and
 uniform approach that solves these problems by
 bringing state of the art encapsulation features to
 dynamically typed languages. We provide a detailed
 discussion of our design rationales and compare them
 and their consequences to the encapsulation
 approaches used for statically typed languages. We
 also describe an implementation of object-oriented
 encapsulation in Smalltalk. Benchmarks show that
 extensive use of object-oriented encapsulation
 results in a slowdown of less than 15 per cent.},
  acceptnum = {27},
  accepttotal = {174},
  annote = {internationalconference topconference},
  cvs = {OOEncapsulationOOPSLA2004},
  keywords = {scg-pub stefPub kzLanguageDesign},
  month = oct}

@inproceedings{Scha03a,
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
  title = {Traits: Composable Units of Behavior},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming},
  volume = {2743},
  pages = {248--274},
  publisher = {Springer Verlag},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha03a-ECOOP-Traits.pdf},
  misc = {acceptance rate: 18/88 = 20\%},
  doi = {10.1007/b11832},
  abstract = {Despite the undisputed prominence of inheritance as
 the fundamental reuse mechanism in object-oriented
 programming languages, the main variants --- single
 inheritance, multiple inheritance, and mixin
 inheritance --- all suffer from conceptual and
 practical problems. In the first part of this paper,
 we identify and illustrate these problems. We then
 present traits, a simple compositional model for
 structuring object-oriented programs. A trait is
 essentially a group of pure methods that serves as a
 building block for classes and is a primitive unit
 of code reuse. In this model, classes are composed
 from a set of traits by specifying glue code that
 connects the traits together and accesses the
 necessary state. We demonstrate how traits overcome
 the problems arising from the different variants of
 inheritance, we discuss how traits can be
 implemented effectively, and we summarize our
 experience applying traits to refactor an existing
 class hierarchy.},
  acceptnum = {18},
  accepttotal = {88},
  annote = {internationalconference topconference},
  cvs = {TraitsECOOP2003},
  isbn = {978-3-540-40531-3},
  keywords = {scg-pub traits stefPub kzTrait},
  month = jul,
  series = {LNCS}}

@inproceedings{Scha04a,
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Composable Encapsulation Policies},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'04)},
  volume = {3086},
  pages = {26--50},
  publisher = {Springer Verlag},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha04a-ECOOP-EncapsulationPolicies.pdf},
  misc = {acceptance rate: 25/132 = 19\%},
  doi = {10.1007/b98195},
  abstract = {Given the importance of encapsulation to
 object-oriented programming, it is surprising to
 note that mainstream object-oriented languages offer
 only limited and fixed ways of encapsulating
 methods. Typically one may only address two
 categories of clients, users and heirs, and one must
 bind visibility and access rights at an early stage.
 This can lead to inflexible and fragile code as well
 as clumsy workarounds. We propose a simple and
 general solution to this problem in which
 encapsulation policies can be specified separately
 from implementations. As such they become
 first-class composable entities that can be reused
 by different classes. We present a detailed analysis
 of the problem with encapsulation and visibility
 mechanisms in mainstream OO languages, we introduce
 our approach in terms of a simple model, and we
 evaluate how our approach compares with existing
 approaches. We also assess the impact of
 incorporating encapsulation policies into Smalltalk
 and discuss some implementation issues.},
  acceptnum = {25},
  accepttotal = {132},
  annote = {internationalconference topconference},
  isbn = {978-3-540-22159-3},
  keywords = {scg-pub stefPub kzLanguageDesign},
  month = jun,
  series = {LNCS}}

@inproceedings{Scha02a,
  author = {Nathanael Sch{\"a}rli and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Classes = Traits + States + Glue (Beyond mixins and multiple inheritance)},
  booktitle = {Proceedings of the International Workshop on Inheritance},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha02aTraitsPlusGlue2002.pdf},
  abstract = {We present a simple, component-based model of
 mixins, called traits, and argue that this simple
 model sidesteps many of the practical problems with
 other approaches to mixins and multiple inheritance.
 With our model, classes are built from a set of
 traits by specifying glue code that connects them
 together and accesses the necessary state. We
 briefly discuss practical experience with an
 implementation of traits for Squeak, and we list a
 number of open questions for discussion.},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub kzTrait}}

@article{Papo16a,
  author = {Nick Papoulias and Marcus Denker and	St\'ephane Ducasse and Luc Fabresse},
  title = {End-User Abstractions for Meta-Control: Reifying the Reflectogram},
  journal = {Science of Computer Programming},
  volume = {140},
  pages = {2--16},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo16a-reflectogram-scp.pdf},
  url = {https://hal.inria.fr/hal-01424787},
  doi = {10.1016/j.scico.2016.12.002},
  hal-id = {hal-01424787},
  annote = {internationaljournal},
  abstract = {Reflective facilities in OO languages are used both for implementing language extensions (such as AOP frameworks) and for supporting new programming tools and methodologies (such as object-centric debugging and message-based profiling). Yet controlling the runtime behavior of these reflective facilities introduces several challenges, such as computational overhead, the possibility of meta-recursion and an unclean separation of concerns between base and meta-level. In this paper we present five dimensions of meta-level control from related literature that try to remedy these problems. These dimensions are namely: temporal and spatial control, placement control, level control and identity control. We then discuss how these dimensions interact with language semantics in class-based OO languages in terms of: scoping, inheritance and first-class entities. We argue that the reification of the descriptive notion of reflectogram can unify the control of meta-level execution in all these five dimensions while expressing properly the underlying language semantics. We present an extended model for the reification of the reflectogram based on our additional analysis and validate our approach through a new prototype implementation that relies on byte-code instrumentation. Finally, we illustrate our approach through a case study on runtime tracing.},
  keywords = {stefpub lse-pub marcusdenker reflection}}

@inproceedings{Anq19a,
  author = {Nicolas Anquetil and Anne Etien and Gaelle Andreo and St\'ephane Ducasse},
  title = {{Decomposing God Classes at Siemens}},
  booktitle = {2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02395836},
  abstract = {A group of developers at Siemens Digital Industry Division approached our team to help them restructure a large legacy system. Several problems were identified, including the presence of God classes (big classes with thousands of lines of code and hundred of methods). They had tried different approaches considering the dependencies between the classes, but none were satisfactory. Through interaction during the last three years with a lead software architect of the project, we designed a software visualization tool and an accompanying process that allows her to propose a decomposition of a God Class in a matter of one or two hours even without prior knowledge of the class (although actually implementing the decomposition in the source code could take a week of work). In this paper, we present the process that was formalized to decompose God Classes and the tool that was designed. We give details on the system itself and some of the classes that were decomposed. The presented process and visualisations have been successfully used for the last three years on a real industrial system at Siemens.},
  address = {Cleveland, OH, USA},
  month = oct,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case},
  hal-id = {hal-02395836},
  tagnicolasa = {architecture},
  annote = {topconference internationalconference},
  rate = {50\%}}

@inproceedings{Anqu20a,
  author = {Nicolas Anquetil and Anne Etien and Houekpetodji, Mahugnon Honor\'e and Benoit Verhaeghe St\'ephane Ducasse and Clotilde Toullec and Fatija Djareddir and J\`erome Sudich and Mustapha Derras},
  title = {Modular Moose:  A new generation of software reengineering platform},
  booktitle = {International Conference on Software and Systems Reuse, ICSR2020},
  year = {2020},
  annote = {internationalconference},
  keywords = {kzEvolution},
  month = dec}

@inproceedings{Anqu17b,
  author = {Nicolas Anquetil and Muhammad Bhatti and St\'ephane Ducasse and Andr\'e Hora and Jannik Laval},
  title = {The Case for Non-Cohesive Packages},
  booktitle = {SQAMIA 2017 - 6th workshop on Software Quality Analysis, Monitoring, Improvement, and Applications},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu17b-Sqamia-Metrics.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01585703},
  abstract = {While the lack of cohesiveness of modules in procedural languages is a good way to identify modules with potential quality problems, we doubt that it is an adequate measure for packages in object-oriented systems. Indeed, mapping procedural metrics to object-oriented systems should take into account the building principles of object-oriented programming: inheritance and late binding. Inheritance offers the possibility to create packages by just extending classes with the necessary increment of behavior. Late binding coupled to the " Hollywood Principle " are a key to build frameworks and let the users branch their extensions in the framework. Therefore, a package extending a framework does not have to be cohesive, since it inherits the framework logic, which is encapsulated in framework packages. In such a case, the correct modularization of an extender application may imply low cohesion for some of the packages. In this paper we confirm these conjectures on various real systems (JHotdraw, Eclipse, JEdit, JFace) using or extending OO frameworks. We carry out a dependency analysis of packages to measure their relation with their framework. The results show that framework dependencies form a considerable portion of the overall package dependencies. This means that non-cohesive packages should not be considered systematically as packages of low quality.},
  annote = {internationalworkshop},
  hal-id = {hal-01585703},
  tagnicolasa = {architecture},
  url-conference = {http://ceur-ws.org/Vol-1938/paper-anq.pdf},
  hal-url = {https://hal.inria.fr/hal-01585703},
  month = {sep},
  keywords = {lse-pub kzMetric kzEvolution},
  address = {Belgrade, Serbia}}

@article{Anqu14a,
  author = {Nicolas Anquetil and St\'ephane Ducasse and Muhammad U. Bhatti},
  title = {Dedicated Software Analysis Tools},
  journal = {ERCIM News},
  volume = {99},
  pages = {22--23},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu14a-Ercim-EN99-web.pdf},
  annote = {vulgarisation},
  keywords = {moose lse-pub raweb2014 StePub kzIDE kzTools},
  month = oct,
  tagnicolasa = {other analysis},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu14a-Ercim-EN99-web.pdf}}

@incollection{Cell13a,
  author = {Nicolas Cellier and St\'ephane Ducasse},
  title = {Fun with Floats},
  booktitle = {Deep Into Pharo},
  pages = 10,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  isbn = {978-3-9523341-6-4},
  annote = {articlebook},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming, kzVulgarisation},
  month = sep}

@misc{Auve16a,
  author = {Olivier Auverlot and St\'ephane Ducasse},
  title = {Un Chat en Pharo},
  journal = {GNU Linux Magazine},
  year = {2016},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub pharo kzWeb kzTeaching},
  month = jan,
  hal-url = {http://hal.inria.fr/hal-01353594},
  hal-id = {hal-01353594},
  number = 189}

@misc{Auve11a,
  author = {Olivier Auverlot and St\'ephane Ducasse},
  title = {Construire un service Rest avec Pharo et Seaside-Rest},
  journal = {Linux Magazine},
  volume = 1,
  year = {2011},
  annote = {vulgarisation},
  hal-id = {hal-00746254},
  hal-url = {http://hal.inria.fr/hal-00746254},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzWeb kzTeaching},
  month = sep,
  number = 141}

@book{Auve19a,
  author = {Olivier Auverlot and St\'ephane Ducasse and Luc Fabresse},
  title = {TinyBlog: Develop your First Web App with Pharo},
  pages = {110},
  publisher = {Square Bracket Associates},
  year = {2019},
  hal-url = {http://hal.inria.fr/hal-02297688},
  hal-id = {hal-02297688},
  keywords = {moose StefPub}}

@book{Auve19b,
  author = {Olivier Auverlot and St\'ephane Ducasse and Luc Fabresse},
  title = {TinyBlog: Cr\'eer votre Premi\`ere Application Web avec Pharo},
  pages = {142},
  publisher = {Square Bracket Associates},
  year = {2019},
  hal-id = {hal-02297691},
  hal-url = {http://hal.inria.fr/hal-02297691},
  keywords = {moose StefPub}}

@inproceedings{Gree05b,
  author = {Orla Greevy and St\'ephane Ducasse},
  title = {Characterizing the Functional Roles of Classes and Methods by Analyzing Feature Traces},
  booktitle = {Proceedings of WOOR 2005 (6th International Workshop on Object-Oriented Reengineering)},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05bTraceScraperWOOR2005.pdf},
  abstract = {Software developers are often faced with the task of
 maintaining or extending large and complex
 applications, with which they are unfamiliar.
 Typically change requests and bug reports are
 expressed in terms of system features. Much of the
 maintenance effort is spent trying to identify which
 classes and methods provide functionality to
 individual features. To tackle this problem, we
 propose an approach based on dynamic analysis that
 exploits the relationship between features and
 software entities. Our definition of a feature is a
 unit of observable behavior of a software system. We
 apply our approach to a large open source
 application and identify key classes and methods
 which provide functionality to individual features.},
  annote = {internationalworkshop},
  cvs = {TraceScraperWOOR2005},
  keywords = {scg-pub skip-doi greevy jb06 MISSINGPAGENUMBERS stefPub Feature Feature-Traces Dynamic Analysis Evolution moose recast05 kzDynamicInformation},
  month = jul}

@inproceedings{Gree05a,
  author = {Orla Greevy and St\'ephane Ducasse},
  title = {Correlating Features and Code Using A Compact Two-Sided Trace Analysis Approach},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
  pages = {314--323},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05aTraceScraperCSMR2005Features.pdf},
  misc = {acceptance rate: 33/81 = 41\%},
  doi = {10.1109/CSMR.2005.21},
  abstract = {Software developers are constantly required to
 modify and adapt features of an application in
 response to changing requirements. The problem is
 that just by reading the source code, it is
 difficult to determine how classes and methods
 contribute to the runtime behavior of features.
 Moreover, dependencies between system features are
 not obvious, consequently software maintenance
 operations often result in unintended side effects.
 To tackle these problems, we propose a compact
 feature-driven approach (\ie summarized trace
 information) based on dynamic analysis to
 characterize features and computational units of an
 application. We extract execution traces to achieve
 an explicit mapping between features and classes
 using two complementary perspectives. We apply our
 approach to two case studies and we report our
 findings.},
  acceptnum = {33},
  accepttotal = {81},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  cvs = {TraceScraperRevEng},
  keywords = {scg-pub kzDynamicInformation recast05 stefPub Feature Feature-Traces Dynamic Analysis Evolution moose},
  location = {Manchester, United Kingdom},
  rate = {41\%}}

@inproceedings{Gree05c,
  author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
  title = {Analyzing Feature Traces to Incorporate the Semantics of Change in Software Evolution Analysis},
  booktitle = {Proceedings of 21st IEEE International Conference on Software Maintenance (ICSM'05)},
  pages = {347--356},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05cTraceScraperICSM2005.pdf},
  misc = {acceptance rate: 55/180 = 31\%},
  doi = {10.1109/ICSM.2005.22},
  abstract = {Many of the approaches that analyze software
 evolution consider a static perspective of a system.
 Static analysis approaches focus on the evolution of
 static software entities such as packages, classes
 and methods. Without knowledge of the roles software
 entities play in system features, it is difficult to
 interpret the motivation behind changes and
 extensions in the code. To tackle this problem, we
 propose an approach to software evolution analysis
 that exploits the relationships between features and
 software entities. Our definition of a feature is a
 unit of observable behavior of a software system. We
 define history measurements that summarize the
 evolution of software entities from a feature
 perspective. We show how we use our feature
 perspective of software evolution to interpret
 modifications and extensions to the code. We apply
 our approach on two case studies and discuss our
 findings.},
  acceptnum = {55},
  accepttotal = {180},
  address = {Los Alamitos},
  annote = {internationalconference},
  keywords = {scg-pub stefPub Features Feature-Traces Dynamic-Analysis Evolution history moose recast06 listic kzDynamicInformation},
  month = sep,
  rate = {31\%}}

@article{Gree06b,
  author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
  title = {Analyzing Software Evolution through Feature Views},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {18},
  pages = {425--456},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree06bTraceScraperJSME-SCG.pdf},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.340},
  abstract = {Features encapsulate the domain knowledge of a
 software system and thus are valuable sources of
 information for a reverse engineer. When analyzing
 the evolution of a system, we need to know how and
 which features were modified to recover both the
 change intention and its extent, namely which source
 artifacts are affected. Typically, the
 implementation of a feature crosscuts a number of
 source artifacts. To obtain a mapping between
 features to the source artifacts, we exercise the
 features and capture their execution traces. However
 this results in large traces that are difficult to
 interpret. To tackle this issue we compact the
 traces into simple sets of source artifacts that
 participate in a feature's runtime behavior. We
 refer to these compacted traces as feature views.
 Within a feature view, we partition the source
 artifacts into disjoint sets of characterized
 software entities. The characterization defines the
 level of participation of a source entity in the
 features. We then analyze the features over several
 versions of a system and we plot their evolution to
 reveal how and hich features were affected by
 changes in the code. We show the usefulness of our
 approach by applying it to a case study where we
 address the problem of merging parallel development
 tracks of the same system.},
  annote = {internationaljournal},
  keywords = {scg-pub recast07 stefPub girba dynamic-analysis feature evolution moose kzDynamicInformation},
  number = {6}}

@inproceedings{Gree07a,
  author = {Orla Greevy and Tudor G\^irba and St\'ephane Ducasse},
  title = {How Developers Develop Features},
  booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR 2007)},
  pages = {256--274},
  publisher = {IEEE Computer Society},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree07aDevelopersDevelopFeatures.pdf},
  misc = {Acceptance rate: 38/132=29\%},
  doi = {10.1109/CSMR.2007.27},
  abstract = {Software systems are typically developed by teams of
 developers, with responsibilities for different
 parts of the code. Knowledge of how the developers
 collaborate, and how their responsibilities are
 distributed over the software artifacts is a
 valuable source of information when reverse
 engineering a system. Determining which developers
 are responsible for which software artifacts (\eg
 packages or classes) is just one perspective. In
 this paper we complement the static perspective with
 the dynamic perspective of a system in terms of its
 features. We want to extract information about which
 developers are responsible for which features. To
 achieve these two perspectives, we correlate
 developer responsibilities both with a structural
 view of the system and with a feature view. We
 identify which developers are responsible for which
 features, and whether the responsibilities
 correspond with structural source code artifacts or
 with features. We apply our technique to two
 software projects developed by two teams of students
 as part of their course work, and to one large open
 source project.},
  acceptnum = {38},
  accepttotal = {132},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  cvs = {TraceScraperCSMR2007},
  isbn = {0-7695-2802-3},
  issn = {1534-5351},
  keywords = {scg-pub greevy stefPub moose authors features evolution dynamic-analysis girba kzDynamicInformation},
  medium = {2},
  rate = {29\%}}

@inproceedings{Nier05b,
  author = {Oscar Nierstrasz and Alexandre Bergel and Marcus Denker and St\'ephane Ducasse and Markus Gaelli and Roel Wuyts},
  title = {On the Revival of Dynamic Languages},
  booktitle = {Proceedings of Software Composition 2005},
  volume = {3628},
  pages = {1--13},
  publisher = {LNCS 3628},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05b-SC05-Revival.pdf},
  doi = {10.1007/11550679\_1},
  abstract = {The programming languages of today are stuck in a
 deep rut that has developed over the past 50 years.
 Although we are faced with new challenges posed by
 enormous advances in hardware and internet
 technology, we continue to struggle with
 old-fashioned languages based on rigid, static,
 closed-world file-based views of programming. We
 argue the need for a new class of dynamic languages
 that support a view of programming as constant
 evolution of living and open software models. Such
 languages would require features such as dynamic
 first-class namespaces, explicit meta-models,
 optional, pluggable type systems, and incremental
 compilation of running software systems.},
  annote = {invited},
  editor = {Thomas Gschwind and Uwe A{\ss}mann},
  isbn = {3-540-28748-5},
  keywords = {scg-pub kzLanguageDesign},
  note = {Invited paper}}

@inproceedings{Nier02a,
  author = {Oscar Nierstrasz and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Roel Wuyts and Andrew Black and Peter M{\"u}ller and Christian Zeidler and Thomas Genssler and Reinier van den Born},
  title = {A Component Model for Field Devices},
  booktitle = {Proceedings First International IFIP/ACM Working Conference on Component Deployment},
  pages = {200--209},
  publisher = {ACM},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier02aPecosModel.pdf},
  abstract = {Component-based software development is becoming
 mainstream for conventional applications. However,
 components can be difficult to deploy in embedded
 systems because of non-functional requirements.
 Pecos is a collaborative project between industrial
 and research partners that seeks to enable
 component-based technology for a class of embedded
 systems known as field devices. In this paper we
 introduce a component model for field devices that
 captures a range of non-functional properties and
 constraints. We report on the current status of
 Pecos, including the Pecos composition language,
 language mappings to {Java} and C\+\+, and industrial
 case studies.},
  address = {Berlin, Germany},
  annote = {internationalconference},
  keywords = {scg-pub skip-doi jb02 pecos stefPub arevalo kzComponent},
  month = jun}

@article{Nier06a,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
  title = {Flattening {Traits}},
  journal = {Journal of Object Technology},
  volume = {5},
  pages = {129--148},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier06aFlatteningTraits.pdf},
  misc = {May-June},
  abstract = {Traits are fine-grained components that can be used
 to compose classes, while avoiding many of the
 problems of multiple inheritance and mixin-based
 approaches. Since most implementations of traits
 have focused on dynamically-typed languages, the
 question naturally arises, how can one best
 introduce traits to statically-typed languages, like
 {Java} and C#? In this paper we argue that the
 flattening property of traits should be used as a
 guiding principle for any attempt to add traits to
 statically-typed languages. This property
 essentially states that, semantically, traits can be
 compiled away. We demonstrate how this principle
 applies to FTJ, a conservative extension to
 Featherweight {Java}.},
  annote = {internationaljournal},
  cached = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier06aFlatteningTraits.pdf},
  keywords = {scg-pub skip-doi scg-rotor traits jot stefPub kzTrait},
  medium = {2},
  month = may,
  number = {4}}

@inproceedings{Nier05d,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
  title = {Object-oriented Reengineering Patterns --- an Overview},
  booktitle = {Proceedings of Generative Programming and Component Engineering (GPCE 2005)},
  pages = {1--9},
  publisher = {LNCS 3676},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05dReengineeringPatterns.pdf},
  doi = {10.1007/11561347\_1},
  abstract = {Successful software systems must be prepared to
 evolve or they will die. Although object-oriented
 software systems are built to last, over time they
 degrade as much as any legacy software system. As a
 consequence, one must invest in reengineering
 efforts to keep further development costs down. Even
 though software systems and their business contexts
 may differ in countless ways, the techniques one
 uses to understand, analyze and transform these
 systems tend to be very similar. As a consequence,
 one may identify various reengineering patterns that
 capture best practice in reverse- and re-engineering
 object-oriented legacy systems. We present a brief
 outline of a large collection of these patterns that
 have been mined over several years of experience
 with object-oriented legacy systems, and we indicate
 how some of these patterns can be supported by
 appropriate tools.},
  annote = {invited},
  editor = {Robert Gl\"uck, Michael Lowry},
  isbn = {3-540-29138-5},
  keywords = {stefPub recast06 scg-pub jb06 kzPattern},
  note = {Invited paper}}

@article{Nier05f,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
  title = {Objektorientierte Re-Engineering-Muster: ein \"{U}berblick},
  journal = {ObjektSpektrum},
  volume = {2005},
  pages = {46--51},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05fOORM.pdf},
  abstract = {Erfolgreiche Softwaresysteme m\"ussen so konzipiert
 sein, dass sie sich weiterentwickeln k\"onnen ---
 ansonsten gehen sie ein. Obwohl objektorientierte
 Softwaresysteme auf eine lange Lebensda\"ur
 ausgerichtet sind, veralten sie \"uber die Jahre
 genauso wie jedes andere Legacy-Softwaresystem. Um
 die weiteren Entwicklungskosten niedrig zu halten,
 m\"ussen daher Investitionen im Bereich \
 Re-Engineering get\"atigt werden. Softwaresysteme
 und der Gesch\"aftskontext, in dem sie eingesetzt
 werden, unterscheiden sich in vielen Punkten ---
 dennoch \"ahneln sich Techniken, sie zu verstehen,
 zu analysieren und zu transformieren. Folglich
 lassen sich verschiedene Re-Engineering-Muster
 identifizieren, die bew\"ahrte Vorgehensweisen beim
 Reverse- und Re-Engineering objektorientierter
 Legacy-Systeme beinhalten. Dieser Artikel stellt
 einen kleinen Ausschnitt aus einer gr\"on Sammlung
 dieser Muster vor, die auf der mehrj\"ahrigen
 Erfahrung mit objektorientierten Legacy-Systemen
 basieren. Dar\"uber hinaus werden Hinweise gegeben,
 wie einige dieser Muster durch geeignete Werkzeuge
 unterst\"utzt werden k\"onnen.},
  annote = {invited},
  keywords = {stefPub recast06 scg-pub skip-doi kzPattern},
  note = {German translation of ``Object-oriented Reengineering Patterns --- an Overview'' (GPCE 05)},
  number = {6}}

@inproceedings{Nier05c,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Tudor G\^irba},
  title = {The Story of {Moose}: an Agile Reengineering Environment},
  booktitle = {Proceedings of the European Software Engineering Conference},
  pages = {1--10},
  publisher = {ACM Press},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05cStoryOfMoose.pdf},
  doi = {10.1145/1095430.1081707},
  abstract = {Moose is a language-independent environment for
 reverse- and re-engineering complex software
 systems. Moose provides a set of services including
 a common meta-model, metrics evaluation and
 visualization, a model repository, and generic GUI
 support for querying, browsing and grouping. The
 development effort invested in Moose has paid off in
 precisely those research activities that benefit
 from applying a combination of complementary
 techniques. We describe how Moose has evolved over
 the years, we draw a number of lessons learned from
 our experience, and we outline the present and
 future of Moose.},
  address = {New York NY},
  annote = {invited},
  editor = {Michel Wermelinger and Harald Gall},
  isbn = {1-59593-014-0},
  keywords = {girba stefPub recast06 scg-pub moose kzMoose kzTools},
  note = {Invited paper},
  series = {ESEC/FSE'05}}

@article{Teso17b,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Dynamic Software Update from Development to Production},
  journal = {Journal of Object Technology},
  publisher = {AITO - Association Internationale pour les Technologies Objets},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso17b-JOT-DynamicUpdate.pdf},
  doi = {10.5381/jot.2018.17.1.a2},
  annote = {internationaljournal},
  abstract = {Dynamic Software Update (DSU) solutions update applications while they are executing. These solutions are typically used in production to minimize application downtime, or in integrated development environments to provide live programming support. Each of these scenarios presents different challenges, forcing existing solutions to be designed with only one of these use cases in mind. For example, DSUs for live programming typically do not implement safe point detection or instance migration, while production DSUs require manual generation of patches and lack IDE integration. Also, these solutions have limited ability to update themselves or the language core libraries, and some of them present execution penalties outside the update window. We propose a DSU (gDSU) that works for both live programming and production environments. Our solution implements safe update point detection using call stack manipulation and a reusable instance migration mechanism to minimize manual intervention in patch generation. Moreover, it also offers updates of core language libraries and the update mechanism itself. This is achieved by the incremental copy of the modified objects and an atomic commit operation. We show that our solution does not affect the global performance of the application and it presents only a run-time penalty during the update window. Our solution is able to apply an update impacting 100,000 instances in 1 second. In this 1 second, only during 250 milliseconds the application is not responsive. The rest of the time the application runs normally while gDSU is looking for the safe update point. The update only requires to copy the elements that are modified.},
  keywords = {pharo lse-pub},
  hal-id = {hal-01920362}}

@article{Teso20a,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Preserving Instance State during Refactorings in Live Environments},
  journal = {Future Generation Computer Systems},
  publisher = {Elsevier},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso20a-FutureGeneration-PreservingInstance.pdf},
  annote = {internationaljournal},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02541754/file/main.pdf},
  keywords = {pharo lse-pub kzLanguageDesign}}

@article{Teso20b,
  author = {Pablo Tesone and St\'ephane Ducasse and Guillermo Polito and Luc Fabresse and Noury Bouraqadi},
  title = {A new modular implementation for Stateful Traits},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso20b-SCP-StatefulTraits.pdf},
  annote = {internationaljournal},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02541842/file/main.pdf},
  keywords = {pharo lse-pub kzLanguageDesign}}

@article{Papo15b,
  author = {Papoulias, Nick and Bouraqadi, N. and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Mercury: Properties and Design of a Remote Debugging Solution using Reflection},
  journal = {Journal of Object Technology},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo15b-Mercury-JOT.pdf},
  url = {https://hal.inria.fr/hal-01185730},
  hal-id = {hal-01185730},
  annote = {internationaljournal},
  abstract = {Remote debugging facilities are a technical necessity for devices that lack appropriate input/output interfaces (display, keyboard, mouse) for program- ming (e.g., smartphones, mobile robots) or are simply unreachable for local development (e.g., cloud-servers). Yet remote debugging solutions can prove awkward to use due to re-deployments. Empirical studies show us that on aver- age 10.5 minutes per coding hour (over five 40-hour work weeks per year) are spent for re-deploying applications (including re-deployments during debugging). Moreover current solutions lack facilities that would otherwise be available in a local setting because it is difficult to reproduce them remotely. Our work identifies three desirable properties that a remote debugging solution should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a remote debugging model based on reflection. Mercury supports run-time evolution through a causally connected remote meta-level, semantic instrumentation through the reification of the underlying execution environment and adaptable distribution through a modular architecture of the debugging middleware.},
  keywords = {kzReflection stefpub}}

@inproceedings{Papo15a,
  author = {Papoulias, Nick and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Reifying the Reflectogram},
  booktitle = {{30th ACM/SIGAPP Symposium On Applied Computing}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo15a-ACM-SAC-Reflectogram.pdf},
  doi = {10.1145/2695664.2695883},
  address = {Salamanca, Spain},
  hal-id = {hal-01098596},
  annote = {internationalconference},
  keywords = {Reflectogram ; Explicit Control ; Reflection ; Intercession kzReflection StefPub},
  month = {apr},
  abstract = {Reflective facilities in OO languages are used both for implementing language extensions (such as AOP frameworks) and for support- ing new programming tools and methodologies (such as object- centric debugging and message-based profiling). Yet controlling the run-time behavior of these reflective facilities introduces several challenges, such as computational overhead, the possibility of meta- recursion and an unclean separation of concerns between base and meta-level. In this paper we present five dimensions of meta-level control from related literature that try to remedy these problems. These dimensions are namely: temporal and spatial control, place- ment control, level control and identity control. We argue that the reification of the descriptive notion of the reflectogram, can unify the control of meta-level execution in all these five dimensions. We present a model for the reification of the reflectogram and validate our approach through a prototype implementation in the Pharo pro- gramming environment. Finally we detail a case-study on run-time tracing illustrating our approach.}}

@inproceedings{Papo11a,
  author = {Papoulias, Nikolaos and Bouraqadi, Noury and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Towards Structural Decomposition of Reflection with Mirrors},
  booktitle = {{Proceedings of International Workshop on Smalltalk Technologies (IWST'11)}},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo11a-StructuralDecomposition.pdf},
  url = {http://hal.inria.fr/inria-00629175/en/},
  abstract = {Mirrors are meta-level entities introduced to decouple reflection from the base-level system. Current mirror-based systems focus on functional decomposition of reflection. In this paper we advocate that mirrors should also address structural decomposition. Mirrors should not only be the entry points of reflective behavior but also be the storage entities of meta-information. This decomposition can help resolve issues in terms of resource constraints (e.g. embedded systems and robotics) or security. Indeed, structural decomposition en- ables discarding meta-information.},
  address = {Edingburgh, United Kingdom},
  annote = {internationalworkshop},
  hal-id = {inria-00629175},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzReflection}}

@misc{Rapi98a,
  author = {Pascal Rapicault and Mireille Blay-Fornarino and St\'ephane Ducasse and Anne-Marie Dery},
  title = {Dynamic Type Inference to Support Object-Oriented Reengineering in Smalltalk},
  pages = {76--77},
  year = {1998},
  pdf = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf},
  abstract = {Type information is a crucial information to support
 object-oriented reengineering. In a dynamically
 typed language like Smalltalk standard static type
 inference is a complex and heavily computational
 task. In this paper, we report how we use message
 passing control and compiler extension to support
 dynamic inference type in Smalltalk.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi famoosstefPub kzEvolution},
  note = {Proceedings of the ECOOP '98 International Workshop Experiences in Object-Oriented Reengineering, abstract in Object-Oriented Technology (ECOOP '98 Workshop Reader forthcoming LNCS)}}

@inproceedings{Pass14a,
  author = {Passerini, Nicol\'{a}s and Tesone, Pablo and Ducasse, St\'ephane},
  title = {An extensible constraint-based type inference algorithm for object-oriented dynamic languages supporting blocks and generic types},
  booktitle = {International Workshop on Smalltalk Technologies (IWST 14)},
  year = {2014},
  month = aug,
  annote = {internationalworkshop},
  keywords = {kzLanguageDesign kzPharo}}

@inproceedings{Lian02a,
  author = {Peng Liang and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Michele Lanza and Nathanael Sch{\"a}rli and Roel Wuyts and Oscar Nierstrasz},
  title = {Applying RMA for Scheduling Field Device Components},
  booktitle = {ECOOP 2002 Workshop Reader},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lian02aPecosRMA.pdf},
  abstract = {PECOS is a collaborative project between industrial and research partners that seeks to enable component-based technology for a class of embedded systems known as "field devices". Results so far include a component model for field devices and a composition language for specifying connections between software components. Here we investigate the application of Rate Monotonic Analysis (RMA) to the
 problem of generating real-time schedules for compositions of field device components.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi pecos stefPub arevalo schaerli kzComponent}}

@inproceedings{Moug03a,
  author = {Philippe Mougin and St\'ephane Ducasse},
  title = {{OOPAL}: Integrating Array Programming in Object-Oriented Programming},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  pages = {65--77},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Moug03aOOPALOOPSLA.pdf},
  misc = {acceptance rate: 26/142 = 18\%},
  doi = {10.1145/949305.949312},
  abstract = {Array programming shines in its ability to express
 computations at a high-level of abstraction,
 allowing one to manipulate and query whole sets of
 data at once. This paper presents the OPA model that
 enhances object-oriented programming with array
 programming features. The goal of OPA is to
 determine a minimum set of modifications that must
 be made to the traditional object model in order to
 take advantage of the possibilities of array
 programming. It is based on a minimal extension of
 method invocation and the definition of a kernel of
 methods implementing fundamental array programming
 operations. The OPA model presents a generalization
 of traditional message passing in the sense that a
 message can be send to an entire set of objects. The
 model is validated in FS, a new scripting language.},
  acceptnum = {26},
  accepttotal = {142},
  annote = {internationalconference topconference},
  keywords = {snf04 scg-pub jb04 stefPub kzMessaging kzLanguageDesign},
  month = oct}

@inproceedings{Poli14b,
  author = {Polito, Guillermo and Bouraqadi, Noury and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Understanding Pharo\'s global state to move programs through time and space},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 22th International Smalltalk Conference - 2014},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14b-IWST-GlobalStateClassification.pdf},
  abstract = {Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application\'s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around code resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo\'s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-01070964},
  keywords = {lse-pub globalstate stefpub kzEvolution kzPharo}}

@inproceedings{Poli13a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {Virtual Smalltalk Images: Model and Applications},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 21th International Smalltalk Conference - 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli13a-IWST13-ObjectSpacesVirtualization.pdf},
  abstract = {Reflective architectures are a powerful solution for code browsing, debugging or in-language process handling. However, these reflective architectures show some limitations in edge cases of self-modification and self-monitoring. Modifying the modifier process or monitoring the monitor process in a reflective system alters the system itself, leading to the impossibility to perform some of those tasks properly. In this paper we analyze the problems of reflective architectures in the context of image based object-oriented languages and solve them by providing a first-class representation of an image: a virtualized image.
We present Oz, our virtual image solution. In Oz, a virtual image is represented by an object space. Through an object space, an image can manipulate the internal structure and control the execution of other images. An Oz object space allows one to introspect and modify execution information such as processes, contexts, existing classes and objects. We show how Oz solves the edge cases of reflective architectures by adding a third participant, and thus, removing the self modification and self-observation constraints.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-00924932},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection StefPub}}

@inproceedings{Poli15a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {A Bootstrapping Infrastructure to Build and Extend Pharo-Like Languages},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf},
  abstract = {Bootstrapping is well known in the context of compilers, where a bootstrapped compiler can compile its own source code. Bootstrapping is a beneficial engineering practice because it raises the level of abstraction of a program making it easier to understand, optimize, evolve, etc. Bootstrapping a reflective object-oriented language is however more challenging, as we need also to initialize the runtime of the language with its initial objects and classes besides writing its compiler.
In this paper, we present a novel bootstrapping infrastructure for Pharo-like languages that allows us to easily extend and modify such languages. Our bootstrapping process relies on a first-class runtime. A first-class runtime is a meta-object that represents a program's runtime and provides a MOP to easily load code into it and manipulate its objects. It decouples the virtual machine (VM) and language concerns by introducing a clear VM-language interface. Using this process, we show how we succeeded to bootstrap a Smalltalk-based language named Candle and then extend it with traits in less than 250 lines of high-level Smalltalk code. We also show how we can bootstrap with minimal effort two other languages (Pharo and MetaTalk) with similar execution semantics but different object models.},
  annote = {internationalconference},
  hal-id = {hal-01185812},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf}}

@inproceedings{Poli15b,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and Mattone, Max},
  title = {Virtualization Support for Dynamic Core Library Update},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf},
  abstract = {Dynamically updating language runtime and core libraries such as collections and threading is challenging since the update mechanism uses such libraries at the same time that it modifies them. To tackle this challenge, we present Dy- namic Core Library Update (DCU) as an extension of Dy- namic Software Update (DSU) and our approach based on a virtualization architecture. Our solution supports the up- date of core libraries as any other normal library, avoiding the circular dependencies between the updater and the core libraries. Our benchmarks show that there is no evident per- formance overhead in comparison with a default execution. Finally, we show that our approach can be applied to real life scenario by introducing a critical update inside a web application with 20 simulated concurrent users.},
  annote = {internationalconference},
  hal-id = {hal-01185819},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf}}

@article{Poli14c,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and van Ryseghem, Benjamin},
  title = {Bootstrapping Reflective Systems: The Case of Pharo},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14c-BootstrappingASmalltalk-ScienceOfComputerProgramming.pdf},
  abstract = {Bootstrapping is a technique commonly known by its usage in language definition by the introduction of a compiler written in the same language it compiles.
	This process is important to understand and modify the definition of a given language using the same language, taking benefit of the abstractions and expression power it provides. A bootstrap, then, supports the evolution of a language. However, the infrastructure of reflective systems like Smalltalk includes, in addition to a compiler, an environment with several self-references. A reflective system bootstrap should consider all its infrastructural components.
	In this paper, we propose a definition of bootstrap for object-oriented reflective systems, we describe the architecture and components it should contain and we analyze the challenges it has to overcome. Finally, we present a reference bootstrap process for a reflective system and Hazelnut, its implementation for bootstrapping the Pharo Smalltalk-inspired system.},
  annote = {internationaljournal},
  hal-id = {hal-00903724},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection stefpub}}

@inproceedings{Poll07a,
  author = {Pollet, Damien and Ducasse, St\'ephane and Poyet, Lo\"{\i}c and Alloui, Ilham and C\^impan, Sorana and Verjus, Herv\'e},
  title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
  booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
  publisher = {IEEE Computer Society},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll07a-CSMRSARTaxonomy.pdf},
  misc = {Acceptance rate: 38/132=29\%},
  abstract = {To maintain and understand large applications, it is
 crucial to know their architecture. The first
 problem is that unlike classes and packages,
 architecture is not explicitly represented in the
 code. The second problem is that successful
 applications evolve over time, so their architecture
 inevitably drifts. Reconstructing the architecture
 and checking whether it is still valid is therefore
 an important aid. While there is a plethora of
 approaches and techniques supporting architecture
 reconstruction, there is no comprehensive state of
 the art and it is often difficult to compare the
 approaches. This article presents a state of the art
 on software architecture reconstruction approaches.},
  acceptnum = {38},
  accepttotal = {132},
  annote = {internationalconference},
  editor = {Krikhaar, Ren\'e and Verhoef, Chris and Di Lucca, Giuseppe},
  hal-id = {hal-00849009},
  keywords = {recast kzArchi},
  location = {Amsterdam, the Netherlands},
  month = mar,
  note = {Best Paper Award},
  rate = {29\%}}

@inproceedings{Rizu15a,
  author = {Rizun, Markiyan and Bach, Jean-Christophe and Ducasse, St\'ephane},
  title = {Code Transformation by Direct Transformation of ASTs},
  booktitle = {International Workshop on Smalltalk Technologies},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rizu15a-CodeTransformation.pdf},
  annote = {internationalworkshop},
  keywords = {kzInfrastructure kzTools kzEvolution},
  hal = {http://hal.inria.fr/inria-01319677},
  hal-id = {hal-01319677}}

@inproceedings{Wuyt04x,
  author = {Roel Wuyts and Serge Demeyer and St\'ephane Ducasse and Kim Mens},
  title = {Report of the {ECOOP}'04 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'04 Workshop Reader},
  volume = {3344},
  pages = {177--186},
  publisher = {Springer-Verlag},
  year = {2004},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt04x-OOR04Report.pdf},
  doi = {10.1007/b104146},
  abstract = {This paper reports on the results of the Fifth
 International Workshop on Object-Oriented
 Reengineering in Oslo on June 15, 2004. It
 enumerates the presentations made, classifies the
 contributions and lists the main results of the
 discussions held at the workshop. As such it
 provides the context for future workshops around
 this topic.},
  annote = {workshopproceedings},
  isbn = {978-3-540-23988-8},
  keywords = {scg-pub stefPub recast04 kzEditor},
  series = {LNCS}}

@inproceedings{Wuyt07a,
  author = {Roel Wuyts and Serge Demeyer and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Kim Mens and St\'ephane Ducasse},
  title = {Report of the 7th ECOOP'06 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'06 Workshop Reader},
  pages = {69--71},
  publisher = {Springer-Verlag},
  year = {2007},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt07-WoorWorkshop.pdf},
  annote = {workshopproceedings},
  keywords = {stefPub kzEditor},
  series = {LNCS}}

@article{Wuyt04a,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Unanticipated Integration of Development Tools using the Classification Model},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {30},
  pages = {63--77},
  publisher = {Elsevier},
  year = {2004},
  impactfactor = {Impact factor (2010) 0.541},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt04aClassifications.pdf},
  doi = {10.1016/j.cl.2003.08.003},
  abstract = {The increasing complexity of software development
 spawns lots of specialised tools to edit code,
 employ UML schemes, integrate documentation, and so
 on. The problem is that the tool builders themselves
 are responsible for making their tools interoperable
 with other tools or development environments.
 Because they cannot anticipate all other tools they
 can integrate with, a lot of tools cannot
 co-operate. This paper introduces the classication
 model, a lightweight integration medium that enables
 unrelated tools that were not meant to be integrated
 to cooperate easily. Moreover, the tool integration
 is done by a tool integrator, and not by the tool
 builder. To validate this claim, we show how to
 integrate several third-party tools using the
 classication model, and how it forms the foundation
 for the StarBrowser, a Smalltalk browser integrating
 different tools.},
  annote = {internationaljournal},
  keywords = {stefPub kzIDE},
  number = {1-2}}

@inproceedings{Wuyt01c,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Composition Languages for Black-Box Components},
  booktitle = {First OOPSLA Workshop on Language Mechanisms for Programming Software Components},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01c.pdf},
  abstract = {Supporting reuse of existing pieces of code is one
 of the main goals of software engineering. In the
 name of reuse, module-based programming languages
 came to be, only to be surpassed by object-oriented
 technology. With the same motivation component-based
 solutions are overtaking object-oriented solutions.
 However, the delegation-only focus of
 component-based programming risks of resulting in
 the same problems that modular-based approaches ran
 into. To counter this, we claim that one of th e
 important problems that should be addressed by
 component languages is the composition of
 components. More specifically, we see component
 languages where components are black-box
 abstractions, and with (one or more) composition
 languages to glue them tog ether. As an example we
 show a functional (Piccola) and a logic (QSoul)
 composition approach.},
  annote = {internationalworkshop},
  keywords = {component kzComponents kzLanguageDesign Pecos stefPub}}

@inproceedings{Wuyt01a,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Symbiotic Reflection between an Object-Oriented and a Logic Programming Language},
  booktitle = {ECOOP 2001 International Workshop on MultiParadigm Programming with Object-Oriented Languages},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01a.pdf},
  abstract = {Meta-programming is the act of using one system or
 language to reason about another one. Reflection
 describes systems that have access to and change a
 causally connected representation of themselves,
 hence leading to self-extensible systems . Up to
 now, most of the reflective languages have been
 implemented in the same paradigm. In this paper, we
 propose \emph{symbiotic reflection} as a way to
 integrate a meta programming language with the
 object-oriented language it reasons about and is
 implemented in. New to this approach is that any
 element of the implementation language can be
 reasoned about and acted upon (not only the self
 representation), and that both languages are of
 different paradigms. Moreover, every language
 implementer that is faced with the problem of
 allowing the base language to access the underlying
 meta-language has to solve the problem of enabling
 entity transfer between both worlds. We propose a
 uniform schema, called upping/downing, to this
 problem that avoid explicit wrapping or
 typechecking. We illustrate this with SOUL (the
 Smalltalk Open Unification Language), a logic
 programming language in symbiotic reflection with
 the object-oriented language Smalltalk. We show how
 SOUL does logic reasoning directly on Smalltalk
 objects, and how to use this to implement type
 snooping},
  annote = {internationalworkshop},
  keywords = {stefPub kzReflection}}

@inproceedings{Wuyt01e,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Non-Functional Requirements in a Component Model for Embedded Systems},
  booktitle = {International Workshop on Specification and Verification of Component-Based Systems},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01e.pdf},
  abstract = {In this paper we describe an interesting context to
 study formal methods for component systems: embedded
 devices. The context of embedded devices is highly
 constrained by the physical requirements the devices
 have to adhere to. As a result, component models for
 embedded devices are not general purpose but geared
 towards these constrained contexts. In this paper we
 give the concrete setting of the Pecos project (a
 project with as goal component engineering for
 embedded devices). We describe the Pecos component
 model, and show possibilities where we think formal
 verification could be useful. We would like to use
 this as a very concrete example to discuss formal
 verification techniques.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi snf01 jb01 component Pecos stefPub kzComponent kzLanguageDesign}}

@inproceedings{Wuyt01d,
  author = {Roel Wuyts and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
  title = {Applying Experiences with Declarative Codifications of Software Architectures on COD},
  booktitle = {Ecoop 6th International Workshop on Component-Oriented Programming},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01d.pdf},
  abstract = {This position paper presents some preliminary work
 we made for applying declarative component oriented
 design in the context of embedded devices. We
 quickly describes COMES the model we develop and
 present how logic rules can be used to describe
 architectures.},
  annote = {internationalworkshop},
  keywords = {component Pecos stefPub arevalo kzComponent kzArchi kzChecking}}

@article{Wuyt05a,
  author = {Roel Wuyts and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {A Data-centric Approach to Composing Embedded, Real-time Software Components},
  journal = {Journal of Systems and Software --- Special Issue on Automated Component-Based Software Engineering},
  volume = {74},
  pages = {25--34},
  publisher = {Elsevier},
  year = {2005},
  misc = {SCI impact factor 0.744},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt05aPecosElsevier.pdf},
  doi = {10.1016/j.jss.2003.05.004},
  abstract = {Software for embedded systems must cope with a variety of stringent constraints, such as real-time requirements, small memory footprints, and low power consumption. It is usually implemented using low-level programming languages, and as a result has not benefitted from component-based software development techniques. This paper describes a \emph{data-centric component model} for embedded devices that (i) minimizes the number of concurrent tasks needed to implement the system, (ii) allows one to verify whether components meet their deadlines by applying Rate Monotonic Analysis (RMA), and (iii) can generate and verify schedules using Constraint Logic Programming (CLP). This model forms the foundation for a suite of tools for specifying, composing, verifying and deploying embedded software components developed in the context of the \pecos project.},
  annote = {internationaljournal},
  keywords = {scg-pub jb03 pecos stefPub kzComponent kzLanguageDesign},
  number = {1}}

@inproceedings{Bert03a,
  author = {Roland Bertuli and St\'ephane Ducasse and Michele Lanza},
  title = {Run-Time Information Visualization for Understanding Object-Oriented Systems},
  booktitle = {Proceedings of 4th International Workshop on Object-Oriented Reengineering (WOOR'03)},
  pages = {10--19},
  publisher = {University of Antwerp},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bert03aEcoop-Workshop.pdf},
  abstract = {Understanding object-oriented legacy systems is a complex task exacerbated by the presence of late binding and polymorphism. Moreover, the metaphor of message sending and the anthropomorphism promoted by object-oriented languages makes it difficult to statically identify the precise role the objects play at run-time. We propose a lightweight visualization approach enriched with run-time information which allows us to identify precise aspects of the objects lifetime such as the role played in the creation of other objects and the communication architecture they support. Our approach not only supports the run-time understanding of an application but also allows one to evaluate test understanding and test coverage.},
  annote = {internationalworkshop},
  keywords = {stefPub moose kzVisualization kzDynamicInformation},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bert03aEcoopWorkshop.pdf}}

@inproceedings{Robb05b,
  author = {Romain Robbes and St\'ephane Ducasse and Michele Lanza},
  title = {Microprints: A Pixel-based Semantically Rich Visualization of Methods},
  booktitle = {Proceedings of 13th International Smalltalk Conference},
  pages = {131--157},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Robb05b-microprintsESUG.pdf},
  abstract = {Understanding classes and methods is a key activity
 in object-oriented programming, since classes
 represent the primary abstractions from which
 applications are built, while methods contain the
 actual program logic. The main problem of this task
 is to quickly grasp the purpose and inner structure
 of a class. To achieve this goal, one must be able
 to overview multiple methods at once. In this paper,
 we present microprints, pixel-based representations
 of methods enriched with semantical information. We
 present three specialized microprints each dealing
 with a specific aspect we want to understand of
 methods: (1) state access, (2) control flow, and (3)
 invocation relationship. We present the microprints
 in conjunction with the class blueprints of the CODE
 CRAWLER visualization tool [12] and also integrated
 into the default code browser of the Smalltalk
 VisualWorks development environment.},
  annote = {internationalconference},
  keywords = {scg-pub skip-doi stefPub kzVisualization},
  series = {ISC'05}}

@inproceedings{Salg16a,
  author = {Salgado, Ronie and Ducasse, St\'ephane},
  title = {{Lowcode: Extending Pharo with C Types to Improve Performance}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Salg16a-IWST16-Lowcode.pdf},
  doi = {10.1145/2991041.2991064},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353884},
  keywords = {lse-pub stefPub kzLanguageDesign kzVM},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Tich00m,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
  title = {{FAMIX}: Exchange Experiences with {CDIF} and {XMI}},
  booktitle = {Proceedings of the ICSE 2000 Workshop on Standard Exchange Format (WoSEF 2000)},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00mFamixCdifXmi.pdf},
  abstract = {In the FAMOOS project we have developed a set of
 tools for reengineering object-oriented legacy
 systems. These tools are based on the FAMIX meta
 model and exchange information using CDIF, an
 industry standard exchange format. For several
 reasons XMI, an emerging standard for information
 exchange, has appealed to us to be used as our
 interchange format. In this paper we discuss why XMI
 is interesting for us and what, to our current
 experience, are the advantages and disadvantages of
 XMI over CDIF.},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub moose kzTools},
  month = jun}

@inproceedings{Tich00n,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
  title = {{FAMIX} and {XMI}},
  booktitle = {Proceedings WCRE 2000 Workshop on Exchange Formats},
  pages = {296--296},
  publisher = {IEEE Computer Society Press},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00nFamixWCRE2000.pdf},
  doi = {10.1109/WCRE.2000.891485},
  abstract = {Recently exchange formats have gained lots of
 attention. Multiple tools need to interact and/or
 work on the same software system. Especially there
 is a need to reuse parser technology. Within the
 FAMOOS project we have developed a model for
 representing object-oriented software systems at the
 program entity level. The model has been designed
 for language independence, extensibility and
 information exchange. For the actual exchange of
 data we are currently moving to use XMI, a standard
 for model-based information exchange.},
  address = {Los Alamitos CA},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub moose kzMeta kzTools},
  month = nov}

@inproceedings{Tich00b,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {A Meta-model for Language-Independent Refactoring},
  booktitle = {Proceedings of International Symposium on Principles of Software Evolution},
  pages = {157--167},
  publisher = {IEEE Computer Society Press},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00bRefactoringMetamodel.pdf},
  misc = {acceptance rate: 22/51 = 43\%},
  doi = {10.1109/ISPSE.2000.913233},
  abstract = {Refactoring --- transforming code while preserving
 behaviour --- is currently considered a key approach
 for improving object-oriented software systems.
 Unfortunately, all of the current refactoring tools
 depend on language-dependent refactoring engines,
 which prevents a smooth integration with mainstream
 development environments. In this paper we
 investigate the similarities between refactorings
 for Smalltalk and {Java}, derive a
 language-independent meta-model and show that it is
 feasible to build a language-independent refactoring
 engine on top of this meta-model. Our feasibility
 study is validated by means of a tool prototype
 which uses the same engine to refactor both
 Smalltalk and {Java} code. Using our approach we
 minimize the language-dependent part of refactoring
 tools, providing a standard way for programmers and
 tools to perform refactorings no matter what
 language they work in.},
  acceptnum = {22},
  accepttotal = {51},
  annote = {internationalconference},
  keywords = {reengineering refactoring FAMIX repositories scg-pub stefPub moose kzMeta},
  series = {ISPSE'00}}

@inproceedings{Tich97b,
  author = {Sander Tichelaar and St\'ephane Ducasse and Theo-Dirk Meijler},
  title = {Architectural Extraction In Reverse Engineering by Prototyping: An experiment},
  booktitle = {Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering},
  publisher = {Technical University of Vienna, Information Systems Institute, Distributed Systems Group},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich97bArchExtraction.pdf},
  abstract = {In this workshop proposal we present a prototype
 approach to help the extraction of architectural
 information in the re-engineering process. Commonly,
 the re-engineering life-cycle has been defined as a
 succession of the following tasks: analysis of
 requirements, model capture (understanding the
 system), problem detection, problem analysis,
 reorganization and change propagation. We have
 evaluated the benefit of a prototyping approach with
 a focus on model capture. Although prototyping is a
 known approach to evaluate the application
 feasibility, costs, comparison and validation of
 choices, we focus in this paper on the aspects of
 prototyping that are helpful for re-engineering.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Harald Gall},
  keywords = {stefPub scg-pub kzArchitecture},
  month = sep,
  note = {Technical Report TUV-1841-97-10}}

@inproceedings{Sand13a,
  author = {Sandoval Alcocer, Juan Pablo and Alexandre Bergel and St\'ephane Ducasse and Marcus Denker},
  title = {Performance Evolution Blueprint: Understanding the Impact of Software Evolution on Performance},
  booktitle = {Vissoft 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sand13a-Vissoft-PreformanceBlueprint.pdf},
  abstract = {Understanding the root of a performance drop or improvement requires analyzing different program executions at a fine grain level. Such an analysis involves dedicated profiling and representation techniques. JProfiler and YourKit, two recognized code profilers fail, on both providing adequate metrics and visual representations, conveying a false sense of the performance variation root.
	We propose performance evolution blueprint, a visual support to precisely compare multiple software executions. Our blueprint is offered by Rizel, a code profiler to efficiently explore performance of a set of benchmarks against multiple software revisions.},
  annote = {internationalconference},
  hal-id = {hal-00849004},
  keywords = {pharo stefPub lse-pub kzVisualization}}

@inproceedings{Brag18a,
  author = {Santiago Bragagnolo and Henrique Rocha and Marcus Denker and  St\'ephane Ducasse},
  title = {SmartInspect: solidity smart contract inspector},
  booktitle = {2018 International Workshop on Blockchain Oriented Software Engineering (IWBOSE)},
  pages = {9-18},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Braga18a-IWBOSE-SmartInspect.pdf},
  doi = {10.1109/IWBOSE.2018.8327566},
  annote = {internationalworkshop},
  abstract = {Solidity is a language used for smart contracts on the Ethereum blockchain. Smart contracts are embedded procedures stored with the data they act upon. Debugging smart contracts is a really difficult task since once deployed, the code cannot be reexecuted and inspecting a simple attribute is not easily possible because data is encoded. In this paper, we address the lack of inspectability of a deployed contract by analyzing contract state using decompilation techniques driven by the contract structure definition. Our solution, SmartInspect, also uses a mirror-based architecture to represent locally object responsible for the interpretation of the contract state. SmartInspect allows contract developers to better visualize and understand the contract stored state without needing to redeploy, nor develop any ad-hoc code.},
  keywords = {Contracts;Debugging;Indexes;Inspection;Tools;Blockchain;Inspecting;Smart Contracts;Solidity; lse-pub kzBlockchain},
  hal-id = {inria-01831075},
  month = {mar},
  note = {Electronic ISBN: 978-1-5386-5986-1}}

@inproceedings{Brag18b,
  author = {Santiago Bragagnolo and Henrique Rocha and Marcus Denker and  St\'ephane Ducasse},
  title = {Ethereum Query Language},
  booktitle = {1st International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
  pages = {1-8},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Braga18b-WETSEB-Query.pdf},
  doi = {10.1145/3194113.3194114},
  annote = {internationalworkshop},
  abstract = {Blockchains store a massive amount of heterogeneous data which
will only grow in time. When searching for data on the Ethereum
platform, one is required to either access the records (blocks) directly
by using a unique identifier, or sequentially search several
records to find the desired information. Therefore, we propose
the Ethereum Query Language (EQL), a query language that allows
users to retrieve information from the blockchain by writing
SQL-like queries. The queries provide a rich syntax to specify data
elements to search information scattered through several records.
We claim that EQL makes it easier to search, acquire, format, and
present information from the blockchain.},
  hal-id = {inria-01831084},
  keywords = {Ethereum;Blockchain;Query Language;SQL; lse-pub kzBlockchain},
  month = {may}}

@inproceedings{Brag20a,
  author = {Santiago Bragagnolo and Nicolas Anquetil and St\'ephane Ducasse and
	 Seriai Abderrahmane and Mustapha Derras},
  title = {Analysing Microsoft Access Projects: Building a model in a Partially Observable Domain},
  booktitle = {International Conference on Software and Systems Reuse, ICSR2020},
  year = {2020},
  annote = {internationalconference},
  keywords = {kzEvolution},
  month = dec}

@misc{Gonz04a,
  author = {Sebastian Gonzales and Wolgang Demeuter and Pascal Costanza and St\'ephane Ducasse and Richard Gabriel and Theo D'hondt},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
  booktitle = {Object-Oriented Technology (ECOOP'04 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Gonz04a-oolepje04-report.pdf},
  abstract = {This report covers the activities of the 2nd
 workshop on "Object-Oriented Language Engineering
 for the Post-Java Era". We describe the motivation
 that led to the organisation of a second edition of
 the workshop. Relevant organisational aspects are
 mentioned. The main part of the report consists of a
 summary of Dave Thomas's invited talk, and a recount
 of the presentations by the authors of position
 papers. Comments given along the way by the
 participants are included. Finally, some pointers to
 related work and events are given.},
  annote = {workshopproceedings},
  keywords = {scg-pub skip-doi jb04 stefPub recast04 kzEditor},
  series = {LNCS}}

@inproceedings{Deme05a,
  author = {Serge Demeyer and Filip Van Rysselberghe and Tudor G\^irba and Jacek Ratzinger and Radu Marinescu and Tom Mens and Bart Du Bois and Dirk Janssens and St\'ephane Ducasse and Michele Lanza and Matthias Rieger and Harald Gall and Michel Wermelinger and Mohammad El-Ramly},
  title = {The {LAN}-simulation: A Research and Teaching Example for Refactoring},
  booktitle = {Proceedings of IWPSE 2005 (8th International Workshop on Principles of Software Evolution)},
  pages = {123--131},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme05a-LANRefactoring.pdf},
  misc = {acceptance rate: 13/54=24\%},
  doi = {10.1109/IWPSE.2005.30},
  abstract = {The notion of refactoring --- transforming the source-code of an object-oriented program without changing its external behaviour --- has been studied intensively within the last decade. This diversity has created a plethora of toy-examples, cases and code snippets, which make it hard to assess the current state-of-the-art.	Moreover, due to this diversity, there is currently no accepted way of teaching good refactoring practices, despite the acknowledgment in the software engineering body of knowledge. Therefore, this paper presents a common example --- the LAN simulation --- which has been used by a number of European Universities for both research and teaching purposes.},
  acceptnum = {13},
  accepttotal = {54},
  address = {Los Alamitos CA},
  annote = {internationalworkshop},
  inri = {hors},
  keywords = {kzEvolution},
  location = {Lisbon, Portugal},
  rate = {24\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme05aLANRefactoring.pdf}}

@inproceedings{Deme06a,
  author = {Serge Demeyer and Kim Mens and Roel Wuyts and Yann-Ga\"el Gu\'{e}h\'{e}neuc and Andy Zaidman and Neil Walkinshaw and Ademar Aguiar and St\'ephane Ducasse},
  title = {Report of the 6th ECOOP'05 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'05 Workshop Reader},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Deme06a-ECOOP2006-WOOR.pdf},
  annote = {workshopproceedings},
  keywords = {scg-pub skip-abstract skip-doi stefPub kzEditor}}

@inproceedings{Deme99a,
  author = {Serge Demeyer and St\'ephane Ducasse},
  title = {Metrics, Do They Really Help?},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO'99)},
  pages = {69--82},
  publisher = {HERMES Science Publications, Paris},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99a-LMO99-DemeyerDucasse.pdf},
  abstract = {Maturing a well designed framework requires a set of software metrics to steer the iterative development process. Based on a case study of the VisualWorks/Smalltalk framework for user-interface building, we conclude that today's size and inheritance metrics are not reliable to detect problems but are useful in measuring stability. We expect that this work will contribute to the application of metrics as a project management tool.},
  annote = {nationalconference},
  editor = {Jacques Malenfant},
  keywords = {famoos scg-pub skip-doi oorp stefPub moose kzMetric},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99aDemeyerDucasseLMO99.pdf}}

@inproceedings{Deme98n,
  author = {Serge Demeyer and St\'ephane Ducasse},
  title = {Do Metrics Support Framework Development?},
  booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
  volume = {1543},
  pages = {247--249},
  publisher = {Springer-Verlag},
  year = {1998},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {famoos scg-pub skip-pdf skip-abstract skip-doi metrics stefPub kzEditor},
  series = {LNCS}}

@inproceedings{Deme03a,
  author = {Serge Demeyer and St\'ephane Ducasse and Kim Mens and Adrian Trifu and Rajesh Vasa},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  pages = {72-85},
  publisher = {Springer-Verlag},
  year = {2003},
  annote = {workshopproceedings},
  keywords = {kzEditor},
  series = {LNCS}}

@inproceedings{Deme99c,
  author = {Serge Demeyer and St\'ephane Ducasse and Michele Lanza},
  title = {A Hybrid Reverse Engineering Platform Combining Metrics and Program Visualization},
  booktitle = {Proceedings of Working Conference on Reverse Engineering (WCRE'99)},
  publisher = {IEEE Computer Society},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99c-WCRE-CodeCrawler.pdf},
  doi = {10.1109/WCRE.1999.806958},
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Consequently, reverse engineering techniques are relevant in an object-oriented context as well. This paper investigates a hybrid approach, combining the immediate appeal of visualisations with the scalability of metrics. We validate such a hybrid approach by showing how CodeCrawler ---the experimental platform we built--- allowed us to understand the program structure of, and identify potential design anomalies in a public domain software system.},
  annote = {internationalconference},
  editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {famoos scg-pub oorp stefPub moose kzVisualization},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99cCodeCrawler.pdf}}

@book{Deme02a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Object-Oriented Reengineering Patterns},
  pages = {360},
  publisher = {Morgan Kaufmann},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/OORP.pdf},
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems. This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  isbn = {1-55860-639-4},
  keywords = {kzBook},
  web = {http://www.iam.unibe.ch/~scg/OORP}}

@inproceedings{Deme00a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Finding Refactorings via Change Metrics},
  booktitle = {Proceedings of 15th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '00)},
  pages = {166--178},
  publisher = {ACM Press},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00a-OOPSLA00-FindingRefactoring.pdf},
  misc = {acceptance rate: 26/142 = 18\%, SCI impact factor 0.190, ranked 66/77},
  doi = {10.1145/353171.353183},
  abstract = {Reverse engineering is the process of uncovering the design and the design rationale from a functioning software system. Reverse engineering is an integral part of any successful software system, because changing requirements lead to implementations that drift from their original design. In contrast to traditional reverse engineering techniques -which analyse a single snapshot of a system- we focus the reverse engineering effort by determining where the implementation has changed. Since changes of object-oriented software are often phrased in terms of refactorings, we propose a set of heuristics for detecting refactorings by applying lightweight, object-oriented metrics to successive versions of a software system. We validate our approach with three separate case studies of mature object-oriented software systems for which multiple versions are available. The case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system.},
  acceptnum = {26},
  accepttotal = {142},
  address = {New York NY},
  annote = {internationalconference topconference},
  keywords = {olit scg-pub jb00 snf00 oorp stefPub moose kzMetric kzEvolution},
  note = {Also in ACM SIGPLAN Notices 35 (10)},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00aFindingRefactoring.pdf}}

@inproceedings{Deme00d,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {A Pattern Language for Reverse Engineering},
  booktitle = {Proceedings of EuroPLoP '00},
  pages = {189--208},
  publisher = {UVK GmbH},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00d-RevEng.pdf},
  abstract = {Since object-oriented programming is usually associated with iterative development, reverse engineering must be considered an essential facet of the object-oriented paradigm. The reverse engineering pattern language presented here summarises the reverse engineering experience gathered as part of the FAMOOS project, a project with the explicit goal of investigating reverse and reengineering techniques in an object-oriented context. Due to limitations on EuroPLOP submissions, only part of the full pattern language is presented, namely the patterns describing how to gain an initial understanding of a software system.},
  annote = {internationalworkshop},
  isbn = {3-87940-775-4},
  keywords = {snf-none stefPub scg-pub skip-doi jb00 kzMetric},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00dRevEng.pdf}}

@book{Deme08a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Object-Oriented Reengineering Patterns},
  publisher = {Square Bracket Associates},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/OORP.pdf},
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems.	This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  isbn = {978-3-9523341-2-6},
  keywords = {scg-pub skip-doi stefPub moose kzBook},
  medium = {2},
  peerreview = {no},
  web = {http://scg.unibe.ch/download/oorp/}}

@inproceedings{Deme99n,
  author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
  title = {A Pattern Language for Reverse Engineering},
  booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing},
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99n-Europlop99.pdf},
  abstract = {This pattern language describes how to reverse engineer an object-oriented software system. Since the only way to achieve a truly reusable object-oriented design is recognised to be iterative development, reverse engineering is indeed an essential facet of any object-oriented development process. The pattern language itself covers the different phases one encounters when reverse engineering a large software system: from being unfamiliar with a software system up untill preparations for actual reengineering. What you read here is a short version of a complete pattern language. We present only five patterns in full detail and include a summary for the remaining patterns.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi stefPub kzPattern},
  month = jul,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99nEuroplop99.pdf}}

@inproceedings{Deme99d,
  author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
  title = {Why Unified is not Universal. {UML} Shortcomings for Coping with Round-trip Engineering},
  booktitle = {Proceedings of the International Conference on The Unified Modeling Language (UML'99)},
  volume = {1723},
  pages = {630--644},
  publisher = {Springer-Verlag},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99d-UML99.pdf},
  misc = {acceptance rate: 44/166 = 26\%, SCI impact 0.515, ranked 39/69},
  abstract = {UML is currently embraced as "the" standard in object-oriented modeling languages, the recent work of OMG on the Meta Object Faci lity (MOF) being the most noteworthy example. We welcome these standardisation efforts, yet warn against the tendency to use UML as the panacea for all exchange standards. In particular, we argue that UML is not sufficient to serve as a tool-interoperability standard for integrating round-trip engineering tools, because one is forced to rely on UML's built-in extension mechanisms to a dequately model the reality in source-code. Meanwhile, our argumentation includes a number of constructive suggestions that we ho pe will influence future releases of the UML and MOF standards.},
  acceptnum = {44},
  accepttotal = {166},
  address = {Kaiserslautern, Germany},
  annote = {internationalconference},
  editor = {Bernhard Rumpe},
  keywords = {famoos-papref scg-pub skip-doi stefPub moose kzMeta},
  month = oct,
  series = {LNCS},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99dUML99.pdf}}

@misc{Stin06a,
  author = {Serge Stinckwich and St\'ephane Ducasse},
  title = {Les structures de contr\^ole en Smalltalk},
  journal = {Linux Pratique},
  volume = 1,
  pages = {18--23},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jan,
  number = 33}

@misc{Stin05a,
  author = {Serge Stinckwich and St\'ephane Ducasse},
  title = {La syntaxe Smalltalk},
  journal = {Linux Pratique},
  volume = 1,
  pages = {18--23},
  year = {2005},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 32}

@inproceedings{Alli12a,
  author = {Simon Allier and Nicolas Anquetil and Andre Hora and St\'ephane Ducasse},
  title = {A Framework to Compare Alert Ranking Algorithms},
  booktitle = {Proceedings of the 19th International Working Conference on Reverse Engineering (WCRE'12)},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Alli12a-wcre2012-ComparisonOfAlertsRankingAlgorithms.pdf},
  misc = {Acceptance rate: 43/138 = 31\%},
  annote = {internationalconference},
  hal-id = {hal-00747817},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00747817},
  keywords = {lse-pub StefPub kzChecking},
  tagnicolasa = {analysis}}

@inproceedings{Deni09b,
  author = {Simon Denier and Damien Pollet and St\'ephane Ducasse},
  title = {Proposals for the Reborn Pharo Developer},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'09)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deni09b-IWST09-PharoBrowsers.pdf},
  abstract = {Smalltalk was at the birth of current IDEs. Current Smalltalk
IDEs, however, lost their abilities to adapt to developer needs
(edit and jump, back button, auto-completion,...). Therefore
while offering a powerful sets of tools current Smalltalk
IDEs looks clunky and often lacks the application of a consistent set of guidelines. In this paper we sketch some possible IDEs future features or reorganization.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {hal-00746260},
  keywords = {lse-pub pharo-pub kzIDE}}

@inproceedings{Kale17a,
  author = {Sophie Kaleba and Cl\'ement B\'era and Alexandre Bergel and St\'ephane Ducasse},
  title = {A detailed VM profiler for the Cog VM},
  booktitle = {International Workshop on Smalltalk Technology {IWST'17}},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kale17a-IWST-VMProfiler.pdf},
  url = {https://hal.inria.fr/hal-01585754},
  annote = {internationalworkshop},
  abstract = {Code profiling enables a user to know where in an application or function the execution time is spent. The Pharo ecosystem offers several code profilers. However, most of the publicly available profilers (MessageTally, Spy, GadgetPro-filer) largely ignore the activity carried out by the virtual machine , thus incurring inaccuracy in the gathered information and missing important information, such as the Just-in-time compiler activity. This paper describes the motivations and the latest improvements carried out in VMProfiler, a code execution pro-filer hooked into the virtual machine, that performs its analysis by monitoring the virtual machine execution. These improvements address some limitations related to assessing the activity of native functions (resulting from a Just-in-time compiler operation): as of now, VMProfiler provides more detailed profiling reports, showing for native code functions in which bytecode range the execution time is spent.},
  address = {Maribor, Slovenia},
  month = sep,
  keywords = {lse-pub kzInfrastructure},
  hal-id = {hal-01585754}}

@inproceedings{Kale18a,
  author = {Sophie Kaleba and Cl\'ement B\'era and St\'ephane Ducasse},
  title = {Assessing primitives performance on multi-stage execution},
  booktitle = {International Workshop on Smalltalk Technology {IWST'18}},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kabe18a-VMStringOptimisation.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01874947},
  annote = {internationalworkshop},
  abstract = {Virtual machines, besides the interpreter and just-in-time compiler optimization facilities, also include a set of primitive operations that the client language can use. Some of these are essential and cannot be performed in any other way. Others are optional: they can be expressed in the client language but are often implemented in the virtual machine to improve performance when the just-in-time compiler is unable to do so (start-up performance, speculative optimizations not implemented or not mature enough, etc.). In a hybrid runtime, where code is executed by an interpreter and a just-in-time compiler, the implementor can choose to implement optional primitives in the client language , in the virtual machine implementation language (typically C or C++), or on top of the just-in-time compiler back-end. This raises the question of the maintenance and performance trade-offs of the different alternatives. As a case study, we implemented the String comparison optional primitive in each case. This paper describes the different implementations , discusses the maintenance cost of each of them and evaluates for different string sizes the execution time in Cog, a Smalltalk virtual machine.},
  keywords = {kzInfrastructure lse-pub}}

@article{Duca99a,
  author = {St\'ephane Ducasse},
  title = {Evaluating Message Passing Control Techniques in {Smalltalk}},
  journal = {Journal of Object-Oriented Programming (JOOP)},
  volume = {12},
  pages = {39--44},
  publisher = {SIGS Press},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99aMsgPassingControl.pdf},
  impactfactor = {Impact factor 0.306},
  abstract = {In a language like Smalltalk in which objects communicate only via message passing, message passing control is a fundamental tool for the analysis of object behavior (trace, spying) or for the definition of new semantics (asynchronous messages, proxy,...). Different techniques exist, from the well known approach based on the specialization of the doesNotUnderstand: method to the exploitation the method lookup algorithm done by the virtual machine. Until now no comparison between these techniques has been made. In this article we compare the different techniques taking into account the reflective aspects used, the scope, the limit and the cost of the control.},
  annote = {internationaljournal},
  keywords = {scg-pub skip-doi stefPub kzReflection},
  month = jun,
  number = {6}}

@book{Duca19b,
  author = {St\'ephane Ducasse},
  title = {Pharo with Style},
  pages = {46},
  publisher = {Square Bracket Associates},
  year = {2019},
  url = {http://books.pharo.org},
  hal-id = {hal-02299550}}

@phdthesis{Duca97a,
  author = {St\'ephane Ducasse},
  title = {Int\'egration r\'eflexive de d\'ependances dans un mod\`ele \`a classes},
  school = {Universit\'e de Nice-Sophia Antipolis},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97aPhD.pdf},
  annote = {phdthesis},
  keywords = {stefPub flo kzDependency},
  month = jan,
  note = {Th\`ese de l'Universit\'e de Nice-Sophia Antipolis}}

@article{Duca03x,
  author = {St\'ephane Ducasse},
  title = {Seaside: Des applications web complexes simplement...},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation kzWeb},
  month = apr,
  number = 52}

@article{Duca97e,
  author = {St\'ephane Ducasse},
  title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet},
  volume = {3},
  pages = {355--377},
  publisher = {Hermes, Paris},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97eMessagePassing.pdf},
  annote = {nationaljournal},
  keywords = {scg-pub skip-abstract skip-doi stefPub flo kzReflection},
  number = {4}}

@inproceedings{Duca97c,
  author = {St\'ephane Ducasse},
  title = {Message Passing Abstractions as Elementary Bricks for Design Pattern Implementation},
  booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
  volume = {1357},
  pages = {96--99},
  publisher = {Springer-Verlag},
  year = {1997},
  annote = {internationalworkshop},
  editor = {Jan Bosch and Stuart Mitchell},
  keywords = {scg-pub flo stefPub kzDependency kzReflection},
  month = jun,
  series = {LNCS}}

@article{Duca03z,
  author = {St\'ephane Ducasse},
  title = {Espionnage en Squeak},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = feb,
  number = 50}

@article{Duca02w,
  author = {St\'ephane Ducasse},
  title = {SUnit: Ces tests que souvent l'on deteste},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2002},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jan,
  number = 39}

@inproceedings{Duca97d,
  author = {St\'ephane Ducasse},
  title = {R\'eification de Sch\'emas de Conception: Une Exp\'erience},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'97)},
  pages = {95--110},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97dReificationDP.ps.gz},
  annote = {nationalconference},
  keywords = {scg-pub skip-doi skip-abstract stefPub flo kzDependency}}

@book{Duca05j,
  author = {St\'ephane Ducasse},
  title = {Squeak: Learn Programming with Robots},
  publisher = {APress},
  year = {2005},
  annote = {book},
  keywords = {stefPub scg-pub kzVulgarisation kzBook},
  note = {ISBN: 1-59059-491-6}}

@article{Duca01u,
  author = {St\'ephane Ducasse},
  title = {Squeak: Syntaxe par l'example},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 35}

@booklet{Duca18c,
  author = {St\'ephane Ducasse},
  title = {A Simple Reflective Object Kernel},
  pages = {40},
  publisher = {Square Bracket Associates},
  collection = {The Pharo TextBook Collection},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-ReflectiveCore.pdf},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  keywords = {lse-pub kzVulgarisation},
  hal-id = {hal-01900323}}

@article{Duca01t,
  author = {St\'ephane Ducasse},
  title = {Squeak: Classes},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = oct,
  number = 36}

@article{Duca01v,
  author = {St\'ephane Ducasse},
  title = {Squeak: Une syntaxe minimaliste},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jul,
  number = 34}

@article{Duca01w,
  author = {St\'ephane Ducasse},
  title = {Squeak: Un smalltalk open-source d\'etonnant},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jun,
  number = 33}

@article{Duca02v,
  author = {St\'ephane Ducasse},
  title = {Refactoring Browser et SmallLint},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2002},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 46}

@inproceedings{Duca95c,
  author = {St\'ephane Ducasse},
  title = {Inheritance Mechanism Reification by Means of First Class Object},
  booktitle = {Proceedings of the International IJCAI'95 Workshop on Reflection and Meta-Level Architectures and their Applications in AI},
  pages = {39--49},
  year = {1995},
  annote = {internationalworkshop},
  institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
  keywords = {flo kzDependency},
  note = {RR-95-12}}

@article{Duca03y,
  author = {St\'ephane Ducasse},
  title = {Squeak: R\'eflexion pour Prototyper},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 51}

@article{Duca03w,
  author = {St\'ephane Ducasse},
  title = {Seaside: Des composants pour le web},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation kzWeb},
  month = may,
  number = 53}

@inproceedings{Duca04e,
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  title = {Seaside --- a Multiple Control Flow Web Application Framework},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  pages = {231--257},
  year = {2004},
  misc = {Also Technical Report IAM-04-008},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04eSeaside.pdf},
  abstract = {Developing web applications is difficult since (1) the client-server relationship is asymmetric: the server cannot update clients but only responds to client requests and (2) the navigation facilities of web browsers lead to a situation where servers cannot control the state of the clients. Page-centric web application frameworks fail to offer adequate solutions to model control flow at a high-level of abstraction. Developers have to work manually around the shortcomings of the HTTP protocol. Some approaches offer better abstractions by composing an application out of components, however they still fail to offer modeling control flow at a high level. Continuation-based approaches solve this problem by providing the facilities to model a control flow over several pages with one piece of code. However combining multiple flows inside the same page is difficult. This article presents Seaside. Seaside is a framework which combines an object-oriented approach with a continuation-based one. A Seaside application is built out of components (i.e., objects) and the logic of the application benefits from the continuation-based program flow infrastructure. Seaside offers a unique way to have multiple control flows on a page, one for each component. This enables the developer to write components that are highly reusable and that can be used to compose complex web applications with higher quality in less time.},
  annote = {internationalconference},
  cvs = {seaside},
  keywords = {scg-pub skip-doi stefPub seaside kzWeb},
  month = sep}

@article{Duca07a,
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  title = {Seaside: A Flexible Environment for Building Dynamic Web Applications},
  journal = {IEEE Software},
  volume = {24},
  pages = {56--63},
  publisher = {IEEE Computer Society},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07a-IEEESoftware-Seaside.pdf},
  impactfactor = {5-year ISI impact factor (2010) 2.551},
  doi = {10.1109/MS.2007.144},
  abstract = {Nowadays, many complex applications are built with a web browser as their main user interface. However, despite the increasing popularity of the web as an application platform, implementing and maintaining web applications still remains difficult and lags behind conventional desktop application development.	The underlying technologies such as HTTP for the interaction and XHTML/CSS for the presentation were originally built to display and link static documents. Unfortunately, most mainstream frameworks provide only little abstraction over the page-oriented structure imposed by those technologies. Inevitably, the goto-like manner of how pages are linked leads to spaghetti code and hampers reuse. In this article we present Seaside, a web application framework that provides an uniform and pure object-oriented view on web applications.	In this way, Seaside avoids the unwieldily goto-like style. Exploiting the reflective features of Smalltalk, Seaside reintroduces procedure call abstraction in the client-server context. Seaside's key concepts are: (i) a component architecture supporting multiple, simultaneously active control flows, (ii) a programmatic XHTML generation, and (iii) fully supported on-the-fly debugging, code-editing, and recompilation. In this article we discuss these key features of Seaside and explain how they are made possible by the dynamic nature and the reflective capabilities of Smalltalk.},
  address = {Los Alamitos, CA, USA},
  annote = {internationaljournal},
  issn = {0740-7459},
  keywords = {scg-pub seaside kzWeb},
  number = {5}}

@misc{Duca10t,
  author = {St\'ephane Ducasse and Alexandre Bergel},
  title = {Exceptions en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  year = {2008},
  annote = {vulgarisation},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub pharo kzVulgarisation},
  month = nov,
  number = 110}

@incollection{Bera13c,
  author = {St\'ephane Ducasse and Cl\'ement Bera},
  title = {Blocks: a Detailed Analysis},
  booktitle = {Deep Into Pharo},
  pages = 25,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  isbn = {978-3-9523341-6-4},
  annote = {articlebook},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming	kzLanguageDesign kzPharo},
  month = sep}

@book{Duca17b,
  author = {St\'ephane Ducasse and Damien Pollet},
  title = {Learning Object-Oriented Programming, Design and TDD with Pharo},
  pages = {250},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {book},
  keywords = {skipdoi kzSmalltalk lse-pub kzPharo},
  hal-id = {hal-01612687}}

@inproceedings{Duca07c,
  author = {St\'ephane Ducasse and Damien Pollet and Mathieu Suen and Hani Abdeen and Ilham Alloui},
  title = {Package Surface Blueprints: Visually Supporting the Understanding of Package Relationships},
  booktitle = {ICSM'07: Proceedings of the IEEE International Conference on Software Maintenance},
  pages = {94--103},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07cPackageBlueprintICSM2007.pdf},
  misc = {acceptance rate: 46/214 = 21\%},
  abstract = {Large object-oriented applications are structured over large number of packages. Packages are important but complex structural entities that may be difficult to understand since they play different development roles (i.e., class containers, code ownership basic structure, architectural elements...). Maintainers of large applications face the problem of understanding how packages are structured in general and how they relate to each others. In this paper, we present a compact visualization, named Package Surface Blueprint, that qualifies the relationships that a package has with its neighbours. A Package Surface Blueprint represents packages around the notion of package surfaces: groups of relationships according to the packages they refer to. We present two specific views one stressing the references made by a package and another showing the inheritance structure of a package. We applied the visualization on two large case studies: ArgoUML and Squeak.},
  acceptnum = {46},
  accepttotal = {214},
  annote = {internationalconference stefPub},
  keywords = {moose kzCycle kzVisualization},
  rate = {21\%}}

@book{Duca17a,
  author = {St\'ephane Ducasse and Dmitri Zagidulin and Nicolai Hess and Dimitris Chloupis --- Originally written by A. Black and S. Ducasse and O. Nierstrasz and D. Pollet with D. Cassou and M. Denker},
  title = {Pharo by Example 5},
  pages = {376},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  annote = {book},
  isbn = {978-3-9523341-0-2},
  keywords = {skipdoi kzSmalltalk kzPharo lse-pub}}

@booklet{Duca18d,
  author = {St\'ephane Ducasse and Guillermo Polito},
  title = {Physche: A Little Scheme in Pharo},
  pages = {50},
  publisher = {Square Bracket Associates},
  collection = {The Pharo TextBook Collection},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-08-28-Physche.pdf},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  keywords = {kzSmalltalk lse-pub kzVulgarisation},
  hal-id = {hal-01900327}}

@misc{Duca07z,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Tests unitaires en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2007},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = may,
  number = 94}

@misc{Duca06e,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {La syntaxe Smalltalk par la pratique},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = may,
  number = 83}

@misc{Duca05k,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Squeak: un Smalltalk libre multim\'edia},
  journal = {Linux Pratique},
  volume = {1},
  pages = {18--23},
  year = {2005},
  aeresstastus = {2008},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 89}

@misc{Duca07y,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Smalltalk et design patterns, un couple assorti},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2007},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 92}

@misc{Duca98z,
  author = {St\'ephane Ducasse and Joachim Weisbrod},
  title = {Report of the {ECOOP}'98 Workshop on Experiences in Object-Oriented Re-Engineering},
  booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
  pages = {72--96},
  publisher = {Springer-Verlag},
  year = {1998},
  annote = {workshopproceedings},
  keywords = {skip-pdf scg-pub skip-abstract skip-doi jb-none stefPub kzPattern},
  number = 1543,
  series = {LNCS}}

@book{Duca10a,
  author = {St\'ephane Ducasse and Lukas Renggli and C. David Shaffer and Rick Zaccone and Michael Davies},
  title = {Dynamic Web Development with Seaside},
  pages = {371},
  publisher = {Square Bracket Associates},
  year = {2010},
  url = {http://book.seaside.st/book},
  abstract = {Seaside is the open source framework of choice for developing sophisticated and dynamic web applications. Seaside uses the power of objects to master the web. With Seaside web applications is as simple as building desktop applications. Seaside lets you build highly dynamic and interactive web applications. Seaside supports agile development through interactive debugging and unit testing.	Seaside is based on Smalltalk, a proven and robust language implemented by different vendors. Seaside is now available for all the major Smalltalk including Pharo, Squeak, GNU Smalltalk, Cincom Smalltalk, GemStone Smalltalk, and VA Smalltalk.},
  annote = {book},
  hal-id = {inria-00531503},
  inriareport = {2010},
  isbn = {978-3-9523341-1-9},
  keywords = {skipdoi remoose2-pub pharo-pub pharo kzWeb}}

@inproceedings{Duca05h,
  author = {St\'ephane Ducasse and Lukas Renggli and Roel Wuyts},
  title = {{SmallWiki} --- A Meta-Described Collaborative Content Management System},
  booktitle = {Proceedings ACM International Symposium on Wikis (WikiSym'05)},
  pages = {75--82},
  publisher = {ACM Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05hSmallwikiWikiSymp05.pdf},
  doi = {10.1145/1104973.1104981},
  abstract = {Wikis are often implemented using string-based approaches to parse and generate their pages. While such approaches work well for simple wikis, they hamper the customization and adaptability of wikis to the variety of end-users when more sophisticated needs are required (i.e., different output formats, user-interfaces, wiki managment, security policies, ...). In this paper we present SmallWiki, the second version of a fully object-oriented implementation of a wiki. SmallWiki is implemented with objects from the top to the bottom and it can be customized easily to accommodate new needs. In addition, SmallWiki is based on a powerful meta-description called Magritte that allows one to create user-interface elements declaratively.},
  address = {New York, NY, USA},
  annote = {internationalconference},
  cvs = {SmallWikiTwoOOPSLASymp2005},
  keywords = {scg-pub snf-none stefPub kzOut}}

@inproceedings{Duca98c,
  author = {St\'ephane Ducasse and Manuel G{\"u}nter},
  title = {Coordination of Active Objects by Means of Explicit Connectors},
  booktitle = {Proceedings of the DEXA workshops},
  pages = {572--577},
  publisher = {IEEE Computer Society Press},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca98cExplicitConnectors.pdf},
  abstract = {Although coordination of multiple activities is a fundamental goal of object-oriented concurrent programming languages, there is only limited support for their specification and abstraction at the language level. This leads to a mismatch between conceptional designs, using high-level abstractions, and the implementation, using the low-level coordination constructs. Often coordination is hard-wired into the components they coordinate, which leads to evolution, maintenance and composibility problems. We propose a model called FLO/C that relies on the notion of connectors. A connector is an entity that enforces the coordination of the entities it coordinates. This model supports a clear separation between the coordinated active objects and their coordination.	An active object only defines specific domain information and a connector only defines coordination between a group of active objects (its participants). The coordination is abstractly defined refering to components in terms of the object interface. Coordination and coordinated entities are independant and can evolve separately.	Coordination can be composed and replaced easily.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi flo floc coordination stefPub kzDependency},
  month = aug}

@inproceedings{Duca11a,
  author = {St\'ephane Ducasse and Manuel Oriol and Alexandre Bergel},
  title = {Challenges to support automated random testing for dynamically typed languages},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
  year = {2011},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca11a-IWST11-RandomTesting.pdf},
  abstract = {Automated random testing is a proven way to identify bugs and precondition violations, and this even in well tested libraries.
In the context of statically typed languages, current automated random testing tools heavily take advantage of static method declaration (argument types, thrown exceptions) to constrain input domains while testing and to identify errors. For such reason, automated random testing has not been investigated in the context of dynamically typed languages. In this paper we present the key challenges that have to be addressed to support automated testing in dynamic languages.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614769},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzChecking}}

@inproceedings{Duca99d,
  author = {St\'ephane Ducasse and Matthias Rieger and Georges Golomingi},
  title = {Tool Support for Refactoring Duplicated {OO} Code},
  booktitle = {Proceedings of the ECOOP '99 Workshop on Experiences in Object-Oriented Re-Engineering},
  publisher = {Forschungszentrum Informatik, Karlsruhe},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg99aToolSuppRefacOOCode.pdf},
  abstract = {Code duplication is an important problem in application maintenance. Tools exist that support code duplication detection. However, few of them propose a solution for the problem, i.e.	refactorings. We propose an approach that uses the information given by code duplication detection to guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  editor = {St\'ephane Ducasse and Oliver Ciupke},
  keywords = {olit famoos-papref scg-pub skip-doi jb99 stefPub kzDuplication},
  month = jun,
  note = {FZI-Report 2-6-6/99}}

@inproceedings{Duca99b,
  author = {St\'ephane Ducasse and Matthias Rieger and Serge Demeyer},
  title = {A Language Independent Approach for Detecting Duplicated Code},
  booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
  pages = {109--118},
  publisher = {IEEE Computer Society},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99bCodeDuplication.pdf},
  misc = {acceptance rate: 49/100 = 49\%},
  doi = {10.1109/ICSM.1999.792593},
  abstract = {Code duplication is one of the factors that severely complicates the maintenance and evolution of large software systems. Good tools for detecting duplicated code are scarce because of the large amount of data to be checked, because duplicated code is not known a priori and because especially it requires parsing technology. In this paper we show that is possible to circumvent these complicating factors by applying a language independent and lightweigth approach, i.e. a tool that requires no parsing and a little learning and configuration time, yet is able to detect a significant amount of code duplication. We validate our approach on a number of case studies, involving five different implementation languages and ranging from 256 K up untill 26Mb of source code.},
  acceptnum = {49},
  accepttotal = {100},
  annote = {internationalconference},
  editor = {Hongji Yang and Lee White},
  keywords = {scg-pub toBeChecked duploc stefPub moose kzDuplication},
  month = sep}

@inproceedings{Duca04b,
  author = {St\'ephane Ducasse and Michael Freidig and Roel Wuyts},
  title = {Logic and Trace-based Object-Oriented Application Testing},
  booktitle = {Fifth International Workshop on Object-Oriented Reengineering (WOOR 2004)},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04bTestLogicWoor04.pdf},
  abstract = {Due to the size and the extreme complexity of legacy systems, it is nearly impossible to write from scratch tests before refactoring them. In addition object-oriented legacy systems present specific requirements to test them. Indeed late-binding allow subclasses to change fundamental aspects of the superclass code and in particular call flows.	Moreover Object-oriented programming promotes a distribution of the responsibilities to multiple entities leading to complex scenario to be tested.	In such a context one of the few trustable source of information is the execution of the application itself. Traditional forward engineering approaches such as unit testing do not really provide adequate solution to this problem. Therefore there is a need for a more expressive way of testing the execution of object-oriented applications. We propose to represent the trace of object-oriented applications as logic facts and express tests over the trace.	This way complex sequences of message exchanges, sequence matching, or expression of negative information are expressed in compact form. We validated our approach by implementing TestLog a prototype tool and testing the Moose reengineering environment and a meta-interpreter.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi recast04 evolution visualization test stefPub kzDynamicInformation}}

@article{Duca01a,
  author = {St\'ephane Ducasse and Michele Lanza},
  title = {Towards a Methodology for the Understanding of Object-Oriented Systems},
  journal = {Technique et science informatiques},
  volume = {20},
  pages = {539--566},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca01aTowardsAMethod.pdf},
  abstract = {The reverse engineering of object-oriented legacy systems presents a number
of problems typically encountered in large-scale legacy systems: the lack of overview and
the need to focus on interesting parts. To help in reverse engineering large
object-oriented legacy systems, we proposed a hybrid approach combining the immediate
appeal of visualisations with the scalability of metrics. However, our approach lacked of a
methodology that guides the reverse engineer. In this paper we present a first methodology
that we developed from our industrial experiments.},
  annote = {nationaljournal},
  keywords = {scg-pub skip-doi jb01 snf02 stePub kzVisualization},
  number = {4}}

@article{Duca05b,
  author = {St\'ephane Ducasse and Michele Lanza},
  title = {The {Class} {Blueprint}: Visually Supporting the Understanding of Classes},
  journal = {Transactions on Software Engineering (TSE)},
  volume = {31},
  pages = {75--90},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05bTSEClassBlueprint.pdf},
  impactfactor = {5 Year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2005.14},
  abstract = {Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel xvisualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub recast05 mooseCincom moose kzVisualization},
  month = jan,
  number = {1}}

@inproceedings{Duca05e,
  author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
  title = {Butterflies: A Visual Approach to Characterize Packages},
  booktitle = {Proceedings of the 11th IEEE International Software Metrics Symposium (METRICS'05)},
  pages = {70--77},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05e-Metrics-Butterflies-Ponisio.pdf},
  misc = {acceptance rate: 39/89 = 44\%},
  doi = {10.1109/METRICS.2005.15},
  abstract = {Understanding sets of classes, or packages, is an important activity in the
development and reengineering of large object-oriented systems. Packages represent the
coarse-grained structure of an application. They are artefacts to deploy and structure
software, and therefore more than a simple generalization of classes. The relationships
between packages and their contained classes are key in the decomposition of an application
and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a
package and to understand how a package interacts with the rest of the system. We tackle
this problem using butterfly visualizations, i.e. dedicated radar charts built from simple
package metrics based on a language-independent meta-model. We illustrate our approach on
two applications and show how we can retrieve the relevant characteristics of packages.},
  acceptnum = {39},
  accepttotal = {89},
  annote = {internationalconference},
  keywords = {scg-pub stefPub moose recast06 kzMetric},
  rate = {44\%},
  pdf-second = {http://rmod.inria.fr/archive/papers/Duca05ePackageVisualization.pdf}}

@inproceedings{Duca00f,
  author = {St\'ephane Ducasse and Michele Lanza and Lukas Steiger},
  title = {Supporting Evolution Recovery: a Query-based Approach},
  booktitle = {ECOOP 2000 International Workshop of Architecture Evolution},
  year = {2000},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-abstract skip-pdf skip-doi stefPub design-recovery moose kzHistory}}

@inproceedings{Duca04a,
  author = {St\'ephane Ducasse and Michele Lanza and Roland Bertuli},
  title = {High-Level Polymetric Views of Condensed Run-Time Information},
  booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
  pages = {309--318},
  publisher = {IEEE Computer Society Press},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04aRuntimePolymetricViews.pdf},
  misc = {acceptance rate: 33/62 = 52\%},
  doi = {10.1109/CSMR.2004.1281433},
  abstract = {Understanding the run-time behavior of object-oriented legacy systems is a complex task due to factors such as late binding and polymorphism.	Current approaches extract and use information from the complete execution trace of a system. The sheer size and complexity of such traces make their handling, storage, and analysis difficult. Current software systems which run almost non-stop do not permit such a full analysis. In this paper we present a lightweight approach based on the extraction of a condensed amount of information, e.g., measurements, that does not require a full trace. Using this condensed information, we propose a visualization approach which allows us to identify and understand certain aspects of the objects' lifetime such as their role played in the creation of other objects and the communication architecture they support.},
  acceptnum = {33},
  accepttotal = {62},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {recast04 scg-pub stefPub jb04 moose kzVisualisation kzDynamicInformation}}

@inproceedings{Duca05i,
  author = {St\'ephane Ducasse and Michele Lanza and Romain Robbes},
  title = {Multi-level Method Understanding Using {Microprints}},
  booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE International Workshop on Visualizing Software for Understanding)},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05imicroprintsVissoft.pdf},
  abstract = {Understanding classes and methods is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built, while methods contain the actual program logic. The main problem of this task is to quickly grasp the purpose and inner structure of a class. To achieve this goal, one must be able to overview multiple methods at once. In this paper, we present microprints, pixel-based representations of methods enriched with semantical information. We present three specialized microprints each dealing with a specific aspect we want to understand of methods: (1) state access, (2) control flow, and (3) invocation relationship.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub recast06 kzVisualization},
  month = sep}

@inproceedings{Duca99s,
  author = {St\'ephane Ducasse and Michele Lanza and Serge Demeyer},
  title = {Reverse Engineering based on Metrics and Program Visualization},
  booktitle = {Object-Oriented Technology (ECOOP'99 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {1999},
  annote = {internationalworkshop},
  keywords = {scg-pub snf-none skip-pdf jb-skip skip-abstract skip-doi kzVisualization},
  number = {1743},
  series = {LNCS}}

@inproceedings{Duca96b,
  author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
  title = {Object and Dependency Oriented Programming in FLO},
  booktitle = {Proceedings of International Symposium on Methodologies for Intelligent Systems (ISMIS '96)},
  pages = {295--304},
  publisher = {Springer-Verlag},
  year = {1996},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca96bDependencyOP.pdf},
  doi = {10.1007/3-540-61286-6\_154},
  abstract = {The FLO language integrates management of inter-object dependencies into the object oriented paradigms. In this paper, we focus on the use of reactive dependencies (links) in object-oriented knowledge representation. In particular, we present different meta-links (links between links) and show how the FLO links allow one to design some composition relationships.},
  annote = {internationalconference},
  keywords = {flo scg-old scg-pub stefPub kzDependency},
  month = jun,
  number = 1079,
  series = {LNIA (Lectures Notes in Artificial Intelligence)}}

@inproceedings{Duca95b,
  author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
  title = {A Reflective Model for First Class Dependencies},
  booktitle = {Proceedings of 10th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '95)},
  pages = {265--280},
  publisher = {ACM},
  year = {1995},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca95bAReflectiveModel.pdf},
  misc = {acceptance rate: 27/167 = 16\%},
  acceptnum = {27},
  accepttotal = {167},
  annote = {internationalconference topconference},
  keywords = {stefPub flo kzReflection kzDependency kzReflection},
  month = oct}

@inproceedings{Duca93b,
  author = {St\'ephane Ducasse and Mireille Fornarino},
  title = {Protocol for Managing Dependencies between Objects by controlling Generic Function Invocation},
  booktitle = {OOPSLA '93 International Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming},
  year = {1993},
  annote = {internationalworkshop},
  keywords = {stefPub flo kzReflection kzDependency},
  note = {Technical Report, University of Nice-Sophia Antipolis, I3S Lab, RR-94-62},
  organization = {ACM}}

@inproceedings{Duca94a,
  author = {St\'ephane Ducasse and Mireille Fornarino},
  title = {Protocole pour la gestion des d\'ependances entre objets gr\^ace au contr\^ole des fonctions g\'en\'eriques},
  booktitle = {Actes des Journ\'ees Francophones des Langages Applicatifs (JFLA'94)},
  pages = {239--258},
  year = {1994},
  annote = {nationalconference},
  editor = {Pierre Cointe and Christian Queinnec and Bernard Serpette},
  keywords = {stefPub flo kzDependency}}

@article{Duca05g,
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
  title = {Uniform and Safe Metaclass Composition},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {31},
  pages = {143--164},
  publisher = {Elsevier},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05ySafeMetaclassTrait.pdf},
  impactfactor = {Impact factor (2009) 0.619},
  doi = {10.1016/j.cl.2004.11.003},
  abstract = {In pure object-oriented languages, classes are objects, instances of other classes called metaclasses. In the same way as classes define the properties of their instances, metaclasses define the properties of classes. It is therefore very natural to wish to reuse class properties, utilizing them amongst several classes. However this introduced metaclass composition problems, i.e., code fragments applied to one class may break when used on another class due to the inheritance relationship between their respective metaclasses.	Numerous approaches have tried to solve metaclass composition problems, but they always resort to an ad-hoc manner of handling conflicting properties, alienating the meta-programmer. We propose a uniform approach that represents class properties as traits, groups of methods that act as a unit of reuse from which classes are composed. Like all the other classes in the system, metaclasses are composed out of traits. This solution supports the reuse of class properties, and their safe and automatic composition based on explicit conflict resolution. The paper discusses traits and our solution, shows concrete examples implemented in the Smalltalk environment Squeak, and compares our approach with existing models for composing class properties.},
  aeresstastus = {2008},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub kzReflection},
  month = dec,
  number = {3-4}}

@inproceedings{Duca03b,
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
  title = {Open Surfaces for Controlled Visibility},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03bSurfaces.pdf},
  abstract = {Current languages contain visibility mechanisms such as private, protected, or public to control who can see what. However, these visibility mechanisms are fixed once for all. Moreover, they do not solve all problems related to the visibility, and are typically of a static nature. In this position paper we present an open and uniform way of dealing with visibility and introduce surfaces: i.e., list of methods that control the way the behavior of an ob ject is accessible. We introduce two problems that other visibility mechanisms cannot solve, and show how surfaces can.},
  annote = {internationalworkshop},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub schaerli kzLanguageDesign},
  month = jul}

@article{Duca06i,
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Matthias Rieger},
  title = {On the Effectiveness of Clone Detection by String Matching},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {18},
  pages = {37--58},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06iDuplocJSMEPaper.pdf},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.317},
  abstract = {Although duplicated code is known to pose severe problems for software maintenance, it is difficult to identify in large systems. Many different techniques have been developed to detect software clones, some of which are very sophisticated, but are also expensive to implement and adapt.	Lightweight techniques based on simple string matching are easy to implement, but how effective are they? We present a simple stringbased approach which we have successfully applied to a number of different languages such COBOL, {Java}, C\+\+, Pascal, Python, Smalltalk, C and PDP-11 assembler. In each case the maximum time to adapt the approach to a new language was less than 45 minutes. In this article we investigate a number of simple variants of string-based clone detection that abstract away from common editing operations, and assess the quality of clone detection for very different case studies. Our results confirm that this inexpensive clone detection technique generally achieves high recall and acceptable precision. Over-zealous normalization of the code before comparison, however, can result in unacceptable numbers of false positives.},
  annote = {internationaljournal},
  cvs = {DuplocJournalPaper},
  keywords = {scg-pub recast06 jb06 stefPub duploc kzDuplication},
  month = jan,
  number = 1}

@article{Duca06b,
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P. Black},
  title = {Traits: A Mechanism for fine-grained Reuse},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume = {28},
  pages = {331--388},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06bTOPLASTraits.pdf},
  impactfactor = {5-Year ISI impact factor (2010) 1.478},
  doi = {10.1145/1119479.1119483},
  abstract = {Inheritance is well-known and accepted as a mechanism for reuse in object-oriented languages.	Unfortunately, due to the coarse granularity of inheritance, it may be difficult to decompose an application into an optimal class hierarchy that maximizes software reuse. Existing schemes based on single inheritance, multiple inheritance, or mixins, all pose numerous problems for reuse. To overcome these problems we propose traits, pure units of reuse consisting only of methods. We develop a formal model of traits that establishes how traits can be composed, either to form other traits, or to form classes. We also outline an experimental validation in which we apply traits to refactor a non-trivial application into composable units.},
  annote = {internationaljournal},
  cvs = {TraitsTOPLAS2005},
  issn = {0164-0925},
  keywords = {scg-pub stefPub toplas traits schaerli kzTrait},
  month = mar,
  number = {2},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06bTOPLASTraits.pdf}}

@booklet{Duca17c,
  author = {St\'ephane Ducasse and Peter Kenny},
  title = {Scraping HTML with XPath},
  pages = {30},
  publisher = {Square Bracket Associates},
  collection = {The Pharo Technology Collection},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-scrapingbook.pdf},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  keywords = {skipdoi kzSmalltalk kzPharo lse-pub},
  hal-id = {hal-01612689}}

@inproceedings{Duca03c,
  author = {St\'ephane Ducasse and Philippe Mougin},
  title = {Power to Collections: Generalizing Polymorphism by Unifying Array Programming and Object-Oriented Programming},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03cOOPALEcoop.pdf},
  abstract = {Array programming shines in its ability to express computations at a high-level of abstraction, allowing one to manipulate and query whole sets of data at once. This paper presents the OOPAL model that enhances object-oriented programming with array programming features. The goal of OOPAL is to determine a minimum set of modifications that must be made to the traditional object model in order to take advantage of the possibilities of array programming. It is based on a minimal extension of method invocation and the definition of a kernel of methods implementing the fundamental array programming operations. The model is validated in F-SCRIPT, a new scripting language.},
  annote = {internationalworkshop},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub kzLanguageDesign},
  month = jul}

@inproceedings{Duca98b,
  author = {St\'ephane Ducasse and Robb Nebbe and Tamar Richner},
  title = {Two Reengineering Patterns: Eliminating Type Checking},
  booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing, 1999},
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca98bTwoReengPatterns.pdf},
  abstract = {A reengineering pattern describes how to go from an existing legacy solution to a new refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with design patterns and antipatterns. We then highlight the structure of a reengineering pattern and present two simple, related patterns for type-check elimination.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi pattern kzPattern stefPub},
  month = jul}

@inproceedings{Duca02a,
  author = {St\'ephane Ducasse and Roel Wuyts},
  title = {Supporting Objects as An Anthropomorphic View at Computation or Why {Smalltalk} for Teaching Objects?},
  booktitle = {Proceedings of the Ecoop'02 International Educator Symposium},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca02aTeacherWorkshop.pdf},
  abstract = {In this paper we stress the fact that a language and an environment for teaching object-oriented programming should support the anthropomorphic metaphor promoted by the paradigm. We show that all the cultural aspects of Smalltalk, i.e., the vocabulary and the syntax support the object metaphor. In addition, we stress that the programming environment should also support the metaphor. We show that Smalltalk environments offer an important property we named liveness or object proximity that promotes the anthropomorphic perception of objects. By providing excerpt from our forth coming book, we show how Squeak with the Morphic framework reinforces this ability to make object into living entities.},
  annote = {internationalworkshop},
  keywords = {stefPub scg-pub skip-doi kzTeaching}}

@inproceedings{Duca07b,
  author = {St\'ephane Ducasse and Roel Wuyts and Alexandre Bergel and Oscar Nierstrasz},
  title = {User-Changeable Visibility: Resolving Unanticipated Name Clashes in Traits},
  booktitle = {Proceedings of 22nd International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'07)},
  pages = {171--190},
  publisher = {ACM Press},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07b-FreezableTrait.pdf},
  misc = {Acceptance rate: 33/156=21\%},
  doi = {10.1145/1297027.1297040},
  abstract = {A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts.	Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.},
  acceptnum = {33},
  accepttotal = {156},
  address = {New York, NY, USA},
  annote = {internationalconference topconference},
  isbn = {978-1-59593-786-5},
  keywords = {stefPub alexPub scg-pub kzTrait},
  location = {Montreal, Quebec, Canada},
  medium = {2},
  month = oct,
  rate = {21\%}}

@article{Duca03d,
  author = {St\'ephane Ducasse and Sander Tichelaar},
  title = {Dimensions of Reengineering Environment Infrastructures},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {15},
  pages = {345--373},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03dInfrastructures.pdf},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.279},
  abstract = {Over the last decade many research groups and commercial companies have been developing reengineering environments. However, many design decisions such as support for multiple models, incremental loading of information, tool integration, entity grouping, and their impacts on the underlying meta-model and resulting environment have remained implicit. Based on the experience accumulated while developing the Moose reengineering environment and on a survey of reengineering environments, we present a design space defined by a set of criteria that makes explicit the different options and especially their dependencies and trade-offs. Using this design space, developers of future environments should have a better understanding of the problems they face and the impact of design choices.},
  annote = {internationaljournal},
  keywords = {scg-pub recast04 jb04 stefPub moose kzTools kzEvolution},
  month = oct,
  number = 5}

@inproceedings{Duca00a,
  author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {Tie Code And Questions: a Reengineering Pattern},
  booktitle = {Proceedings of EuroPLoP '2000},
  pages = {209--217},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00aTieCode.pdf},
  abstract = {Reengineering is an inherent aspect of modern software development, with its emphasis on iterative and incremental development. The reengineering pattern presented in this paper shows how you can support your understanding during system reengineering by linking your questions or information about the code in the code itself.},
  annote = {internationalworkshop},
  keywords = {snf-none olit scg-pub skip-doi jb00 stefPub kzPattern}}

@inproceedings{Duca00c,
  author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {Transform Conditionals to Polymorphism},
  booktitle = {Proceedings of EuroPLoP '2000},
  pages = {219--252},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00cTransform.pdf},
  abstract = {Conditionals -i.e., switch statements, nested ifs- that are used to simulate polymorphism hamper evolution and flexibility of applications. The reengineering patterns presented in this paper show you how to transform conditionals in object-oriented code to improve the flexibility of application.},
  annote = {internationalworkshop},
  keywords = {snf-none skip-doi olit scg-pub jb00 stefPub kzPattern}}

@misc{Duca06g,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Seaside: d\'evelopper des composants r\'eutilisables},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 88}

@misc{Duca07o,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {R\'eflexion en Squeak},
  journal = {Linux Magazine},
  volume = {1},
  year = {2007},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = nov,
  number = 99}

@misc{Duca07p,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Introspection et m\'eta-manipulations en Squeak},
  journal = {Linux Magazine},
  volume = {1},
  year = {2007},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = apr,
  number = 93}

@article{Duca06h,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Smalltalk: un mod\`ele pur objet},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = dec,
  number = 89}

@misc{Duca06f,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Seaside: d\'eveloppement d'applications web en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 86}

@inproceedings{Duca97b,
  author = {St\'ephane Ducasse and Tamar Richner},
  title = {Executable Connectors: Towards Reusable Design Elements},
  booktitle = {Proceedings of European Software Engineering Conference and Foundations on Software Engineering (ESEC/FSE'97)},
  volume = {1301},
  pages = {483--500},
  publisher = {Springer-Verlag},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97bExecutableConnectors.pdf},
  misc = {acceptance rate: 19/197 = 9\%},
  doi = {10.1007/3-540-63531-9\_32},
  abstract = {The decomposition of a software application into components and connectors at the design stage has been promoted as a way to describe and reason about complex software architectures. There is, however, surprisingly little language support for this decomposition at implementation level. Interaction relationships which are identified at design time are lost as they get spread out into the participating entities at implementation. In this paper, we propose first-class connectors in an object-oriented language as a first step towards making software architecture more explicit at implementation level. Our connectors are run-time entities which control the interaction of components and can express a rich repertoire of interaction relationships. We show how connectors can be reused and how they enhance the reuse of components.},
  acceptnum = {19},
  accepttotal = {197},
  annote = {internationalconference topconference},
  isbn = {978-3-540-63531-4},
  keywords = {scg-pub flo stefPub kzDependency},
  series = {LNCS}}

@inproceedings{Duca99c,
  author = {St\'ephane Ducasse and Tamar Richner and Robb Nebbe},
  title = {Type-Check Elimination: Two Object-Oriented Reengineering Patterns},
  booktitle = {Proceedings of 6th Working Conference on Reverse Engineering (WCRE'99)},
  pages = {157--168},
  publisher = {IEEE Computer Society},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99cTypeCheckElim.pdf},
  doi = {10.1109/WCRE.1999.806956},
  abstract = {In reengineering an object-oriented system we want to benefit from the expertise developed in earlier efforts. It is therefore essential to have a way to communicate expertise at different levels: from knowledge about how to approach a system to be reengineered, to knowledge about improving code by eliminating 'bad' style. In this paper we propose to use a pattern form to communicate knowledge about reengineering. A reengineering pattern connects an observable problem in the code to a reengineering goal: it describes the process of going from the existing legacy solution causing or aggravating the problem to a new refactored solution which meets the reengineering goal. It thus gives a method appropriate for a specific problem, rather than proposing a general methodology, and makes reference to the appropriate tools or techniques for obtaining the refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with related kinds of patterns. We then highlight the form of reengineering patterns and present two simple patterns for type-check elimination.},
  annote = {internationalconference},
  editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {olit famoos-papref scg-pub jb99 stefPub kzPattern},
  month = oct}

@inproceedings{Duca00d,
  author = {St\'ephane Ducasse and Thomas Hofmann and Oscar Nierstrasz},
  title = {OpenSpaces: An Object-Oriented Framework For Reconfigurable Coordination Spaces},
  booktitle = {Coordination Languages and Models},
  volume = {1906},
  pages = {1--19},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00dOpenSpaces.pdf},
  misc = {acceptance rate: 18/52 = 35\%},
  doi = {10.1007/3-540-45263-X\_1},
  abstract = {Tuple spaces have turned out to be one of the most fundamental abstractions for coordinating communicating agents. At the same time, researchers continue to propose new variants of tuple spaces, since no one approach seems to be universally applicable to all problem domains. Some models offer a certain configurability, but existing approaches generally stop at afixed set of configuration options and static configuration at instantiation time. We argue that a more open approach is needed, and present OpenSpaces, an object-oriented framework that supports static configurability through subclassing across several dimensions, as well as dynamic configurability of policies through runtime composition. We introduce OpenSpaces by showing how it can be used to instantiate a typical application, and we present an overview of the framework, implemented in Smalltalk, detailing the various degrees of configurability.},
  acceptnum = {18},
  accepttotal = {52},
  address = {Limassol, Cyprus},
  annote = {internationalconference},
  editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
  isbn = {978-3-540-41020-1},
  keywords = {scg-pub coordination stefPub kzCoordination},
  month = sep,
  series = {LNCS}}

@inproceedings{Duca06d,
  author = {St\'ephane Ducasse and Tudor G\^irba},
  title = {Using {Smalltalk} as a Reflective Executable Meta-Language},
  booktitle = {International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)},
  volume = {4199},
  pages = {604--618},
  publisher = {Springer-Verlag},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06dMOOSEMODELS2006.pdf},
  doi = {10.1007/11880240\_42},
  abstract = {Object-oriented meta-languages such as MOF or EMOF are often used to specify domain specific languages.	However, these meta-languages lack the ability to describe behavior or operational semantics. Several approaches used a subset of Java mixed with OCL as executable meta-languages. In this paper, we report our experience of using Smalltalk as an executable and integrated meta-language. We validated this approach in incrementally building over the last decade, Moose, a meta-described reengineering environment. The reflective capabilities of Smalltalk support a uniform way of letting the base developer focus on his tasks while at the same time allowing him to meta-describe his domain model. The advantage of our this approach is that the developer uses the same tools and environment},
  address = {Berlin, Germany},
  annote = {internationalconference},
  isbn = {978-3-540-45772-5},
  keywords = {scg-pub girba moose stefPub recast07 norex06 kzMeta},
  medium = {2},
  rate = {28\%},
  series = {LNCS}}

@inproceedings{Duca05d,
  author = {St\'ephane Ducasse and Tudor G\^irba},
  title = {Being a Long-Living Software Mayor --- the SimCity Metaphor to Explain the Challenges Behind Software Evolution},
  booktitle = {Proceedings of CHASE International Workshop 2005},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05dChaseSimCity.pdf},
  annote = {internationalworkshop},
  keywords = {stefPub jb05 kzEvolution}}

@inproceedings{Duca06c,
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn},
  title = {Distribution Map},
  booktitle = {Proceedings of 22nd IEEE International Conference on Software Maintenance},
  pages = {203--212},
  publisher = {IEEE Computer Society},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06cDistributionMap.pdf},
  misc = {acceptance rate: 41/147 = 28\%},
  doi = {10.1109/ICSM.2006.22},
  abstract = {Understanding large software systems is a challenging task, and to support it many approaches have been developed. Often, the result of these approaches categorize existing entities into new groups or associates them with mutually exclusive properties. In this paper we present the Distribution Map as a generic technique to visualize and analyze this type of result. Our technique is based on the notion of focus, which shows whether a property is well-encapsulated or cross-cutting, and the notion of spread, which shows whether the property is present in several parts of the system.	We present a basic visualization and complement it with measurements that quantify focus and spread. To validate our technique we show evidence of applying it on the result sets of different analysis approaches. As a conclusion we propose that the Distribution Map technique should belong to any reverse engineering toolkit.},
  acceptnum = {41},
  accepttotal = {147},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub stefPub moose recast07 kzVisualization},
  medium = {2},
  rate = {28\%},
  series = {ICSM'06}}

@article{Duca08a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn and Lukas Renggli},
  title = {Meta-Environment and Executable Meta-Language using {Smalltalk}: an Experience Report},
  journal = {Journal of Software and Systems Modeling (SOSYM)},
  volume = {8},
  pages = {5--19},
  publisher = {Springer Verlag},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
  impactfactor = {Impact Factor (2011) 1.061},
  doi = {10.1007/s10270-008-0081-4},
  abstract = {No abstract},
  annote = {internationaljournal cook-pub remoose1-pub},
  hal-id = {hal-00746255},
  keywords = {stefPub kzMeta},
  month = feb,
  number = {1}}

@inproceedings{Duca04f,
  author = {St\'ephane Ducasse and Tudor G\^irba and Jean-Marie Favre},
  title = {Modeling Software Evolution by Treating History as a First Class Entity},
  booktitle = {Proceedings Workshop on Software Evolution Through Transformation (SETra 2004)},
  pages = {75--86},
  publisher = {Elsevier},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04fHismo.pdf},
  doi = {10.1016/j.entcs.2004.08.035},
  abstract = {The histories of software systems hold useful information when reasoning about the systems at hand or about general laws of software evolution. Yet, the approaches developed so far, do not rely on an explicit meta-model and do not facilitate the comparison of different evolutions. We argue for the need to define history as a first class entity and propose a meta-model centered around the notion of history. We show the usefulness of our a meta-model by discussing the different analysis it enables.},
  address = {Amsterdam},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution van stefPub recast05 girba hismo moose kzMeta}}

@incollection{Duca05a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Michele Lanza and Serge Demeyer},
  title = {Moose: a Collaborative and Extensible Reengineering Environment},
  booktitle = {Tools for Software Maintenance and Reengineering},
  pages = {55--71},
  publisher = {Franco Angeli},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05aMooseBookChapter.pdf},
  abstract = {Software systems are complex and difficult to analyze. Reverse engineering is a complex analysis that usually involves combining different techniques and tools. Moreover, oftentimes the existing tools are not perfectly suitable for the task, and customization of existing tools, or development of new tools is required. Moose is an extensible reengineering environment designed to provide the necessary infrastructure for tool integration. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and advanced tool integration mechanism.},
  address = {Milano},
  annote = {articlebook},
  isbn = {88-464-6396-X},
  keywords = {moose scg-pub skip-doi jb05 recast05 stefPub jointERCIM girba kzMoose kzEvolution},
  series = {RCOST / Software Technology Series}}

@inproceedings{Duca06a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Roel Wuyts},
  title = {Object-Oriented Legacy System Trace-based Logic Testing},
  booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
  pages = {35--44},
  publisher = {IEEE Computer Society Press},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06aTestLogtestingCSMR.pdf},
  misc = {acceptance rate: 27/65 = 42 \%},
  doi = {10.1109/CSMR.2006.37},
  abstract = {When reengineering legacy systems, it is crucial to assess if the legacy behavior has been preserved or how it changed due to the reengineering effort.	Ideally if a legacy system is covered by tests, running the tests on the new version can identify potential differences or discrepancies. However, writing tests for an unknown and large system is difficult due to the lack of internal knowledge. It is especially difficult to bring the system to an appropriate state. Our solution is based on the acknowledgment that one of the few trustable piece of information available when approaching a legacy system is the running system itself. Our approach reifies the execution traces and uses logic programming to express tests on them. Thereby it eliminates the need to programatically bring the system in a particular state, and handles the test-writer a high-level abstraction mechanism to query the trace. The resulting system, called TESTLOG, was used on several real-world case studies to validate our claims.},
  acceptnum = {27},
  accepttotal = {65},
  annote = {internationalconference},
  keywords = {scg-pub recast06 stefPub kzDynamicInformation},
  medium = {2}}

@inproceedings{Reic07a,
  author = {Stefan Reichhart and Tudor G\^irba and St\'ephane Ducasse},
  title = {Rule-based Assessment of Test Quality},
  booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
  volume = {6/9},
  pages = {231--251},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reic07aTestQualityAssessment.pdf},
  abstract = {With the success of agile methodologies more and
 more projects develop large test suites to ensure
 that the system is behaving as expected. Not only do
 tests ensure correctness, but they also offer a live
 documentation for the code. However, as the system
 evolves, the tests need to evolve as well to keep up
 with the system, and as the test suite grows larger,
 the effort invested into maintaining tests is a
 significant activity. In this context, the quality
 of tests becomes an important issue, as developers
 need to assess and understand the tests they have to
 maintain. In this paper we present TestLint, an
 approach together with an experimental tool for
 qualifying tests. We define a set of criteria to
 determine test quality, and we evaluate our approach
 on a large sample of unit tests found in open-source
 projects.},
  annote = {internationalconference},
  issn = {1660-1769},
  keywords = {scg07 scg-pub jb08 snf07 skip-doi testlint test smell refactoring girba kzChecking kzTools},
  medium = {2},
  month = oct,
  note = {Special Issue. Proceedings of TOOLS Europe 2007}}

@article{Cost20b,
  author = {Steven Costiou and Micka\"{e}l Kerboeuf and Clotilde Toullec and Alain Plantec and St\'ephane Ducasse},
  title = {Object Miners: Acquire, Capture and Replay Objects to Track Elusive Bugs},
  journal = {Journal of Object Technology},
  volume = {19},
  pages = {1:1-32},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cost20b-JOT-ObjectMiners.pdf},
  annote = {internationaljournal},
  number = {1},
  annote = {internationaljournal},
  keywords = {kzTools},
  issn = {1660-1769},
  month = jul,
  doi = {10.5381/jot.2020.19.1.a1},
  url = {http://www.jot.fm/contents/issue_2020_01/article1.html}}

@inproceedings{Rich99a,
  author = {Tamar Richner and St\'ephane Ducasse},
  title = {Recovering High-Level Views of Object-Oriented Applications from Static and Dynamic Information},
  booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
  pages = {13--22},
  publisher = {IEEE Computer Society Press},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich99aRecoveringViews.pdf},
  misc = {acceptance rate: 49/100 = 49\%},
  doi = {10.1109/ICSM.1999.792487},
  abstract = {Recovering architectural documentation from code is
 crucial to maintaining and reengineering software
 systems. Reverse engineering and program
 understanding approaches are often limited by the
 fact that (1) they propose a fixed set of predefined
 views and (2) they consider either purely static or
 purely dynamic views of the application. In this
 paper we present an environment supporting the
 generation of tailorable views of object-oriented
 systems from both static and dynamic information.
 Our approach is based on the combination of
 user-defined queries which allow an engineer to
 create high-level abstractions and to produce views
 using these abstractions.},
  acceptnum = {49},
  accepttotal = {100},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  editor = {Hongji Yang and Lee White},
  keywords = {scg-pub oorp stefPub kzDynamicInformation kzArchi},
  month = sep}

@inproceedings{Rich02a,
  author = {Tamar Richner and St\'ephane Ducasse},
  title = {Using Dynamic Information for the Iterative Recovery of Collaborations and Roles},
  booktitle = {Proceedings of 18th IEEE International Conference on Software Maintenance (ICSM'02)},
  pages = {34},
  publisher = {IEEE Computer Society},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich02aRolesExtractionICSM2002.pdf},
  misc = {acceptance rate: 61/127 = 48\%},
  doi = {10.1109/ICSM.2002.1167745},
  abstract = {Modeling object-oriented applications using
 collaborations and roles is now well accepted.
 Collaboration-based or role-based designs decompose
 an application into tasks performed by a subset of
 the applications' classes. Collaborations prov ide a
 larger unit of understanding and reuse than classes,
 and are an important aid in the maintenance and
 evolution of the software. This kind of design
 information is lost, however, at the implementation
 level, making it hard to maintain and evolve an e
 xisting software application. The extraction of
 collaborations from code is therefore an important
 issue in design recovery. In this paper we propose
 an iterative approach which uses dynamic information
 to support the recovery and understanding of collabo
 rations. We describe a tool we have developed to
 support our approach and demonstrate its use on a
 case study.},
  acceptnum = {61},
  accepttotal = {127},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub stefPub kzDynamicInformation},
  month = oct}

@inproceedings{Rich98b,
  author = {Tamar Richner and St\'ephane Ducasse and Roel Wuyts},
  title = {Understanding Object-Oriented Programs with Declarative Event Analysis},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
  volume = {1543},
  publisher = {Springer-Verlag},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich98bEvents.pdf},
  abstract = {Understanding how components in an application
 interact to ensure a certain functionality is an
 essential aspect of understanding a software
 application. To obtain this kind of information an
 analysis of the dynamic behavior of an application
 is more appropriate than a static analysis of the
 code. Understanding dynamic behavior through event
 analysis is a challenge because of the large amount
 of data gathered through program executions. In this
 paper, we show how we define declarative queries
 that allow us to filter the event data collected and
 to define new abstractions which aid in program
 understanding.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {scg-pub skip-doi stefPub kzDynamicInformation},
  month = jul,
  series = {LNCS}}

@inproceedings{Teru13a,
  author = {Teruel, Camille and Cassou, Damien and Ducasse, St\'ephane},
  title = {{Object Graph Isolation with Proxies}},
  booktitle = {{DYLA - 7th Workshop on Dynamic Languages and Applications, Collocated with 26th European Conference on Object-Oriented Programming - 2013}},
  year = {2013},
  pdf = {http://hal.inria.fr/hal-00834320/PDF/main.pdf},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru13a-Dyla-ObjectGraph.pdf},
  abstract = {More and more software systems are now made of multiple collaborating third-party components. Enabling fine-grained control over the communication between components becomes a major requirement. While software isolation has been studied for a long time in operating systems (OS), most programming languages lack support for isolation. In this context we explore the notion of proxy. A proxy is a surrogate for another object that controls access to this object. We are particularly interested in generic proxy implementations based on language-level reflection. We present an analysis that shows how these reflective proxies can propagate a security policy thanks to the transitive wrapping mechanism. We present a prototype implementation that support transitive wrapping and allows a fine-grained control over an isolated object graph.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-00834320},
  keywords = {lse-pub stefPub kzLanguageDesign}}

@inproceedings{Teru15b,
  author = {Teruel, Camille and Ducasse, St\'ephane and Cassou, Damien and Marcus Denker},
  title = {Access Control to Reflection with Object Ownership},
  booktitle = {Dynamic Languages Symposium (DLS'2015)},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15b-DLS15-AccessControlWithOwnership.pdf},
  url = {https://hal.inria.fr/hal-01217041},
  doi = {10.1145/2816707.2816721},
  abstract = {Reflection is a powerful programming language
 feature that enables language extensions, generic
 code, dynamic analyses, development tools, etc.
 However, uncontrolled reflection breaks object
 encapsulation and considerably increases the attack
 surface of programs e.g., malicious libraries can
 use reflection to attack their client applications.
 To bring reflection and object encapsulation back
 together, we use dynamic object ownership to design
 an access control policy to reflective operations.
 This policy grants objects full reflective power
 over the objects they own but limited reflective
 power over other objects. Code is still able to use
 advanced reflective operations but reflection cannot
 be used as an attack vector anymore.},
  annote = {internationalconference},
  audience = {international},
  hal-id = {hal-01217041},
  inria = {RMOD},
  keywords = {lse-pub stefPub kzLanguageDesign},
  acceptnum = {14},
  accepttotal = {40}}

@article{Teru15a,
  author = {Teruel, Camille and Wernli, Erwann and Ducasse, St\'ephane and Nierstrasz, Oscar},
  title = {Propagation of Behavioral Variations with Delegation Proxies},
  journal = {Transactions on Aspect-Oriented Software Development (TAOSD)},
  pages = {63--95},
  publisher = {Springer},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf},
  hal-id = {hal-01135706},
  keywords = {lse-pub stefPub kzLanguageDesign},
  abstract = {Scoping behavioral variations to dynamic extents is useful to support non-functional concerns that otherwise result in cross-cutting code. Unfortunately, such forms of scoping are difficult to obtain with traditional reflection or aspects. We propose delegation proxies, a dynamic proxy model that supports behavioral intercession through the interception of various interpretation operations. Delegation proxies permit different behavioral variations to be easily composed together. We show how delegation proxies enable behavioral variations that can propagate to dynamic extents. We demonstrate our approach with examples of behavioral variations scoped to dynamic extents that help simplify code related to safety, reliability, and monitoring.},
  annote = {internationaljournal},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf}}

@inproceedings{Teso18a,
  author = {Tesone, Pablo and Polito, Guillermo and Fabresse, Luc and Bouraqadi, Noury and Ducasse, St\'ephane},
  title = {Implementing Modular Class-based Reuse Mechanisms on Top of a Single Inheritance VM},
  booktitle = {Symposium on Applied Computing (SAC'18)},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso18a-SAC-ExtensibleMetaclasses.pdf},
  url = {https://hal.archives-ouvertes.fr/hal-01812612},
  doi = {10.1145/3167132.3167244},
  annote = {internationalconference},
  abstract = {Code reuse is a good strategy to avoid code duplication and speed up software development. Existing object-oriented programming languages propose different ways of combining existing and new code such as e.g., single inheritance, multiple inheritance, Traits or Mixins. All these mechanisms present advantages and disadvantages and there are situations that require the use of one over the other. To avoid the complexity of implementing a virtual machine (VM), many of these mechanisms are often implemented on top of an existing high-performance VM, originally meant to run a single inheritance object-oriented language. These implementations require thus a mapping between the programming model they propose and the execution model provided by the VM. Moreover, reuse mechanisms are not usually composable, nor it is easy to implement new ones for a given language. In this paper, we propose a modular meta-level runtime architecture to implement and combine different code reuse mechanisms. This architecture supports dynamic combination of several mechanisms without affecting runtime performance in a single inheritance object-oriented VM. It includes moreover a reflective Meta-Object Protocol to query and modify classes using the programming logical model instead of the underlying low-level runtime model. Thanks to this architecture, we implemented Stateful Traits, Mixins, CLOS multiple inheritance, CLOS Standard Method Combinations and Beta prefixing in a modular and composable way.},
  address = {Pau, France},
  month = apr,
  keywords = {lse-pub pharo kzInfrastructure kzLanguage},
  hal-id = {hal-01812612}}

@inproceedings{Arlo16a,
  author = {Thibault Arloing and Yann Dubois and Damien Cassou and St\'ephane Ducasse},
  title = {Pillar: A Versatile and Extensible Lightweight Markup Language},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arlo16a-IWST16-Pillar.pdf},
  doi = {10.1145/2991041.2991066},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353882},
  hal-url = {http://hal.inria.fr/hal-01353882},
  keywords = {moose lse-pub kzOther},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Raff17a,
  author = {Thibault Raffaillac and St\'ephane Huo and St\'ephane Ducasse},
  title = {Turning Function Calls Into Animations},
  booktitle = {Proceedings of the 9th ACM SIGCHI Symposium on Engineering Interactive Computing Systems},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raff17a-SIGCHI-Animations.pdf},
  url = {https://hal.inria.fr/hal-01564116},
  annote = {internationalworkshop},
  abstract = {Animated transitions are an integral part of modern interaction frameworks. With the increasing number of animation scenarios, they have grown in range of animatable features. Yet not all transitions can be smoothed: programming systems limit the flexibility of frameworks for animating new things, and force them to expose low-level details to programmers. We present an ongoing work to provide system-wide animation of objects, by introducing a delay operator. This operator turns setter function calls into animations. It offers a coherent way to express animations across frameworks, and facilitates the animation of new properties.},
  address = {Lisbon, Portugal},
  month = jun,
  inria = {RMOD},
  keywords = {lse-pub kzOther},
  hal-id = {hal-01564116}}

@inproceedings{Dupr17a,
  author = {Thomas Dupriez and Guillermo Polito and St\'ephane Ducasse},
  title = {Analysis and exploration for new generation debuggers},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {5:1--5:6},
  publisher = {ACM},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr17a-IWST-NewGenerationDebuggers.pdf},
  doi = {10.1145/3139903.3139910},
  annote = {internationalworkshop},
  abstract = {Locating and fixing bugs is a well-known time consuming task. Advanced approaches such as object-centric or back-in-time debuggers have been proposed in the literature, still in many scenarios developers are left alone with primitive tools such as manual breakpoints and execution stepping. In this position paper we explore several advanced on-line debugging techniques such as advanced breakpoints and on-line execution comparison, that could help developers solve complex debugging scenarios. We analyse the challenges and underlying mechanisms required by these techniques. We present some early but promising prototypes we built on the Pharo programming language. We finally identify future research paths by analysing existing research and connecting it to the techniques we presented before.},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01585338},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {5},
  numpages = {6},
  acmid = {3139910},
  address = {New York, NY, USA},
  keywords = {Debugger ; Tool ; Stack ; Breakpoint ; Watchpoint; lse-pub kzInfrastructure},
  hal-id = {hal-01585338}}

@inproceedings{Mens05a,
  author = {Tom Mens and Michel Wermelinger and St\'ephane Ducasse and Serge Demeyer and Robert Hirschfeld and Mehdi Jazayeri},
  title = {Challenges in Software Evolution},
  booktitle = {Proceedings of the International Workshop on Principles of Software Evolution (IWPSE 2005)},
  pages = {123--131},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 13/54 = 24\%},
  acceptnum = {13},
  accepttotal = {54},
  annote = {internationalworkshop},
  keywords = {stefPub scgPub kzPattern},
  rate = {24\%}}

@inproceedings{Bour10a,
  author = {Tristan Bourgois and Jannik Laval and St\'ephane Ducasse and Damien Pollet},
  title = {BLOC: a Trait-Based Collections Library - a Preliminary Experience Report},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'10)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bour10a-IWST10-bloc.pdf},
  abstract = {A trait is a programming construct which provides code reusability. Traits are groups of methods that can be reused orthogonally from inheritance. Traits offer a solution to the problems of multiple inheritance by providing a behavior-centric modularity. Since traits offer an alternative to traditional inheritance-based code reuse, a couple of questions arise. For example, what is a good granularity for a Trait enabling reuse as well as plug ease? How much reuse can we expect on large existing inheritance-based hierarchies?
In this paper we take as case study the Smalltalk Collection hierarchy and we start rewriting it from scratch using traits from the beginning. We show how such library can be built using traits and we report such a preliminary experience. Since the Collection library is large, we focused and built the main classes of the library with Traits and report problems we encountered and how we solved them. Results of this experience are positive and show that we can build new collections based on the traits used to define the new library kernel.},
  address = {Barcelona, Spain},
  annote = {internationalworkshop},
  hal-id = {inria-00511902},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub pharo kzTrait}}

@inproceedings{Girb05c,
  author = {Tudor G\^irba and Adrian Kuhn and Mauricio Seeberger and St\'ephane Ducasse},
  title = {How Developers Drive Software Evolution},
  booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2005)},
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05cOwnershipMap.pdf},
  misc = {acceptance rate: 13/54 = 24\%},
  doi = {10.1109/IWPSE.2005.21},
  abstract = {As systems evolve their structure change in ways not
 expected upfront. As time goes by, the knowledge of
 the developers becomes more and more critical for
 the process of understanding the system. That is,
 when we want to understand a certain issue of the
 system we ask the knowledgeable developers. Yet, in
 large systems, not every developer is knowledgeable
 in all the details of the system. Thus, we would
 want to know which developer is knowledgeable in the
 issue at hand. In this paper we make use of the
 mapping between the changes and the author
 identifiers (e.g., user names) provided by
 versioning repositories. We first define a
 measurement for the notion of code ownership. We use
 this measurement to define the Ownership Map
 visualization to understand when and how different
 developers interacted in which way and in which part
 of the system. We report the results we obtained on
 several large systems.},
  acceptnum = {13},
  accepttotal = {54},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution visualization authors stefPub recast06 moose chronia kzHistory kzVisualization},
  location = {Lisbon, Portugal},
  rate = {24\%}}

@inproceedings{Girb05b,
  author = {Tudor G\^irba and Jean-Marie Favre and St\'ephane Ducasse},
  title = {Using Meta-Model Transformation to Model Software Evolution},
  booktitle = {Proceedings of 2nd International Workshop on Meta-Models and Schemas for Reverse Engineering (ATEM 2004)},
  pages = {57--64},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05bMetaModelTransATEM2004.pdf},
  doi = {10.1016/j.entcs.2005.07.005},
  abstract = {Understanding how software systems evolve is useful
 from different perspectives: reverse engineering,
 empirical studies etc.. For an effective
 understanding we need an explicit meta-model. We
 introduce Hismo, a meta-model which is centered
 around the notion of history and we show how we can
 obtain it from a snapshot meta-model. Based on our
 experience in developing the Hismo reverse
 engineering system, we show how we can transform a
 snapshot meta-model in a history metamodel.},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution meta-modeling hismo van moose recast05 jointERCIM girba stefPub jb05 kzMeta kzHistory}}

@inproceedings{Girb05a,
  author = {Tudor G\^irba and Michele Lanza and St\'ephane Ducasse},
  title = {Characterizing the Evolution of Class Hierarchies},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering},
  pages = {2--11},
  publisher = {IEEE Computer Society},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05aHierarchiesEvolution.pdf},
  misc = {acceptance rate: 33/81 = 41 \%},
  doi = {10.1109/CSMR.2005.15},
  abstract = {Analyzing historical information can show how a
 software system evolved into its current state,
 which parts of the system are stable and which have
 changed more. However, historical analysis implies
 processing a vast amount of information making the
 interpretation of the results difficult. To address
 this issue, we introduce the notion of the history
 of source code artifacts as a first class entity and
 define measurements which summarize the evolution of
 such entities. We use these measurements to define
 rules by which to detect different characteristics
 of the evolution of class hierarchies. Furthermore,
 we discuss the results we obtained by visualizing
 them using a polymetric view. We apply our approach
 on two large open source case studies and classify
 their class hierarchies based on their history.},
  acceptnum = {33},
  accepttotal = {81},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub evolution visualization metrics van recast05 girba stefPub moose kzVisualization kzHistory},
  rate = {41\%},
  series = {CSMR'05}}

@article{Girb06a,
  author = {Tudor G\^irba and St\'ephane Ducasse},
  title = {Modeling History to Analyze Software Evolution},
  journal = {Journal of Software Maintenance: Research and Practice (JSME)},
  volume = {18},
  pages = {207--236},
  publisher = {John Wiley and Sons, Ltd.},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb06aHismo.pdf},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  abstract = {The histories of software systems hold useful
 information when reasoning about the systems at hand
 or when reasoning about general laws of software
 evolution. Over the past 30 years more and more
 research has been spent on understanding software
 evolution. However, the approaches developed so far
 do not rely on an explicit meta-model, and thus,
 they make it difficult to reuse or compare their
 results. We argue that there is a need for an
 explicit meta-model for software evolution analysis.
 We present a survey of the evolution analyses and
 deduce a set of requirements that an evolution
 meta-model should have. We define, Hismo, a
 meta-model in which history is modeled as an
 explicit entity. Hismo adds a time layer on top of
 structural information, and provides a common
 infrastructure for expressing and combining
 evolution analyses and structural analyses. We
 validate the usefulness of our a meta-model by
 presenting how different analyses are expressed on
 it.},
  annote = {internationaljournal},
  keywords = {hasler07 scg-pub skip-doi recast06 stefPub mooseCincom moose kzMeta kzHistory meta-modeling hismo evolution}}

@inproceedings{Girb04b,
  author = {Tudor G\^irba and St\'ephane Ducasse and Michele Lanza},
  title = {{Yesterday's} {Weather}: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes},
  booktitle = {Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM'04)},
  pages = {40--49},
  publisher = {IEEE Computer Society},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04b-ICSM04-YesterdayWeather.pdf},
  misc = {acceptance rate: 38/122 = 31\%},
  doi = {10.1109/ICSM.2004.1357788},
  abstract = {Knowing where to start reverse engineering a large software system, when no information other than the system`s source code itself is available, is a daunting task. Having the history of the code (i.e., the versions) could be of help if this would not imply analyzing a huge amount of data. In this paper we present an approach for identifying candidate classes for reverse engineering and reengineering efforts. Our solution is based on summarizing the changes in the evolution of object-oriented software systems by defining history measurements. Our approach, named Yesterday`s Weather, is an analysis based on the retrospective empirical observation that classes which changed the most in the recent past also suffer important changes in the near future. We apply this approach on two case studies and show how we can obtain an overview of the evolution of a system and pinpoint its classes that might change in the next versions.},
  acceptnum = {38},
  accepttotal = {122},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub evolution metrics hismo stefPub moose recast05 jb05 kzHistory},
  location = {Illinois, USA},
  month = sep,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04bYesterdayWeather.pdf}}

@inproceedings{Girb04d,
  author = {Tudor G\^irba and St\'ephane Ducasse and Radu Marinescu and Daniel Ra\c{t}iu},
  title = {Identifying Entities That Change Together},
  booktitle = {Ninth IEEE Workshop on Empirical Studies of Software Maintenance},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04dEntitiesChangeTogether.pdf},
  abstract = {Software system need to change over time to cope
 with the new requirements. Furthermore, due to
 design decisions, the new requirements happen to
 crosscut the system's structure. Understanding how
 changes appear in the system can reveal hidden
 dependencies between different parts of the system.
 We propose to group entities that change together
 according to a logical expression that specifies the
 change condition. Furthermore, we can group entities
 at different levels of abstraction (i.e., method,
 class, package). Our approach is based on an
 explicit history meta model that centers around the
 notion of history and which enables the definition
 of historical measurements which summarize the
 changes. We apply our approach on two large case
 studies and show how we can identify groups of
 related entities and detect bad smells.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi evolution van metrics smell hismo stefPub recast05 girba jb05 moose kzHistory}}

@inproceedings{Girb07a,
  author = {Tudor G\^irba and St\'ephane Ducasse and {A}drian {K}uhn and Radu Marinescu and Daniel Ra\c{t}iu},
  title = {Using Concept Analysis to Detect Co-Change Patterns},
  booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2007)},
  pages = {83--89},
  publisher = {ACM Press},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb07aCoChangePatterns.pdf},
  doi = {10.1145/1294948.1294970},
  abstract = {Software systems need to change over time to cope
 with new requirements, and due to design decisions,
 the changes happen to crosscut the system's
 structure. Understanding how changes appear in the
 system can reveal hidden dependencies between
 different entities of the system. We propose the
 usage of concept analysis to identify groups of
 entities that change in the same way and in the same
 time. We apply our approach at different levels of
 abstraction (i.e., method, class, package) and we
 detect fine grained changes (i.e., statements were
 added in a class, but no method was added there).
 Concept analysis is a technique that identifies
 entities that have the same properties, but it
 requires manual inspection due to the large number
 of candidates it detects. We propose a heuristic
 that dramatically eliminate the false positives. We
 apply our approach on two case studies and we show
 how we can identify hidden dependencies and detect
 bad smells.},
  annote = {internationalworkshop},
  isbn = {978-1-59593-722-3},
  keywords = {scg07 scg-pub evolution fca girba jb08 metrics moose norex07 stefPub kzHistory},
  medium = {2}}

@article{Uqui14a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Andy Kellens},
  title = {Supporting Streams of Changes during Branch Integration},
  journal = {Journal of Science of Computer Programming},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui14a-SCISCO-StreamsOfChanges.pdf},
  impactfactor = {5-year impact factor (2012) 0.903},
  abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
  annote = {internationaljournal},
  hal = {http://hal.inria.fr/hal-01060524},
  hal-id = {hal-01060534},
  keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzMeta kzMerging}}

@article{Uqui11a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Ring: a Unifying Meta-Model and Infrastructure for {S}malltalk Source Code Analysis Tools},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {38},
  pages = {44-60},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui11a-RingJournalPaper-CSSJournal.pdf},
  impactfactor = {Impact factor (2010) 0.541},
  abstract = {Source code management systems record different versions of code. Tool support can then compute deltas between versions. To ease version history analysis we need adequate models to represent source code entities. Now naturally the questions of their definition, the abstractions they use, and the APIs of such models are raised, especially in the context of a reflective system which already offers a model of its own structure.
	We believe that this problem is due to the lack of a powerful code meta-model as well as an infrastructure. In Smalltalk, often several source code meta-models coexist: the Smalltalk reflective API coexists with the one of the Refactoring Engine or distributed versioning system such as Monticello or Store. While having specific meta-models is an adequate engineered solution, it multiplies	meta-models and it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly hinders navigation tool reuse when meta-models do not offer polymorphic APIs.
	As a first step to provide an infrastructure to support history analysis, this article presents Ring, a unifying source code meta-model that can be used to support several activities and proposes a unified and layered approach to be the foundation for building an infrastructure for version and stream of change analyses. We re-implemented three tools based on Ring to show that it can be used as the underlying meta-model for remote and off-image browsing, scoping refactoring, and visualizing and analyzing changes. As a future work and based on Ring we will build a new generation of history analysis tools.},
  annote = {internationaljournal},
  hal-id = {inria-00629677},
  keywords = {stefPub lse-pub raweb2011 pharo pharo-pub kzMeta kzMerging},
  month = apr,
  number = 1}

@inproceedings{Uqui10b,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Meta-models and Infrastructure for Smalltalk Omnipresent History},
  booktitle = {Smalltalks'2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui10b-Smalltalk2010-Metamodels.pdf},
  abstract = {Source code management systems record different versions of code. Tool support can then com- pute deltas between versions. However there is little support to be able to perform history-wide queries and analysis: for example building slices of changes and identifying their differences since the beginning of the project. We believe that this is due to the lack of a powerful code meta- model as well as an infrastructure. For example, in Smalltalk often several source code meta- models coexist: the Smalltalk reflective API coexists with the one of the Refactoring engine or distributed versioning system. While having specific meta-models is an engineered solution, it hampers meta-models manipulation as it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly navigation tool reuse. As a first step to solve this problem, this article presents several source code models that could be used to support several activities and proposes an unified and layered approach to be the foundation for building an infrastructure for omnipresent version browsing.},
  annote = {internationalworkshop},
  hal-id = {inria-00531613},
  keywords = {stefPub lse-pub pharo pharo-pub kzMeta kzMerging}}

@inproceedings{Uqui10a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Visually Supporting Source Code Changes Integration: the {T}orch Dashboard},
  booktitle = {Proceedings of the 17th Working Conference on Reverse Engineering (WCRE'10)},
  pages = {55-64},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui10a-Torch-WCRE10.pdf},
  misc = {Acceptance rate = 22/68 = 32\%},
  abstract = {Automatic and advanced merging algorithms help programmers to merge their modifications in main development repositories. However, there is little support to help release masters (integrators) to take decisions about the integration of published merged changes into the system release. Most of the time, the release master has to read all the changed code, check the diffs to build an idea of a change, and read unchanged code to understand the context of some changes. Such a task can be overwhelming. In this paper we present a dashboard to support integrators getting an overview of proposed changes in the context of object-oriented programming. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. We describe our experiment applying it to Pharo, a large open-source system, and report on the evaluation of our approach by release masters of several open-source projects.},
  annote = {internationalconference},
  hal-id = {inria-00531508},
  keywords = {lse-pub pharo pharo-pub kzMerging kzVisualisation},
  month = oct}

@article{Uqui13a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Visually charactering source code changes},
  journal = {Journal of Science of Computer Programming},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui13a-SCICO-Official-VisuallyCharacterizingChange.pdf},
  impactfactor = {5-year impact factor (2012) 0.903},
  doi = {10.1016/j.scico.2013.08.002},
  abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
  annote = {internationaljournal},
  hal-id = {inria-00862049},
  keywords = {stefPub lse-pub raweb2013 pharo pharo-pub kzMeta kzMerging kzVisualization}}

@inproceedings{Verh19a,
  author = {Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Seriai, Abderrahmane and Deruelle, Laurent and Ducasse, St\'ephane and Derras, Mustapha},
  title = {{GUI} Migration using {MDE} from {GWT} to {Angular} 6: An Industrial Case},
  booktitle = {2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02019015},
  annote = {internationalconference},
  hal-id = {hal-02019015},
  abstract = {During the evolution of an application, it happens that developers must change the programming language. In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both frameworks are web Graphical User Interface (GUI) frameworks, is made difficult because they use different programming languages and different organization schema. Such migration is complicated by the fact that the new application must be able to mimic closely the visual aspect of the old one so that the users of the application are not disrupted. We propose an approach in four steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 pages. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.},
  tagnicolasa = {other migration gui},
  address = {Hangzhou, China}}

@inproceedings{Verh17a,
  author = {Verhaeghe, Beno{\^\i}t and Nicolas Anquetil and St\'ephane Ducasse and Vincent Blondeau},
  title = {Usage of Tests in an Open-Source Community},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {4:1--4:9},
  publisher = {ACM},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verh17a-IWST-TestUsage.pdf},
  doi = {10.1145/3139903.3139909},
  annote = {internationalworkshop},
  abstract = {During the development, it is known that tests ensure the good behavior of applications and improve their quality. We studied developers testing behavior inside the Pharo community in the purpose to improve it. In this paper, we take inspiration from a paper of the literature to enhance our comprehension of test habits in our open source community. We report results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are strengthened by interviews with developers involved in the study. The main findings are that developers run tests every modifications of their code they did; most of the time they practice test selection (instead of launching an entire test suite); however they are not accurate in their selection; they change their selection depending on the duration of the tests and; contrary to expectation, test selection is not influenced by the size of the test suite.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {4},
  numpages = {9},
  address = {New York, NY, USA},
  keywords = {lse-pub ; Regression Test Selection ; Case study ; Inter- views ; Pharo Community kzChecking},
  tagnicolasa = {other test},
  hal-id = {hal-01579106}}

@inproceedings{Verh19e,
  author = {Verhaeghe, Beno{\^i}t and Fuhrman, Christopher and Guerrouj, Latifa and Anquetil, Nicolas and Ducasse, St{\'e}phane},
  title = {Empirical Study of Programming to an Interface},
  booktitle = {Proceedings of 34th Conference on Automated Software Engineering (ASE'19)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02353681},
  address = {San Diego, United States},
  month = nov,
  tagnicolasa = {other quality},
  annote = {internationalworkshop},
  url = {https://hal.inria.fr/hal-02353681},
  hal-id = {hal-02304301}}

@article{Blon16a,
  author = {Vincent Blondeau and Anne Etien and Nicolas Anquetil and Sylvain Cresson	and Pascal Croisy and St\'ephane Ducasse},
  title = {Test Case Selection in Industry: An Analysis of Issues Related to Static Approaches},
  journal = {Software Quality Journal},
  pages = {1--35},
  publisher = {Springer Verlag},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon16a-SoftwareQualityJournal-TestCaseSelectionInIndustry.pdf},
  doi = {10.1007/s11219-016-9328-4},
  abstract = {Automatic testing constitutes an important part of everyday development practice. Worldline, a major IT company, is creating more and more tests to ensure the good behavior of its applications and gains in efficiency and quality. But running all these tests may take hours. This is especially true for large systems involving, for example, the deployment of a web server or communication with a database. For this reason, tests are not launched as often as they should be and are mostly run at night. The company wishes to improve its development and testing process by giving to developers rapid feedback after a change. An interesting solution is to reduce the number of tests to run by identifying only those exercising the piece of code changed. Two main approaches are proposed in the literature: static and dynamic. The static approach creates a model of the source code and explores it to find links between changed methods and tests. The dynamic approach records invocations of methods during the execution of test scenarios. Before deploying a test case selection solution, Worldline created a partnership with us to investigate the situation in its projects and to evaluate these approaches on three industrial, closed source, cases to understand the strengths and weaknesses of each solution. We propose a classification of problems that may arise when trying to identify the tests that cover a method. We give concrete examples of these problems and list some possible solutions. We also evaluate other issues such as the impact on the results of the frequency of modification of methods or considering groups of methods instead of single ones. We found that solutions must be combined to obtain better results, and problems have different impacts on projects. Considering commits instead of individual methods tends to worsen the results, perhaps due to their large size.},
  annote = {internationaljournal},
  inria = {RMOD},
  issn = {1573-1367},
  hal-url = {https://hal.inria.fr/hal-01344842},
  tagnicolasa = {other test},
  hal-id = {hal-01344842},
  keywords = {lse-pub ; moose-pub ; pharo-pub kzChecking}}

@inproceedings{Blon17a,
  author = {Vincent Blondeau and Anne Etien and Nicolas Anquetil and Sylvain Cresson and Pascal Croisy and St\'ephane Ducasse},
  title = {{What are the Testing Habits of Developers? A Case Study in a Large IT Company}},
  booktitle = {Proceedings of the 21st IEEE International Conference on Software Maintenance and Evolution (ICSME'17)},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon17a-ICSME-FinalVersion.pdf},
  hal-url = {https://hal.inria.fr/hal-01571655},
  abstract = {Tests are considered important to ensure the good behavior of applications and improve their quality. But development in companies also involves tight schedules, old habits, less-trained developers, or practical difficulties such as creating a test database. As a result, good testing practices are not always used as often as one might wish. With a major IT company, we are engaged in a project to understand developers testing behavior, and whether it can be improved. Some ideas are to promote testing by reducing test session length, or by running automatically tests behind the scene and send warnings to developers about the failing ones. Reports on developers testing habits in the literature focus on highly distributed open-source projects, or involve students programmers. As such they might not apply to our industrial, closed source, context. In this paper, we take inspiration from experiments of two papers of the literature to enhance our comprehension of the industrial environment. We report the results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are reinforced by interviews with developers involved in the study. The main findings are that test practice is in better shape than we expected; developers select tests " ruthlessly " (instead of launching an entire test suite); although they are not accurate in their selection, and; contrary to expectation, test selection is not influenced by the size of the test suite nor the duration of the tests.},
  address = {Shanghai, China},
  month = aug,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case ; Test selection, kzChecking},
  hal-id = {hal-01571655},
  tagnicolasa = {other test},
  annote = {topconference internationalconference},
  rate = {27.8\%}}

@inproceedings{Blon16b,
  author = {Vincent Blondeau and Nicolas Anquetil and St\'ephane Ducasse and Sylvain Cresson and Pascal Croisy},
  title = {Test Selection with Moose In Industry: Impact of Granularity},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon16b-IWST-TestSelectionWithMoose.pdf},
  url = {https://hal.inria.fr/hal-01352468},
  address = {Prague, Czech Republic},
  month = sep,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case ; Static ; Test selection ; Moose ; Dynamic, kzChecking},
  hal-id = {hal-01352468},
  tagnicolasa = {other test},
  annote = {internationalworkshop}}

@inproceedings{Wern14a,
  author = {Wernli, Erwann and Nierstrasz, Oscar and Teruel, Camille and Ducasse, St\'ephane},
  title = {Delegation Proxies: The Power of Propagation},
  booktitle = {Proceedings of the 13th International Conference on Modularity},
  year = {2014},
  url = {http://rmod.inria.fr/archive/papers/Wern13a-DelegatingProxy-AOSD.pdf},
  address = {Lugano, Suisse},
  annote = {internationalconference topconference},
  hal-id = {hal-00958573},
  keywords = {lse-pub stefPub kzLanguageDesign kzMessaging},
  month = {apr}}

@misc{Deme03b,
  author = {Wolfgang Demeuter and St\'ephane Ducasse and Theo D'hondt and Ole Lehrmann Madsen},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {2003},
  annote = {workshopproceedings},
  keywords = {kzEditor},
  series = {LNCS}}

@book{Brif01a,
  author = {Xavier Briffault and St\'ephane Ducasse},
  title = {Squeak},
  publisher = {Eyrolles, Paris},
  year = {2001},
  annote = {book},
  keywords = {smalltalk squeak kzSmalltalk},
  month = nov}

@inproceedings{Zait20b,
  author = {Zaitsev, Oleksandr and Ducasse, Stephane and Bergel, Alexandre and Eveillard, Mathieu},
  title = {Suggesting Descriptive Method Names: An Exploratory Study of Two Machine Learning Approaches},
  booktitle = {International Conference on the Quality of Information and Communications Technology},
  pages = {93--106},
  year = {2020},
  keywords = {kzEvolution},
  annote = {internationalconference},
  organization = {Springer}}

@inproceedings{Cuts09a,
  author = {van Cutsem, Tom and Alexandre Bergel and St\'ephane Ducasse and De Meuter, Wolfgang},
  title = {Adding State and Visibility Control to Traits using Lexical Nesting},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'09)},
  publisher = {Springer},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cuts09a-ECOOP09-Traits.pdf},
  misc = {21\%},
  abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits.
This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.},
  address = {London, UK},
  annote = {internationalconference topconference},
  editor = {Sophia Drossopoulou},
  hal-id = {inria-00498397},
  keywords = {traits alexPub stefPub kzTrait},
  rate = {21\%},
  series = {Lecture Notes in Computer Science}}

@article{Ryse14a,
  author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
  title = {Seamless Composition and Reuse of Customizable User Interfaces with Spec},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ryse14a-SCICO-Spec.pdf},
  abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
  annote = {internationaljournal},
  hal-id = {hal-00915350},
  keywords = {lse-pub stefPub kzIDE}}

@inproceedings{Ryse12b,
  author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
  title = {Spec, a framework for the specification and reuse of UIs and their models},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2012)},
  pages = {2:1--2:14},
  publisher = {ACM},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ryse12b-Spec-IWST12-Final.pdf},
  doi = {10.1145/2448963.2448965},
  abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
  address = {Gent, Belgium},
  annote = {internationalworkshop},
  hal-id = {hal-00759030},
  isbn = {978-1-4503-1897-6},
  keywords = {lse-pub stefPub kzIDE},
  location = {Ghent, Belgium},
  series = {IWST '12},
  x-country = {CL},
  x-pays = {FR,CL}}


