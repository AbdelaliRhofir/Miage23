## SAHED Anis 
Durant cette semaine, j'ai appris les notions suivantes : 
<ul>
    <li>Revision sur les bases de l'héritage (héritage simple, différence héritage d'état et héritage du comportement)</li>
    <li>Revision du Lookup Method (signification du self, super et comment la recherche se fait dans les deux cas)</li>
    <li>La méthode doesNotUnderstand : méthode de la classe Object qui est executée lorsque le message envoyé à l'objet n'existe pas. Elle lève une exception MessageNotUnderstood qui pourrait être traitée. On peut aussi redéfinir la méthode doesNotUnderstand afin de spécifier le comportement souhaité lorsque le message envoyé est introuvable.</li>
    <li>Les classes sont des objets donc elles peuvent elle aussi recevoir des messages</li>
    <li>Chaque classe est une instance d'une autre classe appellée MetaClass</li>
    <li>Lookup in MetaClass (même principes que pour les classes basiques)</li>
    <li>Signification des flèches des dessins : flèches de surclassage et flèches d'instanciation</li>
    <li>Pour exécuter une méthode de classe envoyer le message à la classe contenant la méthode</li>
    <li>Pharo Web Stack : le framework Web Seaside, le framework de Persistance Voyage et le Magritte framework</li>
    <li>renderContentOn est une méthode du framework Seaside qui permet de transformer un composant en html</li>
    <li>Utilité du DSL de Seaside pour générer facilement de l'HTML</li>
    <li>Rest API sous Seaside (traitement des requêtes get, post)</li>
    <li>Framework de persistance Voyage qui permet grâce à la méthode isVoyageRoot de rendre les objets persistants dans une base de données MongoDB</li>
</ul>
